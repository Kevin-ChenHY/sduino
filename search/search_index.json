{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sduino Porting the most important features of the Arduino API to the STM8S. Within a few minutes you are ready to compile and upload your first STM8S-based project while still retaining the flexibility to use ST's SPL functions. All you need to get started is a simple STM8S103F breakout board for 70 cents and a ST-Link V2 compatible flash programmer for $2.50. Three boards and one flash programmer together are available for well under five dollars including shipping on aliexpress . Amazing! Usage The recommanded way of installation is now the Arduino Board Manager: Open the Settings tab of the Preferences dialog Enter https://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json as an Additional Boards Manager URL Select sduino in the Boards Manager list (Tools->Board:...->Boards Manager) Click on Install Wait for the download to finsh and you are ready to blink: Open the Boards list at Tools->Board:... You should find a new entry \"STM8S Boards\". Choose STM8S103F3 Breakout Board from the list Open the standard Blink example from File->Examples->01. Basics->Blink Compile it by hitting 'Verify' Easy, isn't it? In order to upload the compiled sketch to a connected board you need to install your flash tool . Included libraries Some Arduino libraries are already ported to C-syntax. The resulting API is still very close to the C++ version and porting an existing application is not hard. Check out the API migration guidelines for details. Communication SPI : Real hardware-SPI up to 10MHz. I2C : Port of the I2C master library by Wayne Truchsess HardwareSerial : The standard serial interface. Displays LiquidCrystal : HD44780 based text LCDs PCD8544 : Monochrome graphical LCD based on the PCD8544 controller like the Nokia 5110 display. SPI mode only. Mini_SSD1306 : SSD1306-based monochrome OLED displays with 128x64 pixels. I2C support only. Motor control Stepper : Stepper motors with 2, 4 or 5 phases. Servo : Up to 12 servos using only 1 timer. Supported hardware The one-dollar-boards : A simple STM8S103 breakout board build around a CPU STM8S103F3P6. It costs less than a dollar. The CPU features a 16MHz internal oscillator, 8kB flash, 1kB RAM, 640 byte EEPROM. It includes an UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 14 I/O pins - quite similar to an Atmel ATmega8. The ESP14 Wifi-boards are very similar. They are basically a variant of these boards with an added ESP-01 Wifi-module. Almost all programs should run on those chinese Wifi-enabled gems as well. The STM8S105Discovery-boards are very similar to an Arduino Uno with an ATmega328 CPU. The support for the used STM8S105 CPU is still quite fresh but it should work now. The sduino Uno is similar to the STM8S105Discovery board, but build to the same form factor as the Arduino Uno and using a very similar pin mapping. These boards are not (yet?) commercially available, but all the design files are free to use. China-gagets based on the STM8S003 like the ESP14 Wifi-board , the W1209 thermostat controller , the HC12 wireless transceiver module and many others. Limitations SDCC doesn't support C++. Some preprocessor magic is applied to close the gap between C and C++ syntax as much as possible, but this is not a 100% compatible drop-in replacement for full Arduino environments like for AVR or STM32. See Limitations and the migration guidelines for details. Supported Systems Linux 64 bit: Tested on Ubuntu 20.04, 18.04, 16.04 Linux 32 bit: Tested on Ubuntu 18.04, 16.04 Windows: Tested on Windows 7. Sduino might work on XP (not tested), but the ST-Link/V2 driver is not available anymore for XP. MacOS: Tested on 10.12 (Sierra) Raspian/Raspberry Pi: Untested. Will require a manual install.","title":"Introduction"},{"location":"#sduino","text":"Porting the most important features of the Arduino API to the STM8S. Within a few minutes you are ready to compile and upload your first STM8S-based project while still retaining the flexibility to use ST's SPL functions. All you need to get started is a simple STM8S103F breakout board for 70 cents and a ST-Link V2 compatible flash programmer for $2.50. Three boards and one flash programmer together are available for well under five dollars including shipping on aliexpress . Amazing!","title":"Sduino"},{"location":"#usage","text":"The recommanded way of installation is now the Arduino Board Manager: Open the Settings tab of the Preferences dialog Enter https://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json as an Additional Boards Manager URL Select sduino in the Boards Manager list (Tools->Board:...->Boards Manager) Click on Install Wait for the download to finsh and you are ready to blink: Open the Boards list at Tools->Board:... You should find a new entry \"STM8S Boards\". Choose STM8S103F3 Breakout Board from the list Open the standard Blink example from File->Examples->01. Basics->Blink Compile it by hitting 'Verify' Easy, isn't it? In order to upload the compiled sketch to a connected board you need to install your flash tool .","title":"Usage"},{"location":"#included-libraries","text":"Some Arduino libraries are already ported to C-syntax. The resulting API is still very close to the C++ version and porting an existing application is not hard. Check out the API migration guidelines for details.","title":"Included libraries"},{"location":"#communication","text":"SPI : Real hardware-SPI up to 10MHz. I2C : Port of the I2C master library by Wayne Truchsess HardwareSerial : The standard serial interface.","title":"Communication"},{"location":"#displays","text":"LiquidCrystal : HD44780 based text LCDs PCD8544 : Monochrome graphical LCD based on the PCD8544 controller like the Nokia 5110 display. SPI mode only. Mini_SSD1306 : SSD1306-based monochrome OLED displays with 128x64 pixels. I2C support only.","title":"Displays"},{"location":"#motor-control","text":"Stepper : Stepper motors with 2, 4 or 5 phases. Servo : Up to 12 servos using only 1 timer.","title":"Motor control"},{"location":"#supported-hardware","text":"The one-dollar-boards : A simple STM8S103 breakout board build around a CPU STM8S103F3P6. It costs less than a dollar. The CPU features a 16MHz internal oscillator, 8kB flash, 1kB RAM, 640 byte EEPROM. It includes an UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 14 I/O pins - quite similar to an Atmel ATmega8. The ESP14 Wifi-boards are very similar. They are basically a variant of these boards with an added ESP-01 Wifi-module. Almost all programs should run on those chinese Wifi-enabled gems as well. The STM8S105Discovery-boards are very similar to an Arduino Uno with an ATmega328 CPU. The support for the used STM8S105 CPU is still quite fresh but it should work now. The sduino Uno is similar to the STM8S105Discovery board, but build to the same form factor as the Arduino Uno and using a very similar pin mapping. These boards are not (yet?) commercially available, but all the design files are free to use. China-gagets based on the STM8S003 like the ESP14 Wifi-board , the W1209 thermostat controller , the HC12 wireless transceiver module and many others.","title":"Supported hardware"},{"location":"#limitations","text":"SDCC doesn't support C++. Some preprocessor magic is applied to close the gap between C and C++ syntax as much as possible, but this is not a 100% compatible drop-in replacement for full Arduino environments like for AVR or STM32. See Limitations and the migration guidelines for details.","title":"Limitations"},{"location":"#supported-systems","text":"Linux 64 bit: Tested on Ubuntu 20.04, 18.04, 16.04 Linux 32 bit: Tested on Ubuntu 18.04, 16.04 Windows: Tested on Windows 7. Sduino might work on XP (not tested), but the ST-Link/V2 driver is not available anymore for XP. MacOS: Tested on 10.12 (Sierra) Raspian/Raspberry Pi: Untested. Will require a manual install.","title":"Supported Systems"},{"location":"about/","text":"About Sduino The idea is to smoothen the path towards your first successful STM8-based project. The Arduino project was very successful in offering a simplified API hiding most of the complexity of embedded system programming while still allowing for advanced programming technics. The SPL (standard peripheral library) offered by ST is very powerful and provides an relativly easy migration path towards the STM32 CPU series in case a project outgrows the capabilities of the 8-bit STM8 series. But using that library is not very intuitive and still requires a fairly detailed knowledge of the CPU internals. compiling the SPL with SDCC Tools used This project is based on free tools that are available for Linux, MacOS, and Windows. It uses the small devices C compiler (SDCC) for compiling, stm8flash for uploading the binary to the CPU, and simple Makefiles for the build process. Support for the Cosmic compiler under Windows and integration into the ST visual developer IDE might be possible, but is not done (yet?). The build process is controlled by a makefile based on the amazing Arduino.mk makefile by Sudar . Project origin For a customer I needed to port an existing project from an ATmega to a better suited (read: cheaper) platform. As the project was based on some Arduino libraries, porting parts of the Arduino environment was the logical first step. After doing that porting the firmware was finished in a couple of days. Porting some of the more commonly used Arduino libraries was a fun project done in my spare time later. About me I am a freelance programmer for embedded systems and electronics developer based in Heidelberg, Germany. I work with embedded systems for more than 25 years now. Experiences current CPU architectures : AVR (ATmega, ATxmega), PIC, STM8, STM32, MCS51 classic CPU architectures : 6502, 68HC11, 6809, Z80, MCS48 electronics development : optical sensors, laser driver, sensor electronics, measurement equipment, industrial control, SMPS, displays (LCD, TFT)","title":"About"},{"location":"about/#about-sduino","text":"The idea is to smoothen the path towards your first successful STM8-based project. The Arduino project was very successful in offering a simplified API hiding most of the complexity of embedded system programming while still allowing for advanced programming technics. The SPL (standard peripheral library) offered by ST is very powerful and provides an relativly easy migration path towards the STM32 CPU series in case a project outgrows the capabilities of the 8-bit STM8 series. But using that library is not very intuitive and still requires a fairly detailed knowledge of the CPU internals. compiling the SPL with SDCC","title":"About Sduino"},{"location":"about/#tools-used","text":"This project is based on free tools that are available for Linux, MacOS, and Windows. It uses the small devices C compiler (SDCC) for compiling, stm8flash for uploading the binary to the CPU, and simple Makefiles for the build process. Support for the Cosmic compiler under Windows and integration into the ST visual developer IDE might be possible, but is not done (yet?). The build process is controlled by a makefile based on the amazing Arduino.mk makefile by Sudar .","title":"Tools used"},{"location":"about/#project-origin","text":"For a customer I needed to port an existing project from an ATmega to a better suited (read: cheaper) platform. As the project was based on some Arduino libraries, porting parts of the Arduino environment was the logical first step. After doing that porting the firmware was finished in a couple of days. Porting some of the more commonly used Arduino libraries was a fun project done in my spare time later.","title":"Project origin"},{"location":"about/#about-me","text":"I am a freelance programmer for embedded systems and electronics developer based in Heidelberg, Germany. I work with embedded systems for more than 25 years now.","title":"About me"},{"location":"about/#experiences","text":"current CPU architectures : AVR (ATmega, ATxmega), PIC, STM8, STM32, MCS51 classic CPU architectures : 6502, 68HC11, 6809, Z80, MCS48 electronics development : optical sensors, laser driver, sensor electronics, measurement equipment, industrial control, SMPS, displays (LCD, TFT)","title":"Experiences"},{"location":"contact/","text":"Contact Bug reports and other issues tightly related to the repository github issue tracker . More general topics and suggestions During the transfer of the STM32duinoforum from Roger Clark to STM the old STM8 board got lost somehow, but the old postings are archived and still readable . There is a new STM8 board in the stm32duino forum. I was re-started on Oktober 2020, so there aren't many messages there yet. is not much going on there, but it is still the place to go to. email Please find my address in the commit messages of the repository (as a simple captcha test) or use the alias address sduino@gmx.de","title":"Contact"},{"location":"contact/#contact","text":"","title":"Contact"},{"location":"contact/#bug-reports-and-other-issues-tightly-related-to-the-repository","text":"github issue tracker .","title":"Bug reports and other issues tightly related to the repository"},{"location":"contact/#more-general-topics-and-suggestions","text":"During the transfer of the STM32duinoforum from Roger Clark to STM the old STM8 board got lost somehow, but the old postings are archived and still readable . There is a new STM8 board in the stm32duino forum. I was re-started on Oktober 2020, so there aren't many messages there yet. is not much going on there, but it is still the place to go to.","title":"More general topics and suggestions"},{"location":"contact/#email","text":"Please find my address in the commit messages of the repository (as a simple captcha test) or use the alias address sduino@gmx.de","title":"email"},{"location":"api/EEPROM/","text":"EEPROM This is a library to access the built-in EEPROM of the STM8 MCUs. It does not work with external I2C or SPI-EEPROM. It is based on the Arduino EEPROM Library V2.0 by Christopher Andrews. In addition to the common Arduino-methods it defines some functions for low-level access. These functions behave similar to the built-in AVR functions. (see below ) Arduino-API This is a pre-instantiated singleton library. It is not possible to use more than one instance per sketch or to change the instance name. The API syntax is very similar to the original C++ syntax. In most cases replacing the dots in the method names for underscores is all it needs. Only the EEPROM[] operator and the EEPtr and EERef behave a little different than their Arduino counterparts. Arduino syntax sduino syntax val = EEPROM.read(idx) val = EEPROM_read(idx) EEPROM.write(idx, val) EEPROM_write(idx, val) EEPROM.update(idx, val) EEPROM_update(idx, val) val = EEPROM.begin() val = EEPROM_begin() val = EEPROM.end() val = EEPROM_end() val = EEPROM.length() val = EEPROM_length() EEPROM.put(idx,T) EEPROM_put(idx,T) EEPROM.get(idx,T) EEPROM_get(idx,T) EEPROM[idx] EEPROM_cell[idx] EEPROM_read( address ) [ example ] This function allows you to read a single byte of data from the eeprom. Its only parameter is an int which should be set to the address you wish to read. The function returns an unsigned char containing the value read. EEPROM_write( address, value ) [ example ] The EEPROM_write() method allows you to write a single byte of data to the EEPROM. Two parameters are needed. The first is an int containing the address that is to be written, and the second is a the data to be written ( unsigned char ). This function does not return any value. EEPROM_update( address, value ) [ example ] This function is similar to EEPROM_write() however this method will only write data if the cell contents pointed to by address is different to value . This method can help prevent unnecessary wear on the EEPROM cells. This function does not return any value. EEPROM_get( address, object ) [ example ] This function will retrieve any object from the EEPROM. Two parameters are needed to call this function. The first is an int containing the address that is to be written, and the second is the object you would like to read. This function is implemented as a macro. On completion, it evaluates to a pointer to the object passed in. It does not need to be used and is only returned for convience. Note: This means that the expression for object will be evaluated twice. This will break sketches using pre- or postincrement operators, because they will end up beeing called twice. EEPROM_put( address, object ) [ example ] This function will write any object to the EEPROM. Two parameters are needed to call this function. The first is an int containing the address that is to be written, and the second is the object you would like to write. This function uses the update method to write its data, and therefore only rewrites changed cells. This function is implemented as a macro using &object and sizeof(object) to reference the actual data to be written. This means that: integer constants can't be directly written, EEPROM_put(0,42) will fail. The expression for object will be evaluated twice. This will break sketches using pre- or postincrement operators. This macro evaluates to a pointer to the object passed in. It does not need to be used and is only returned for convience. EEPROM_length() This function returns an unsigned int containing the number of cells in the EEPROM. EEPROM_begin() This function returns the number of the first cell in the EEPROM. This is similar to the semantics of the original libray, where this method is ment for use with STL objects, custom iteration and C++11 style ranged for loops. EEPROM_end() This function returns the number just behind the last EEPROM cell. Since the EEPROM cells always start at zero this is the number of EEPROM cells. Used with EEPROM_begin() to provide custom iteration. Subscript operator: EEPROM_cell[address] Use the syntax EEPROM_cell[address] instead. This allows acessing the EEPROM like an array. EEPROM cells can be read and written directly using this method. Note: For write access, the EEPROM has to be unlocked by calling eeprom_unlock() first. Trying to write the EEPROM without unlocking will permanently lock the EEPROM after three failed write accesses. Only a hardware reset can re-enable the EEPROM. Please keep in mind that every call of EEPROM_write() or EEPROM_update() re-locks the EEPROM after the access. AVR-API In addition to the common Arduino-methods it defines some functions for low-level access. These functions behave similar to the built-in AVR functions. For the sake of compatibility to the Arduino world all EEPROM addresses start at zero at the needed offset calculation is handled internally. AVR/Arduino syntax sduino syntax Description N/A eeprom_unlock() N/A eeprom_lock() N/A s = eeprom_is_unlocked() returns true if EEPROM is unlocked s = eeprom_is_ready() s = eeprom_is_ready() returns true if EEPROM is ready (no write in progress) eeprom_write_block(idx, *src, len) eeprom_write_block(idx, *src, len) eeprom_update_block(idx, *src, len) eeprom_update_block(idx, *src, len) eeprom_read_block(idx, *dest, len) eeprom_read_block(idx, *dest, len) Access control: eeprom_lock() / eeprom_unlock() To prevent accidental modifications of the EEPROM contents, write access is blocked by default. For write access, the EEPROM has to be unlocked first. This can be done by calling eeprom_unlock() . After accessing the EEPROM it can be re-locked by calling eeprom_lock() . Please keep in mind that every call of EEPROM_write() or EEPROM_update() re-locks the EEPROM after the access. Note: Without unlocking, the EEPROM will be permanently locked until the next hardware reset after three failed write accesses. Status check: eeprom_is_ready() A write access is slow. To avoid stalling the MCU for a longer time by busy waiting it is possible to check the current write status. This can be used to spread out single byte writes over time and use the waiting time in a more productive way. This macro returns a non-zero value if the EEPROM is ready for a new write access. Example Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. #include <EEPROM.h> int addr = 0; void setup() { } void loop() { int val = analogRead(0) / 4; EEPROM_write(addr, val); addr = addr + 1; if (addr == EEPROM_length()) { addr = 0; } delay(100); } Accessing the EEPROM using stm8flash Write simple test data: $ echo -n \"abcdefgh\" > testdata.bin $ hd testdata.bin 00000000 61 62 63 64 65 66 67 68 |abcdefgh| 00000008 $ stm8flash -c stlinkv2 -p \"stm8s103?3\" -s eeprom -w testdata.bin Determine EEPROM area Due to its file extension (or lack thereof), \"testdata.bin\" is considered as RAW BINARY format! 8 bytes at 0x4000... OK Bytes written: 8 read the current EEPROM content: $ stm8flash -c stlinkv2 -p \"stm8s103?3\" -s eeprom -r e2.img Determine EEPROM area Due to its file extension (or lack thereof), \"e2.img\" is considered as RAW BINARY format! Reading 640 bytes at 0x4000... OK Bytes received: 640 $ hd e2.img 00000000 61 62 63 64 65 66 67 68 00 00 00 00 00 00 00 00 |abcdefgh........| 00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000280","title":"EEPROM"},{"location":"api/EEPROM/#eeprom","text":"This is a library to access the built-in EEPROM of the STM8 MCUs. It does not work with external I2C or SPI-EEPROM. It is based on the Arduino EEPROM Library V2.0 by Christopher Andrews. In addition to the common Arduino-methods it defines some functions for low-level access. These functions behave similar to the built-in AVR functions. (see below )","title":"EEPROM"},{"location":"api/EEPROM/#arduino-api","text":"This is a pre-instantiated singleton library. It is not possible to use more than one instance per sketch or to change the instance name. The API syntax is very similar to the original C++ syntax. In most cases replacing the dots in the method names for underscores is all it needs. Only the EEPROM[] operator and the EEPtr and EERef behave a little different than their Arduino counterparts. Arduino syntax sduino syntax val = EEPROM.read(idx) val = EEPROM_read(idx) EEPROM.write(idx, val) EEPROM_write(idx, val) EEPROM.update(idx, val) EEPROM_update(idx, val) val = EEPROM.begin() val = EEPROM_begin() val = EEPROM.end() val = EEPROM_end() val = EEPROM.length() val = EEPROM_length() EEPROM.put(idx,T) EEPROM_put(idx,T) EEPROM.get(idx,T) EEPROM_get(idx,T) EEPROM[idx] EEPROM_cell[idx]","title":"Arduino-API"},{"location":"api/EEPROM/#eeprom_read-address-example","text":"This function allows you to read a single byte of data from the eeprom. Its only parameter is an int which should be set to the address you wish to read. The function returns an unsigned char containing the value read.","title":"EEPROM_read( address ) [example]"},{"location":"api/EEPROM/#eeprom_write-address-value-example","text":"The EEPROM_write() method allows you to write a single byte of data to the EEPROM. Two parameters are needed. The first is an int containing the address that is to be written, and the second is a the data to be written ( unsigned char ). This function does not return any value.","title":"EEPROM_write( address, value ) [example]"},{"location":"api/EEPROM/#eeprom_update-address-value-example","text":"This function is similar to EEPROM_write() however this method will only write data if the cell contents pointed to by address is different to value . This method can help prevent unnecessary wear on the EEPROM cells. This function does not return any value.","title":"EEPROM_update( address, value ) [example]"},{"location":"api/EEPROM/#eeprom_get-address-object-example","text":"This function will retrieve any object from the EEPROM. Two parameters are needed to call this function. The first is an int containing the address that is to be written, and the second is the object you would like to read. This function is implemented as a macro. On completion, it evaluates to a pointer to the object passed in. It does not need to be used and is only returned for convience. Note: This means that the expression for object will be evaluated twice. This will break sketches using pre- or postincrement operators, because they will end up beeing called twice.","title":"EEPROM_get( address, object ) [example]"},{"location":"api/EEPROM/#eeprom_put-address-object-example","text":"This function will write any object to the EEPROM. Two parameters are needed to call this function. The first is an int containing the address that is to be written, and the second is the object you would like to write. This function uses the update method to write its data, and therefore only rewrites changed cells. This function is implemented as a macro using &object and sizeof(object) to reference the actual data to be written. This means that: integer constants can't be directly written, EEPROM_put(0,42) will fail. The expression for object will be evaluated twice. This will break sketches using pre- or postincrement operators. This macro evaluates to a pointer to the object passed in. It does not need to be used and is only returned for convience.","title":"EEPROM_put( address, object ) [example]"},{"location":"api/EEPROM/#eeprom_length","text":"This function returns an unsigned int containing the number of cells in the EEPROM.","title":"EEPROM_length()"},{"location":"api/EEPROM/#eeprom_begin","text":"This function returns the number of the first cell in the EEPROM. This is similar to the semantics of the original libray, where this method is ment for use with STL objects, custom iteration and C++11 style ranged for loops.","title":"EEPROM_begin()"},{"location":"api/EEPROM/#eeprom_end","text":"This function returns the number just behind the last EEPROM cell. Since the EEPROM cells always start at zero this is the number of EEPROM cells. Used with EEPROM_begin() to provide custom iteration.","title":"EEPROM_end()"},{"location":"api/EEPROM/#subscript-operator-eeprom_celladdress","text":"Use the syntax EEPROM_cell[address] instead. This allows acessing the EEPROM like an array. EEPROM cells can be read and written directly using this method. Note: For write access, the EEPROM has to be unlocked by calling eeprom_unlock() first. Trying to write the EEPROM without unlocking will permanently lock the EEPROM after three failed write accesses. Only a hardware reset can re-enable the EEPROM. Please keep in mind that every call of EEPROM_write() or EEPROM_update() re-locks the EEPROM after the access.","title":"Subscript operator: EEPROM_cell[address]"},{"location":"api/EEPROM/#avr-api","text":"In addition to the common Arduino-methods it defines some functions for low-level access. These functions behave similar to the built-in AVR functions. For the sake of compatibility to the Arduino world all EEPROM addresses start at zero at the needed offset calculation is handled internally. AVR/Arduino syntax sduino syntax Description N/A eeprom_unlock() N/A eeprom_lock() N/A s = eeprom_is_unlocked() returns true if EEPROM is unlocked s = eeprom_is_ready() s = eeprom_is_ready() returns true if EEPROM is ready (no write in progress) eeprom_write_block(idx, *src, len) eeprom_write_block(idx, *src, len) eeprom_update_block(idx, *src, len) eeprom_update_block(idx, *src, len) eeprom_read_block(idx, *dest, len) eeprom_read_block(idx, *dest, len)","title":"AVR-API"},{"location":"api/EEPROM/#access-control-eeprom_lockeeprom_unlock","text":"To prevent accidental modifications of the EEPROM contents, write access is blocked by default. For write access, the EEPROM has to be unlocked first. This can be done by calling eeprom_unlock() . After accessing the EEPROM it can be re-locked by calling eeprom_lock() . Please keep in mind that every call of EEPROM_write() or EEPROM_update() re-locks the EEPROM after the access. Note: Without unlocking, the EEPROM will be permanently locked until the next hardware reset after three failed write accesses.","title":"Access control: eeprom_lock()/eeprom_unlock()"},{"location":"api/EEPROM/#status-check-eeprom_is_ready","text":"A write access is slow. To avoid stalling the MCU for a longer time by busy waiting it is possible to check the current write status. This can be used to spread out single byte writes over time and use the waiting time in a more productive way. This macro returns a non-zero value if the EEPROM is ready for a new write access.","title":"Status check: eeprom_is_ready()"},{"location":"api/EEPROM/#example","text":"Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. #include <EEPROM.h> int addr = 0; void setup() { } void loop() { int val = analogRead(0) / 4; EEPROM_write(addr, val); addr = addr + 1; if (addr == EEPROM_length()) { addr = 0; } delay(100); }","title":"Example"},{"location":"api/EEPROM/#accessing-the-eeprom-using-stm8flash","text":"Write simple test data: $ echo -n \"abcdefgh\" > testdata.bin $ hd testdata.bin 00000000 61 62 63 64 65 66 67 68 |abcdefgh| 00000008 $ stm8flash -c stlinkv2 -p \"stm8s103?3\" -s eeprom -w testdata.bin Determine EEPROM area Due to its file extension (or lack thereof), \"testdata.bin\" is considered as RAW BINARY format! 8 bytes at 0x4000... OK Bytes written: 8 read the current EEPROM content: $ stm8flash -c stlinkv2 -p \"stm8s103?3\" -s eeprom -r e2.img Determine EEPROM area Due to its file extension (or lack thereof), \"e2.img\" is considered as RAW BINARY format! Reading 640 bytes at 0x4000... OK Bytes received: 640 $ hd e2.img 00000000 61 62 63 64 65 66 67 68 00 00 00 00 00 00 00 00 |abcdefgh........| 00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000280","title":"Accessing the EEPROM using stm8flash"},{"location":"api/HardwareSerial/","text":"HardwareSerial Uses the UART. API similar to Arduino. Single instance only. Pre-instanciated. This page is only a stub. API Example Implementation details Possible impovements","title":"HardwareSerial"},{"location":"api/HardwareSerial/#hardwareserial","text":"Uses the UART. API similar to Arduino. Single instance only. Pre-instanciated. This page is only a stub.","title":"HardwareSerial"},{"location":"api/HardwareSerial/#api","text":"","title":"API"},{"location":"api/HardwareSerial/#example","text":"","title":"Example"},{"location":"api/HardwareSerial/#implementation-details","text":"","title":"Implementation details"},{"location":"api/HardwareSerial/#possible-impovements","text":"","title":"Possible impovements"},{"location":"api/I2C/","text":"I2C The I2C master library by Wayne Truchsess offers some significant advantages over the Wire/TWI library included in the standard arduino environment: It fixes some possible deadlock situations, it allows for communication using a repeated start condition as required by some devices, the code is much more compact and the structure is easier to understand. API This is a pre-instantiated singleton library. It is not possible to use more than one instance per sketch or to change the instance name. The API syntax is very similar to the original C++ syntax. Some name mangeling was needed to distinguish the different variant of the read() and write() method. Apart from this replacing the dots in the method names for underscores is all it needs. The pullup setting is missing because this function is not supported by the STM8 hardware. Arduino syntax sduino syntax I2C.begin() I2C_begin() I2C.end() I2C_end() I2C.timeOut(val) I2C_timeOut(val) I2C.setSpeed(mode) I2C_setSpeed(mode) I2C.pullup(active) not implemented I2C.scan() I2C_scan() n = I2C.available() n = I2C_available() val = I2C.receive() val = I2C_receive() I2C.write(addr, val) I2C_write(addr, val) I2C.write(addr, reg, val) I2C_write_reg(addr, reg, val) I2C.write(addr, reg, string) I2C_write_s(addr, reg, string) I2C.write(addr, reg, *data, len) I2C_write_sn(addr, reg, *data, len) I2C.read(addr, n) I2C_read(addr, n) I2C.read(addr, reg, n) I2C_read_reg(addr, reg, n) I2C.read(addr, n, *buf) I2C_readbuf(addr, n, *buf) I2C.read(addr, reg, n, *buf) I2C_readbuf_reg(addr, reg, n, *buf) Error codes All functions return an error code. Return values for functions that use the timeOut feature will return at what point in the transmission the timeout occurred. Looking at a full communication sequence between a master and slave (transmit data and then readback data) there a total of 7 points in the sequence where a timeout can occur. These are listed below and correspond to the returned value. Errorcode Meaning: Waiting for... 0 Function executed with no errors 1 Waiting for successful completion of a Start bit 2 Waiting for ACK/NACK while addressing slave in transmit mode (MT) 3 Waiting for ACK/NACK while sending data to the slave 4 Waiting for successful completion of a Repeated Start 5 Waiting for ACK/NACK while addressing slave in receiver mode (MR) 6 Waiting for ACK/NACK while receiving data from the slave 7 Waiting for successful completion of the Stop bit AVR error codes For reference: The codes listed below where defined for the AVR, but they don't exist for the STM8 implementation. Combining the values of SR1 and SR2 it would be possible to implement most of these conditions (apart from 0x20), but so far I haven't seen any program needing these values, so I didn't implement this. Status Codes for Master Transmitter Mode 0x08 A START condition has been transmitted 0x10 A repeated START condition has been transmitted 0x18 SLA+W has been transmitted; ACK has been received 0x20 SLA+W has been transmitted; NOT ACK has been received 0x28 Data byte has been transmitted; ACK has been received 0x30 Data byte has been transmitted; NOT ACK has been received 0x38 Arbitration lost in SLA+W or data bytes Status Codes for Master Receiver Mode 0x08 A START condition has been transmitted 0x10 A repeated START condition has been transmitted 0x38 Arbitration lost in SLA+R or NOT ACK bit 0x40 SLA+R has been transmitted; ACK has been received 0x48 SLA+R has been transmitted; NOT ACK has been received 0x50 Data byte has been received; ACK has been returned 0x58 Data byte has been received; NOT ACK has been returned Status Codes independed of mode 0xF8 No relevant state information available; TWINT = \u201c0\u201d 0x00 Bus error due to an illegal START or STOP condition inner workings start(): Sends start bit, does not wait for SB flag. sendAddress() Further reading Programming the I2C communication on the register level is quite complex for the STM8, especially in receive mode. The most detailed information on this topic is the application note AN3281 bundeled with the related source code package STSW-STM8004 Downloading from the ST website requires a (free) registration. Somebody uploaded the full package to github: https://github.com/jiaohaitao/stsw-stm8004 There are some important notes on I2C implementation in the errata sheets: STM8S001J3/003xx/103xx/903xx Errata sheet, rev. 5 (CD00265449) STM8S005xx STM8S105xx Errata sheet, rev. 7 (CD00270741) STM8S007xx STM8S20xxx Errata sheet, rev. 6 (CD00244749)","title":"I2C"},{"location":"api/I2C/#i2c","text":"The I2C master library by Wayne Truchsess offers some significant advantages over the Wire/TWI library included in the standard arduino environment: It fixes some possible deadlock situations, it allows for communication using a repeated start condition as required by some devices, the code is much more compact and the structure is easier to understand.","title":"I2C"},{"location":"api/I2C/#api","text":"This is a pre-instantiated singleton library. It is not possible to use more than one instance per sketch or to change the instance name. The API syntax is very similar to the original C++ syntax. Some name mangeling was needed to distinguish the different variant of the read() and write() method. Apart from this replacing the dots in the method names for underscores is all it needs. The pullup setting is missing because this function is not supported by the STM8 hardware. Arduino syntax sduino syntax I2C.begin() I2C_begin() I2C.end() I2C_end() I2C.timeOut(val) I2C_timeOut(val) I2C.setSpeed(mode) I2C_setSpeed(mode) I2C.pullup(active) not implemented I2C.scan() I2C_scan() n = I2C.available() n = I2C_available() val = I2C.receive() val = I2C_receive() I2C.write(addr, val) I2C_write(addr, val) I2C.write(addr, reg, val) I2C_write_reg(addr, reg, val) I2C.write(addr, reg, string) I2C_write_s(addr, reg, string) I2C.write(addr, reg, *data, len) I2C_write_sn(addr, reg, *data, len) I2C.read(addr, n) I2C_read(addr, n) I2C.read(addr, reg, n) I2C_read_reg(addr, reg, n) I2C.read(addr, n, *buf) I2C_readbuf(addr, n, *buf) I2C.read(addr, reg, n, *buf) I2C_readbuf_reg(addr, reg, n, *buf)","title":"API"},{"location":"api/I2C/#error-codes","text":"All functions return an error code. Return values for functions that use the timeOut feature will return at what point in the transmission the timeout occurred. Looking at a full communication sequence between a master and slave (transmit data and then readback data) there a total of 7 points in the sequence where a timeout can occur. These are listed below and correspond to the returned value. Errorcode Meaning: Waiting for... 0 Function executed with no errors 1 Waiting for successful completion of a Start bit 2 Waiting for ACK/NACK while addressing slave in transmit mode (MT) 3 Waiting for ACK/NACK while sending data to the slave 4 Waiting for successful completion of a Repeated Start 5 Waiting for ACK/NACK while addressing slave in receiver mode (MR) 6 Waiting for ACK/NACK while receiving data from the slave 7 Waiting for successful completion of the Stop bit","title":"Error codes"},{"location":"api/I2C/#avr-error-codes","text":"For reference: The codes listed below where defined for the AVR, but they don't exist for the STM8 implementation. Combining the values of SR1 and SR2 it would be possible to implement most of these conditions (apart from 0x20), but so far I haven't seen any program needing these values, so I didn't implement this. Status Codes for Master Transmitter Mode 0x08 A START condition has been transmitted 0x10 A repeated START condition has been transmitted 0x18 SLA+W has been transmitted; ACK has been received 0x20 SLA+W has been transmitted; NOT ACK has been received 0x28 Data byte has been transmitted; ACK has been received 0x30 Data byte has been transmitted; NOT ACK has been received 0x38 Arbitration lost in SLA+W or data bytes Status Codes for Master Receiver Mode 0x08 A START condition has been transmitted 0x10 A repeated START condition has been transmitted 0x38 Arbitration lost in SLA+R or NOT ACK bit 0x40 SLA+R has been transmitted; ACK has been received 0x48 SLA+R has been transmitted; NOT ACK has been received 0x50 Data byte has been received; ACK has been returned 0x58 Data byte has been received; NOT ACK has been returned Status Codes independed of mode 0xF8 No relevant state information available; TWINT = \u201c0\u201d 0x00 Bus error due to an illegal START or STOP condition","title":"AVR error codes"},{"location":"api/I2C/#inner-workings","text":"start(): Sends start bit, does not wait for SB flag. sendAddress()","title":"inner workings"},{"location":"api/I2C/#further-reading","text":"Programming the I2C communication on the register level is quite complex for the STM8, especially in receive mode. The most detailed information on this topic is the application note AN3281 bundeled with the related source code package STSW-STM8004 Downloading from the ST website requires a (free) registration. Somebody uploaded the full package to github: https://github.com/jiaohaitao/stsw-stm8004 There are some important notes on I2C implementation in the errata sheets: STM8S001J3/003xx/103xx/903xx Errata sheet, rev. 5 (CD00265449) STM8S005xx STM8S105xx Errata sheet, rev. 7 (CD00270741) STM8S007xx STM8S20xxx Errata sheet, rev. 6 (CD00244749)","title":"Further reading"},{"location":"api/LiquidCrystal/","text":"LiquidCrystal Library This library is for character LCDs based on the HD44780 controller. Derived from the Arduino LiquidCrystal library v1.8.0. API This library is a singleton library, it is not possible to use more than one instance per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . Apart from the usual name mangeling for polymorph functions (mostly the different variants of the Print::print method) moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores is all it needs. Arduino syntax sduino syntax LiquidCrystal lcd(rs,en,d0,d1,d2,d3) LiquidCrystal (lcd,rs,en,d0,d1,d2,d3) LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3) LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3) LiquidCrystal lcd(rs,en,d0,d1,d2,d3,d4,d5,d6,d7) LiquidCrystal (lcd,rs,en,d0,d1,d2,d3,d4,d5,d6,d7) LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) lcd.init(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) lcd_init(mode,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) lcd.begin(cols,lines) lcd_begin(cols,lines) lcd.begin(cols,lines,charsize) lcd_begin_charsize(cols,lines,charsize) lcd.clear() lcd_clear() lcd.home() lcd_home() lcd.noDisplay() lcd_noDisplay() lcd.display() lcd_display() lcd.noBlink() lcd_noBlink() lcd.blink() lcd_blink() lcd.noCursor() lcd_noCursor() lcd.cursor() lcd_cursor() lcd.scrollDisplayLeft() lcd_scrollDisplayLeft() lcd.scrollDisplayRight() lcd_scrollDisplayRight() lcd.leftToRight() lcd_leftToRight() lcd.rightToLeft() lcd_rightToLeft() lcd.noAutoscroll() lcd_noAutoscroll() lcd.autoscroll() lcd_autoscroll() lcd.setRowOffsets(row0,row1,row2,row3) lcd_setRowOffsets(row0,row1,row2,row3) lcd.createChar(number, data[]) lcd_createChar(number, data[]) lcd.setCursor(col,row) lcd_setCursor(col,row) result = lcd.write(value) result = lcd_write(value) lcd.command(value) lcd_command(value) The LCD interface mode can be changed at run time by calling the lcd_init(...) function. Example Output some Text and count the time since the last reset. Notice the slightly different position of the opening parenthesis at the \"class constructor\" function LiquidCrystal compared to the C++ instatiation. #include <Arduino.h> #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins // The instance name \"lcd\" is *within* the brackets LiquidCrystal (lcd,PA1,PA2, PA3,PD2,PD3,PD4); void setup() { lcd_begin(16, 2); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); } Compare it to the original Arduino C++-Sytax: #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins // The instance name \"lcd\" is *before* the brackets LiquidCrystal lcd(12, 11, 5, 4, 3, 2); void setup() { lcd.begin(16, 2); lcd.print(\"hello, world!\"); } void loop() { lcd.setCursor(0, 1); lcd.print(millis() / 1000); } Possible improvements This is not a to-do-list, just brainstorming and a collection of random thoughts. Direct port access As long as the pin numberings are known at compile time it would be possible use direct port register access and the access pattern could be optimized if all data pins are on the same port. Auto-detect 4-bit mode The parameter fourbitmode of the init() function/method is not needed. It would be sufficient to check d5 for a valid value. If it is not valid, assume 4-bit mode. As init() is not called very frequently the possible advantage would be small compared to the downside of breaking the Arduino compatibility.","title":"LiquidCrystal character LCD library"},{"location":"api/LiquidCrystal/#liquidcrystal-library","text":"This library is for character LCDs based on the HD44780 controller. Derived from the Arduino LiquidCrystal library v1.8.0.","title":"LiquidCrystal Library"},{"location":"api/LiquidCrystal/#api","text":"This library is a singleton library, it is not possible to use more than one instance per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . Apart from the usual name mangeling for polymorph functions (mostly the different variants of the Print::print method) moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores is all it needs. Arduino syntax sduino syntax LiquidCrystal lcd(rs,en,d0,d1,d2,d3) LiquidCrystal (lcd,rs,en,d0,d1,d2,d3) LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3) LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3) LiquidCrystal lcd(rs,en,d0,d1,d2,d3,d4,d5,d6,d7) LiquidCrystal (lcd,rs,en,d0,d1,d2,d3,d4,d5,d6,d7) LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) lcd.init(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) lcd_init(mode,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7) lcd.begin(cols,lines) lcd_begin(cols,lines) lcd.begin(cols,lines,charsize) lcd_begin_charsize(cols,lines,charsize) lcd.clear() lcd_clear() lcd.home() lcd_home() lcd.noDisplay() lcd_noDisplay() lcd.display() lcd_display() lcd.noBlink() lcd_noBlink() lcd.blink() lcd_blink() lcd.noCursor() lcd_noCursor() lcd.cursor() lcd_cursor() lcd.scrollDisplayLeft() lcd_scrollDisplayLeft() lcd.scrollDisplayRight() lcd_scrollDisplayRight() lcd.leftToRight() lcd_leftToRight() lcd.rightToLeft() lcd_rightToLeft() lcd.noAutoscroll() lcd_noAutoscroll() lcd.autoscroll() lcd_autoscroll() lcd.setRowOffsets(row0,row1,row2,row3) lcd_setRowOffsets(row0,row1,row2,row3) lcd.createChar(number, data[]) lcd_createChar(number, data[]) lcd.setCursor(col,row) lcd_setCursor(col,row) result = lcd.write(value) result = lcd_write(value) lcd.command(value) lcd_command(value) The LCD interface mode can be changed at run time by calling the lcd_init(...) function.","title":"API"},{"location":"api/LiquidCrystal/#example","text":"Output some Text and count the time since the last reset. Notice the slightly different position of the opening parenthesis at the \"class constructor\" function LiquidCrystal compared to the C++ instatiation. #include <Arduino.h> #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins // The instance name \"lcd\" is *within* the brackets LiquidCrystal (lcd,PA1,PA2, PA3,PD2,PD3,PD4); void setup() { lcd_begin(16, 2); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); } Compare it to the original Arduino C++-Sytax: #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins // The instance name \"lcd\" is *before* the brackets LiquidCrystal lcd(12, 11, 5, 4, 3, 2); void setup() { lcd.begin(16, 2); lcd.print(\"hello, world!\"); } void loop() { lcd.setCursor(0, 1); lcd.print(millis() / 1000); }","title":"Example"},{"location":"api/LiquidCrystal/#possible-improvements","text":"This is not a to-do-list, just brainstorming and a collection of random thoughts.","title":"Possible improvements"},{"location":"api/LiquidCrystal/#direct-port-access","text":"As long as the pin numberings are known at compile time it would be possible use direct port register access and the access pattern could be optimized if all data pins are on the same port.","title":"Direct port access"},{"location":"api/LiquidCrystal/#auto-detect-4-bit-mode","text":"The parameter fourbitmode of the init() function/method is not needed. It would be sufficient to check d5 for a valid value. If it is not valid, assume 4-bit mode. As init() is not called very frequently the possible advantage would be small compared to the downside of breaking the Arduino compatibility.","title":"Auto-detect 4-bit mode"},{"location":"api/LiquidCrystal_I2C/","text":"LiquidCrystal_I2C Library This library is for character LCDs based on the HD44780 controller connected via I2C bus using the cheap I2C backpack modules based on the PCF8574(T/A). It is derived from the LiquidCrystal_I2C library as of 09.05.2017 ( commit e3701fb ). by Frank de Brabander . API The API is very similar (but, for unknown reasons, not identical) to the API used by the Arduino LiquidCrystal library for text LCDs with a parallel interface. This library is a singleton library, it is not possible to use more than one instance per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . Apart from the usual name mangeling for polymorph functions (mostly the different variants of the Print::print method) moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores is all it needs. The original version of the LiquidCystal_I2C library requires the definition of the LCD size and the desired character size (8 or 10 pixel height) at the instantiation and uses a parameterless begin() method. This differs slightly from the semantic of the regular Arduino LiquidCrystal library using the parallel interface. There, the instantiation defines only the electrical connection (the used pin numbers) and defines the logical properties (cols, rows, charsize) later with the begin() method. As an addition to the Arduino version of this library this port supports both initialization styles. Arduino syntax sduino syntax LiquidCrystal_I2C lcd(i2c_addr,cols,rows,charsize) LiquidCrystal_I2C (lcd,i2c_addr,rows,cols,charsize) LiquidCrystal_I2C lcd(i2c_addr,cols,rows) LiquidCrystal_I2C (lcd,i2c_addr,rows) not allowed LiquidCrystal_I2C (lcd,i2c_addr) lcd.init(i2c_addr,cols,rows,charsize) lcd_init(i2c_addr,cols,rows,charsize) lcd.begin() lcd_begin() not allowed lcd_begin_wh(cols,rows) not allowed lcd_begin_full(cols,rows,charsize) lcd.clear() lcd_clear() lcd.home() lcd_home() lcd.noDisplay() lcd_noDisplay() lcd.display() lcd_display() lcd.noBlink() lcd_noBlink() lcd.blink() lcd_blink() lcd.noCursor() lcd_noCursor() lcd.cursor() lcd_cursor() lcd.scrollDisplayLeft() lcd_scrollDisplayLeft() lcd.scrollDisplayRight() lcd_scrollDisplayRight() lcd.printLeft() lcd_printLeft() lcd.printRight() lcd_printRight() lcd.leftToRight() lcd_leftToRight() lcd.rightToLeft() lcd_rightToLeft() lcd.shiftIncrement() lcd_shiftIncrement() lcd.shiftDecrement() lcd_shiftDecrement() lcd.noBacklight() lcd_noBacklight() lcd.Backlight() lcd_Backlight() result = lcd.getBacklight() result = lcd_getBacklight() lcd.noAutoscroll() lcd_noAutoscroll() lcd.autoscroll() lcd_autoscroll() lcd.createChar(number, data[]) lcd_createChar(number, data[]) lcd.setCursor(col,row) lcd_setCursor(col,row) result = lcd.write(value) result = lcd_write(value) lcd.command(value) lcd_command(value) The library supports the following alias definitions introduced by the original LiquidCrystal_I2C library. The use of these alias is depreciated and should be avoided: Arduino syntax sduino syntax lcd_blink_on() lcd_blink_on() lcd_blink_off() lcd_blink_off() lcd_cursor_on() lcd_cursor_on() lcd_cursor_off() lcd_cursor_off() lcd_setBacklight(new_val) lcd_setBacklight(new_val) lcd_load_custom_character(number, data[]) lcd_load_custom_character(number, data[]) lcd_printstr(string) lcd_printstr(string) Example Output some Text and count the time since the last reset. Notice the slightly different position of the opening parenthesis at the \"class constructor\" function LiquidCrystal_I2C compared to the C++ instatiation. #include <Arduino.h> #include <LiquidCrystal_I2C.h> // initialize the library with the I2C bus address // The instance name \"lcd\" is *within* the brackets LiquidCrystal_I2C (lcd,0x27,16,2); void setup() { lcd_begin(); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); } Compare this to the original Arduino C++-Sytax: #include <LiquidCrystal_I2C.h> // initialize the library with the I2C bus address // The instance name \"lcd\" is *before* the brackets LiquidCrystal_I2C lcd(0x27,16,2); void setup() { lcd.begin(); lcd.print(\"hello, world!\"); } void loop() { lcd.setCursor(0, 1); lcd.print(millis() / 1000); } As an extention to the original LiquidCrystal_I2C libray this Sduino port supports an initialisation similar to the syntax of the regular LiquidCrystal library: Defining only the electrical parameters at instantiation (I2C bus address) and giving the logical parameters (display size) with the begin() method: #include <Arduino.h> #include <LiquidCrystal_I2C.h> // initialize the library with the I2C bus address // The instance name \"lcd\" is *within* the brackets LiquidCrystal_I2C (lcd,0x27); void setup() { lcd_begin(16,2); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); } Pin connections The table shows the most common connection scheme as used by the popular backpack boards from China: PCF8574 bit Backpack pin LCD signal LCD pin 0 13 RS 4 1 12 R/-W 5 2 11 EN 6 3 1 LED- (open collector, inverted) 16 4 6 D4 11 5 5 D5 12 6 4 D6 13 7 3 D7 14 The numbering of the LCD connector counts in the opposite directions on the the LCD and the backpack module. It looks like the person designing the PCB layout got confused by the backwards mounting position ;-) But in reality it doesn't matter, they both fit together nicely. It is just a unfortunate silkscreen printing. Possible improvements This is not a to-do-list, just brainstorming and a collection of random thoughts. Further reading Detailed look at the PCF8574 I2C port expander","title":"LiquidCrystal_I2C character LCD connected via I2C backpack boards"},{"location":"api/LiquidCrystal_I2C/#liquidcrystal_i2c-library","text":"This library is for character LCDs based on the HD44780 controller connected via I2C bus using the cheap I2C backpack modules based on the PCF8574(T/A). It is derived from the LiquidCrystal_I2C library as of 09.05.2017 ( commit e3701fb ). by Frank de Brabander .","title":"LiquidCrystal_I2C Library"},{"location":"api/LiquidCrystal_I2C/#api","text":"The API is very similar (but, for unknown reasons, not identical) to the API used by the Arduino LiquidCrystal library for text LCDs with a parallel interface. This library is a singleton library, it is not possible to use more than one instance per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . Apart from the usual name mangeling for polymorph functions (mostly the different variants of the Print::print method) moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores is all it needs. The original version of the LiquidCystal_I2C library requires the definition of the LCD size and the desired character size (8 or 10 pixel height) at the instantiation and uses a parameterless begin() method. This differs slightly from the semantic of the regular Arduino LiquidCrystal library using the parallel interface. There, the instantiation defines only the electrical connection (the used pin numbers) and defines the logical properties (cols, rows, charsize) later with the begin() method. As an addition to the Arduino version of this library this port supports both initialization styles. Arduino syntax sduino syntax LiquidCrystal_I2C lcd(i2c_addr,cols,rows,charsize) LiquidCrystal_I2C (lcd,i2c_addr,rows,cols,charsize) LiquidCrystal_I2C lcd(i2c_addr,cols,rows) LiquidCrystal_I2C (lcd,i2c_addr,rows) not allowed LiquidCrystal_I2C (lcd,i2c_addr) lcd.init(i2c_addr,cols,rows,charsize) lcd_init(i2c_addr,cols,rows,charsize) lcd.begin() lcd_begin() not allowed lcd_begin_wh(cols,rows) not allowed lcd_begin_full(cols,rows,charsize) lcd.clear() lcd_clear() lcd.home() lcd_home() lcd.noDisplay() lcd_noDisplay() lcd.display() lcd_display() lcd.noBlink() lcd_noBlink() lcd.blink() lcd_blink() lcd.noCursor() lcd_noCursor() lcd.cursor() lcd_cursor() lcd.scrollDisplayLeft() lcd_scrollDisplayLeft() lcd.scrollDisplayRight() lcd_scrollDisplayRight() lcd.printLeft() lcd_printLeft() lcd.printRight() lcd_printRight() lcd.leftToRight() lcd_leftToRight() lcd.rightToLeft() lcd_rightToLeft() lcd.shiftIncrement() lcd_shiftIncrement() lcd.shiftDecrement() lcd_shiftDecrement() lcd.noBacklight() lcd_noBacklight() lcd.Backlight() lcd_Backlight() result = lcd.getBacklight() result = lcd_getBacklight() lcd.noAutoscroll() lcd_noAutoscroll() lcd.autoscroll() lcd_autoscroll() lcd.createChar(number, data[]) lcd_createChar(number, data[]) lcd.setCursor(col,row) lcd_setCursor(col,row) result = lcd.write(value) result = lcd_write(value) lcd.command(value) lcd_command(value) The library supports the following alias definitions introduced by the original LiquidCrystal_I2C library. The use of these alias is depreciated and should be avoided: Arduino syntax sduino syntax lcd_blink_on() lcd_blink_on() lcd_blink_off() lcd_blink_off() lcd_cursor_on() lcd_cursor_on() lcd_cursor_off() lcd_cursor_off() lcd_setBacklight(new_val) lcd_setBacklight(new_val) lcd_load_custom_character(number, data[]) lcd_load_custom_character(number, data[]) lcd_printstr(string) lcd_printstr(string)","title":"API"},{"location":"api/LiquidCrystal_I2C/#example","text":"Output some Text and count the time since the last reset. Notice the slightly different position of the opening parenthesis at the \"class constructor\" function LiquidCrystal_I2C compared to the C++ instatiation. #include <Arduino.h> #include <LiquidCrystal_I2C.h> // initialize the library with the I2C bus address // The instance name \"lcd\" is *within* the brackets LiquidCrystal_I2C (lcd,0x27,16,2); void setup() { lcd_begin(); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); } Compare this to the original Arduino C++-Sytax: #include <LiquidCrystal_I2C.h> // initialize the library with the I2C bus address // The instance name \"lcd\" is *before* the brackets LiquidCrystal_I2C lcd(0x27,16,2); void setup() { lcd.begin(); lcd.print(\"hello, world!\"); } void loop() { lcd.setCursor(0, 1); lcd.print(millis() / 1000); } As an extention to the original LiquidCrystal_I2C libray this Sduino port supports an initialisation similar to the syntax of the regular LiquidCrystal library: Defining only the electrical parameters at instantiation (I2C bus address) and giving the logical parameters (display size) with the begin() method: #include <Arduino.h> #include <LiquidCrystal_I2C.h> // initialize the library with the I2C bus address // The instance name \"lcd\" is *within* the brackets LiquidCrystal_I2C (lcd,0x27); void setup() { lcd_begin(16,2); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); }","title":"Example"},{"location":"api/LiquidCrystal_I2C/#pin-connections","text":"The table shows the most common connection scheme as used by the popular backpack boards from China: PCF8574 bit Backpack pin LCD signal LCD pin 0 13 RS 4 1 12 R/-W 5 2 11 EN 6 3 1 LED- (open collector, inverted) 16 4 6 D4 11 5 5 D5 12 6 4 D6 13 7 3 D7 14 The numbering of the LCD connector counts in the opposite directions on the the LCD and the backpack module. It looks like the person designing the PCB layout got confused by the backwards mounting position ;-) But in reality it doesn't matter, they both fit together nicely. It is just a unfortunate silkscreen printing.","title":"Pin connections"},{"location":"api/LiquidCrystal_I2C/#possible-improvements","text":"This is not a to-do-list, just brainstorming and a collection of random thoughts.","title":"Possible improvements"},{"location":"api/LiquidCrystal_I2C/#further-reading","text":"Detailed look at the PCF8574 I2C port expander","title":"Further reading"},{"location":"api/LiquidCrystal_pcf2119/","text":"LiquidCrystal_pcf2119 Library This library is for character LCDs based on the PCF2119 controller and connected via I2C. PCF2119 based displays are pretty rare in the wild, it is very likely that this is the wrong library for your display. The more common case is a LCD based on the HD44780 controller and a parallel interface connected to a small interface PCB with an I2C parallel interface PCF8544. These two interfaces are not compatible with each other. That kind of display will require the LiquidCrystal_I2C library instead. PCF2119 based displays seem to have been used in older fax machines and multi function printers, but thery are hard to come by nowerdays (read: expensive. North of 20\u20ac at Farnell). This Library is derived from the Arduino LiquidCrystal library v1.8.0 with some additions from the LiquidCrystal_I2C library. API This library is a singleton library, it is not possible to use more than one instance per sketch. This Library is an SDuino original: There is no preexisting Arduino library for this controller. The API syntax is designed to be very similar to the regular LiquidCrystal library for LCDs with a parallel interface. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . Apart from the usual name mangeling for polymorph functions (mostly the different variants of the Print::print method) moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores is all it needs. (hypotetical) Arduino syntax sduino syntax LiquidCrystal lcd(adr) LiquidCrystal (adr) LiquidCrystal lcd(adr,reset) LiquidCrystal (adr,reset) LiquidCrystal lcd(adr,reset,charset) LiquidCrystal (adr,reset,charset) lcd.init(adr,reset,charset) lcd_init(adr,reset,charset) lcd.begin(cols,lines) lcd_begin(cols,lines) lcd.begin(cols,lines,charsize) lcd_begin_charsize(cols,lines,charsize) lcd.clear() lcd_clear() lcd.home() lcd_home() lcd.noDisplay() lcd_noDisplay() lcd.display() lcd_display() lcd.noBlink() lcd_noBlink() lcd.blink() lcd_blink() lcd.noCursor() lcd_noCursor() lcd.cursor() lcd_cursor() lcd.scrollDisplayLeft() lcd_scrollDisplayLeft() lcd.scrollDisplayRight() lcd_scrollDisplayRight() lcd.leftToRight() lcd_leftToRight() lcd.rightToLeft() lcd_rightToLeft() lcd.noAutoscroll() lcd_noAutoscroll() lcd.autoscroll() lcd_autoscroll() lcd.createChar(number, data[]) lcd_createChar(number, data[]) lcd.setCursor(col,row) lcd_setCursor(col,row) result = lcd.write(value) result = lcd_write(value) result = lcd.data(value) result = lcd_data(value) lcd.command(value) lcd_command(value) Example Output some Text and count the time since the last reset. Notice the slightly different position of the opening parenthesis at the \"class constructor\" function LiquidCrystal compared to the C++ instatiation. #include <Arduino.h> #include <LiquidCrystal_pcf2119.h> // initialize the library with the number of the reset pin // The instance name \"lcd\" is *within* the brackets LiquidCrystal_pcf2119 (lcd,PA3); void setup() { lcd_begin(16, 2); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); } Compare it to the (hypotetical) Arduino C++-Sytax: #include <LiquidCrystal_pcf2119.h> // initialize the library with the number of the reset pin // The instance name \"lcd\" is *before* the brackets LiquidCrystal_pcf2119 lcd(2); void setup() { lcd.begin(16, 2); lcd.print(\"hello, world!\"); } void loop() { lcd.setCursor(0, 1); lcd.print(millis() / 1000); } Differences between this lib and LiquidCrystal_I2C Physical interface The PCF2119 supports the standard command set as the HD44780, the only visible difference is the physical interface. Supporting I2C natively means very easy read and write access, very similar to the ease of use of a fully connected 8 bit parallel interface without losing so many port pins. This library can be seen as an extended version of the regular LiquidCrystal_I2C using 8 bit mode instead of bit-banging a four bit interface. Or as an I2C-enabled version of LiquidCrystal in 8-bit mode. Character mapping This is a head-banging one. Such an engineering nonsense. The PCF2119 exists in six different versions, supporting six different character sets named A, D, F, I, R and S. See page 19ff in the datasheet . A is a standard ASCII mapping, R is the most random one where not even space is at the position it is supposed to be. And guess which character set is used by the modules still available at Farnell? Right, the R set. The left over ones no one was willing to buy so far. This means that the build-in clear function can't be used and the ShiftLeft/ShiftRight modes are not useful as they fill up the free space with 0x20 - which happens to be an arrow in this character set. Who came up with that idea? For character set A, D and I all data is always transferd unmodified. For character sets F, R and S the write() method transparently swaps the ASCII ranges 0x20..0x7f and 0xa0..0xff. This allows the use of the regular print functions without the need to think about the character encoding. The ranges 0x00..0x1f and 0x80..0x9f are transfered unmodified to enable the use of user defined characters. The additional function data() writes data directly into the display RAM, without any modifications and independed from the chosen character set. The R set is the default case if no other character is specified at instantiation time. So if you were lucky enough to lay your hands on a display with a more useful character set, this is the way to tell the library about your success: // Use character set A instead of the dreaded R LiquidCrystal_pcf2119 (lcd,PA3,'A'); Possible improvements This is not a to-do-list, just brainstorming and a collection of random thoughts. Unify all the LiquidCrystal libraries It would be very slick to unify all three libraries/four interface modes into one, similar to NewLiquidCrystal by Francisco Malpartida.","title":"LiquidCrystal_pcf2119 character LCD connected via I2C"},{"location":"api/LiquidCrystal_pcf2119/#liquidcrystal_pcf2119-library","text":"This library is for character LCDs based on the PCF2119 controller and connected via I2C. PCF2119 based displays are pretty rare in the wild, it is very likely that this is the wrong library for your display. The more common case is a LCD based on the HD44780 controller and a parallel interface connected to a small interface PCB with an I2C parallel interface PCF8544. These two interfaces are not compatible with each other. That kind of display will require the LiquidCrystal_I2C library instead. PCF2119 based displays seem to have been used in older fax machines and multi function printers, but thery are hard to come by nowerdays (read: expensive. North of 20\u20ac at Farnell). This Library is derived from the Arduino LiquidCrystal library v1.8.0 with some additions from the LiquidCrystal_I2C library.","title":"LiquidCrystal_pcf2119 Library"},{"location":"api/LiquidCrystal_pcf2119/#api","text":"This library is a singleton library, it is not possible to use more than one instance per sketch. This Library is an SDuino original: There is no preexisting Arduino library for this controller. The API syntax is designed to be very similar to the regular LiquidCrystal library for LCDs with a parallel interface. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . Apart from the usual name mangeling for polymorph functions (mostly the different variants of the Print::print method) moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores is all it needs. (hypotetical) Arduino syntax sduino syntax LiquidCrystal lcd(adr) LiquidCrystal (adr) LiquidCrystal lcd(adr,reset) LiquidCrystal (adr,reset) LiquidCrystal lcd(adr,reset,charset) LiquidCrystal (adr,reset,charset) lcd.init(adr,reset,charset) lcd_init(adr,reset,charset) lcd.begin(cols,lines) lcd_begin(cols,lines) lcd.begin(cols,lines,charsize) lcd_begin_charsize(cols,lines,charsize) lcd.clear() lcd_clear() lcd.home() lcd_home() lcd.noDisplay() lcd_noDisplay() lcd.display() lcd_display() lcd.noBlink() lcd_noBlink() lcd.blink() lcd_blink() lcd.noCursor() lcd_noCursor() lcd.cursor() lcd_cursor() lcd.scrollDisplayLeft() lcd_scrollDisplayLeft() lcd.scrollDisplayRight() lcd_scrollDisplayRight() lcd.leftToRight() lcd_leftToRight() lcd.rightToLeft() lcd_rightToLeft() lcd.noAutoscroll() lcd_noAutoscroll() lcd.autoscroll() lcd_autoscroll() lcd.createChar(number, data[]) lcd_createChar(number, data[]) lcd.setCursor(col,row) lcd_setCursor(col,row) result = lcd.write(value) result = lcd_write(value) result = lcd.data(value) result = lcd_data(value) lcd.command(value) lcd_command(value)","title":"API"},{"location":"api/LiquidCrystal_pcf2119/#example","text":"Output some Text and count the time since the last reset. Notice the slightly different position of the opening parenthesis at the \"class constructor\" function LiquidCrystal compared to the C++ instatiation. #include <Arduino.h> #include <LiquidCrystal_pcf2119.h> // initialize the library with the number of the reset pin // The instance name \"lcd\" is *within* the brackets LiquidCrystal_pcf2119 (lcd,PA3); void setup() { lcd_begin(16, 2); lcd_print_s(\"hello, world!\"); } void loop() { lcd_setCursor(0, 1); lcd_print_u(millis() / 1000); } Compare it to the (hypotetical) Arduino C++-Sytax: #include <LiquidCrystal_pcf2119.h> // initialize the library with the number of the reset pin // The instance name \"lcd\" is *before* the brackets LiquidCrystal_pcf2119 lcd(2); void setup() { lcd.begin(16, 2); lcd.print(\"hello, world!\"); } void loop() { lcd.setCursor(0, 1); lcd.print(millis() / 1000); }","title":"Example"},{"location":"api/LiquidCrystal_pcf2119/#differences-between-this-lib-and-liquidcrystal_i2c","text":"","title":"Differences between this lib and LiquidCrystal_I2C"},{"location":"api/LiquidCrystal_pcf2119/#physical-interface","text":"The PCF2119 supports the standard command set as the HD44780, the only visible difference is the physical interface. Supporting I2C natively means very easy read and write access, very similar to the ease of use of a fully connected 8 bit parallel interface without losing so many port pins. This library can be seen as an extended version of the regular LiquidCrystal_I2C using 8 bit mode instead of bit-banging a four bit interface. Or as an I2C-enabled version of LiquidCrystal in 8-bit mode.","title":"Physical interface"},{"location":"api/LiquidCrystal_pcf2119/#character-mapping","text":"This is a head-banging one. Such an engineering nonsense. The PCF2119 exists in six different versions, supporting six different character sets named A, D, F, I, R and S. See page 19ff in the datasheet . A is a standard ASCII mapping, R is the most random one where not even space is at the position it is supposed to be. And guess which character set is used by the modules still available at Farnell? Right, the R set. The left over ones no one was willing to buy so far. This means that the build-in clear function can't be used and the ShiftLeft/ShiftRight modes are not useful as they fill up the free space with 0x20 - which happens to be an arrow in this character set. Who came up with that idea? For character set A, D and I all data is always transferd unmodified. For character sets F, R and S the write() method transparently swaps the ASCII ranges 0x20..0x7f and 0xa0..0xff. This allows the use of the regular print functions without the need to think about the character encoding. The ranges 0x00..0x1f and 0x80..0x9f are transfered unmodified to enable the use of user defined characters. The additional function data() writes data directly into the display RAM, without any modifications and independed from the chosen character set. The R set is the default case if no other character is specified at instantiation time. So if you were lucky enough to lay your hands on a display with a more useful character set, this is the way to tell the library about your success: // Use character set A instead of the dreaded R LiquidCrystal_pcf2119 (lcd,PA3,'A');","title":"Character mapping"},{"location":"api/LiquidCrystal_pcf2119/#possible-improvements","text":"This is not a to-do-list, just brainstorming and a collection of random thoughts.","title":"Possible improvements"},{"location":"api/LiquidCrystal_pcf2119/#unify-all-the-liquidcrystal-libraries","text":"It would be very slick to unify all three libraries/four interface modes into one, similar to NewLiquidCrystal by Francisco Malpartida.","title":"Unify all the LiquidCrystal libraries"},{"location":"api/Mini_SSD1306/","text":"Mini_SSD1306 This is a library for monochrome OLEDs based on SSD1306 drivers. This library is a stripped-down version of the original Adafruit_SSD1306 library v1.1.2. This version of the library does not depend on the Adafruit_GFX library and has a much smaller memory footprint than the full version, but most of the graphical features are missing. The Library only supports I2C communication. Limitations This Library uses a full display buffer. For a 128x64 display this requires 128x64 = 8kbit = 1kB of RAM for the display buffer. Since the STM8S103 has only 1kB RAM total, there is no way that this will fit. If you ignore the compiler warnings about insufficient RAM, it will still run, but you will see a graphical memory dump in the lower part of your display. If you are careful not to modify that part of the memory the program still works, but is not terribly useful. See the oled-mini example. The u8g2 library by Oli Kraus is able to use less RAM by rendering the image in multiple stripes. This is slower, but saves RAM. I am thinking of porting that library, but don't hold your breath for it. API SSD1306(instancename, pin_reset); void Mini_SSD1306_begin(uint8_t switchvcc, uint8_t i2caddr, bool reset); void Mini_SSD1306_clearDisplay(void); void Mini_SSD1306_invertDisplay(uint8_t i); void Mini_SSD1306_display(); void Mini_SSD1306_startscrollright(uint8_t start, uint8_t stop); void Mini_SSD1306_startscrollleft(uint8_t start, uint8_t stop); void Mini_SSD1306_startscrolldiagright(uint8_t start, uint8_t stop); void Mini_SSD1306_startscrolldiagleft(uint8_t start, uint8_t stop); void Mini_SSD1306_stopscroll(void); void Mini_SSD1306_dim(boolean dim); void Mini_SSD1306_drawPixel(int16_t x, int16_t y, uint8_t color); Example The library initializes the display buffer with the Adafruit splash screen. Since it is not modified, oled_display() shows it. The loop draws a pattern of blinking pixels in an 8x8 grid: #include \"I2C.h\" #include \"Mini_SSD1306.h\" Mini_SSD1306(oled,-1); // -1 means no reset pin #if (SSD1306_LCDHEIGHT != 64) #error(\"Height incorrect, please fix Mini_SSD1306.h!\"); #endif void setup() { // Initialize with the I2C addr 0x3C. Some displays use 0x3D instead. oled_begin(SSD1306_SWITCHCAPVCC, 0x3C,0); } void loop() { uint8_t x,y; oled_display(); // show the display buffer delay (1000); // draw some dots in an 8x8 pattern for (x=0; x<WIDTH; x+=8) { for (y=0; y<HEIGHT-8; y+=8) // don't alter the stack! { oled_drawPixel(x,y,INVERSE); } } } Hardware requirements These tiny displays communicate usually via I2C, but SPI versions do exist. My display uses the I2C address 0x3C, but there are similar displays out there configured to use the address 0x3D. The display content has to be kept in memory as it is not possible to read the memory content of the physical display. For 128x64 pixel this requires 1kB of RAM. For low-memory devices like the STM8S103 it means the display buffer overlaps with the stack. Notice the chaotic pattern in the lower part of the screen: Technical data: Driver chip SSD1306 Display resolution: 128x64 Power: 3.3V, approx. 20mA (5V possible) Interface: I2C, some modules support SPI as well I2C-Address: 0x3c, configurable to 0x3d by setting a solder bridge (on some modules) Pin out of an I2C module: Pin Function STM8S103 pin sduino pin 1 GND 2 Vcc 3 SCL PB4 PIN_WIRE_SCL, SCL, 4 4 SDA PB5 PIN_WIRE_SDA, SDA, 3 Further reading Technical information: Adafruit tutorial SSD1306 datasheet Other libraries: Adafruit library Old Arduino library u8glib newer library u8g2 Possible improvements Faster I2C transfer Faster I2C transfer is supported by the I2C library , but to use it you have to modify the source code for the Mini_SSD1306 library. Make this configurable in the instantiation function.","title":"Mini_SSD1306 library for monochrome OLED-displays"},{"location":"api/Mini_SSD1306/#mini_ssd1306","text":"This is a library for monochrome OLEDs based on SSD1306 drivers. This library is a stripped-down version of the original Adafruit_SSD1306 library v1.1.2. This version of the library does not depend on the Adafruit_GFX library and has a much smaller memory footprint than the full version, but most of the graphical features are missing. The Library only supports I2C communication.","title":"Mini_SSD1306"},{"location":"api/Mini_SSD1306/#limitations","text":"This Library uses a full display buffer. For a 128x64 display this requires 128x64 = 8kbit = 1kB of RAM for the display buffer. Since the STM8S103 has only 1kB RAM total, there is no way that this will fit. If you ignore the compiler warnings about insufficient RAM, it will still run, but you will see a graphical memory dump in the lower part of your display. If you are careful not to modify that part of the memory the program still works, but is not terribly useful. See the oled-mini example. The u8g2 library by Oli Kraus is able to use less RAM by rendering the image in multiple stripes. This is slower, but saves RAM. I am thinking of porting that library, but don't hold your breath for it.","title":"Limitations"},{"location":"api/Mini_SSD1306/#api","text":"SSD1306(instancename, pin_reset); void Mini_SSD1306_begin(uint8_t switchvcc, uint8_t i2caddr, bool reset); void Mini_SSD1306_clearDisplay(void); void Mini_SSD1306_invertDisplay(uint8_t i); void Mini_SSD1306_display(); void Mini_SSD1306_startscrollright(uint8_t start, uint8_t stop); void Mini_SSD1306_startscrollleft(uint8_t start, uint8_t stop); void Mini_SSD1306_startscrolldiagright(uint8_t start, uint8_t stop); void Mini_SSD1306_startscrolldiagleft(uint8_t start, uint8_t stop); void Mini_SSD1306_stopscroll(void); void Mini_SSD1306_dim(boolean dim); void Mini_SSD1306_drawPixel(int16_t x, int16_t y, uint8_t color);","title":"API"},{"location":"api/Mini_SSD1306/#example","text":"The library initializes the display buffer with the Adafruit splash screen. Since it is not modified, oled_display() shows it. The loop draws a pattern of blinking pixels in an 8x8 grid: #include \"I2C.h\" #include \"Mini_SSD1306.h\" Mini_SSD1306(oled,-1); // -1 means no reset pin #if (SSD1306_LCDHEIGHT != 64) #error(\"Height incorrect, please fix Mini_SSD1306.h!\"); #endif void setup() { // Initialize with the I2C addr 0x3C. Some displays use 0x3D instead. oled_begin(SSD1306_SWITCHCAPVCC, 0x3C,0); } void loop() { uint8_t x,y; oled_display(); // show the display buffer delay (1000); // draw some dots in an 8x8 pattern for (x=0; x<WIDTH; x+=8) { for (y=0; y<HEIGHT-8; y+=8) // don't alter the stack! { oled_drawPixel(x,y,INVERSE); } } }","title":"Example"},{"location":"api/Mini_SSD1306/#hardware-requirements","text":"These tiny displays communicate usually via I2C, but SPI versions do exist. My display uses the I2C address 0x3C, but there are similar displays out there configured to use the address 0x3D. The display content has to be kept in memory as it is not possible to read the memory content of the physical display. For 128x64 pixel this requires 1kB of RAM. For low-memory devices like the STM8S103 it means the display buffer overlaps with the stack. Notice the chaotic pattern in the lower part of the screen: Technical data: Driver chip SSD1306 Display resolution: 128x64 Power: 3.3V, approx. 20mA (5V possible) Interface: I2C, some modules support SPI as well I2C-Address: 0x3c, configurable to 0x3d by setting a solder bridge (on some modules) Pin out of an I2C module: Pin Function STM8S103 pin sduino pin 1 GND 2 Vcc 3 SCL PB4 PIN_WIRE_SCL, SCL, 4 4 SDA PB5 PIN_WIRE_SDA, SDA, 3","title":"Hardware requirements"},{"location":"api/Mini_SSD1306/#further-reading","text":"Technical information: Adafruit tutorial SSD1306 datasheet Other libraries: Adafruit library Old Arduino library u8glib newer library u8g2","title":"Further reading"},{"location":"api/Mini_SSD1306/#possible-improvements","text":"","title":"Possible improvements"},{"location":"api/Mini_SSD1306/#faster-i2c-transfer","text":"Faster I2C transfer is supported by the I2C library , but to use it you have to modify the source code for the Mini_SSD1306 library. Make this configurable in the instantiation function.","title":"Faster I2C transfer"},{"location":"api/PCD8544/","text":"PCD8544 Library This library is for monochrome graphical LCD based on the Philips PCD8544 controller ( datasheet ) or compatibles. These displays quite cheap and are commonly found on older monochrome mobile phones, such as the Nokia 3310 or 5110 . This library is a very much simpified version of the Adafruit library. Optimized for a minimal memory footprint. Only SPI mode supported. Uses soft-SPI, does not need the SPI pins. This is a modified version of the PCD8544 library written by Carlos Rodrigues . It is ported from C++ to C syntax and is meant to be used with the sduino environment for the STM8. This library is meant to have a minimal memory footprint. If you need graphics and other features and can spare the resources, check out the library from Adafruit (no sduino/STM8 port yet, though). API Thanks to some c preprocessor macro magic the API syntax is very similar to the original C++ syntax. Apart from the usual name mangeling for polymorph functions replacing the dots in the method names for underscores and a small modification of the initializer code should be enough. See below for an example. The instantiation \"method\" can be called only one time per sketch as this library is a singleton library. It is not possible to use more than one instance per sketch. Arduino syntax sduino syntax PCD8544 lcd no default pin mapping supported PCD8544 lcd(sclk,sdin,dc,reset,sce) PCD8544 (lcd,sclk,sdin,dc,reset,sce) lcd.begin() lcd_begin() lcd.begin(width,height) lcd_begin_wh(width,height) lcd.begin(width,height,chiptype) lcd_begin_full(width,height,chiptype) lcd.stop() lcd_stop() lcd.clear() lcd_clear() lcd.clearLine() lcd_clearLine() lcd.setPower(flag) lcd_setPower(flag) lcd.display() lcd_display() lcd.noDisplay() lcd_noDisplay() lcd.setInverse(flag) lcd_setInverse(flag) lcd.setContrast(level) lcd_setContrast(level) lcd.home() lcd_home() lcd.setCursor(col,line) lcd_setCursor(col,line) result = lcd.write(value) result = lcd_write(value) lcd.createChar(chr,glyph[]) lcd_createChar(chr,glyph) lcd.drawBitmap(data[],columns,lines) lcd_drawBitmap(data[],columns,lines) lcd.drawColumn(lines, value) lcd.drawColumn(lines, value) The default resolution of 84x48 fits the commons Nokia 5110 display. Example #include <PCD8544.h> PCD8544(lcd, PC5, PC6, PC4, PC7, PD1); // sclk,sdin,dc,reset,sce int counter = 0; void setup() { lcd_begin(); // default resolution is 84x48 } void loop() { // Write some text on the first line... lcd_setCursor(0, 0); lcd_print_s(\"Hello, World!\"); // Write the counter on the second line... lcd_setCursor(0, 1); lcd_print_u(counter); delay(200); counter++; } Hardware connections To use this library, you must first connect your LCD to the proper pins on the STM8 board. This library uses bitbanging for the SPI data transfer, so you are not bound to the SPI pins for SCLK and MOSI. For a Nokia 5510 display connected to a STM8S103 breakout board, the connections look like this: Display Pin STM8S breakout board Pin 1 (VCC) +3.3V (marked by a square around the pin on the silkscreen) Pin 2 (GND) Ground Pin 3 (SCE) STM8S103 pin PD1 (sduino digital pin 10) Pin 4 (RST) STM8S103 pin PC7 (sduino digital pin 9) Pin 5 (D/C) STM8S103 pin PC4 (sduino digital pin 6) Pin 6 (MOSI) STM8S103 pin PC6 (sduino digital pin 8) Pin 7 (SCLK) STM8S103 pin PC5 (sduino digital pin 7) Pin 8 (LED) 82 Ohm resistor to 3.3V or 330 Ohm to 5V Since the STM8S works on 3.3V you can connect the data lines directly to port lines. If you are using this display with a 5V CPU (like on most Arduino boards), you have to add extra components to connect it to the digital pins of the Arduino (not necessary if you are using a 3.3V variant of the Arduino, such as Sparkfun's Arduino Pro). The background LEDs need only 2.8V/6mA. If you connect them to a port pin, prefer a HS (High sink) pin (see CPU datasheet, all pins except the oscillator and the I2C pin PA1/PA2 and PB4/PB5). PWM pins are the best choice. when soldering the pin connectors, keep in mind that the upside of the display is the thicker part of the metal frame. For a Nokia 3310 display the connections would be the following: Display Pin Arduino Pin Pin 1 +3.3V Pin Pin 2 (SCLK) PC5, digital Pin 7 Pin 3 (SDIN/MOSI) PC6, digital Pin 8 Pin 4 (D/C) PC4, digital Pin 6 Pin 5 (SCE) PD1, digital Pin 10 Pin 6 Ground Pin Pin 7 10uF capacitor to Ground Pin Pin 8 (RST) PC7, digital Pin 9 For this display model, \"Pin 1\" is the leftmost pin when facing the back of the display with the connector on top. Custom Symbols The library allows the use of custom bitmap symbols (5x8), defined by an array of five bytes. Checkout the examples in the library folder for usage of this function. To make it easy to create custom symbols, there's a graphical glyph editor available online .","title":"PCD8544 libray for Nokia 5110-like graphical LCDs"},{"location":"api/PCD8544/#pcd8544-library","text":"This library is for monochrome graphical LCD based on the Philips PCD8544 controller ( datasheet ) or compatibles. These displays quite cheap and are commonly found on older monochrome mobile phones, such as the Nokia 3310 or 5110 . This library is a very much simpified version of the Adafruit library. Optimized for a minimal memory footprint. Only SPI mode supported. Uses soft-SPI, does not need the SPI pins. This is a modified version of the PCD8544 library written by Carlos Rodrigues . It is ported from C++ to C syntax and is meant to be used with the sduino environment for the STM8. This library is meant to have a minimal memory footprint. If you need graphics and other features and can spare the resources, check out the library from Adafruit (no sduino/STM8 port yet, though).","title":"PCD8544 Library"},{"location":"api/PCD8544/#api","text":"Thanks to some c preprocessor macro magic the API syntax is very similar to the original C++ syntax. Apart from the usual name mangeling for polymorph functions replacing the dots in the method names for underscores and a small modification of the initializer code should be enough. See below for an example. The instantiation \"method\" can be called only one time per sketch as this library is a singleton library. It is not possible to use more than one instance per sketch. Arduino syntax sduino syntax PCD8544 lcd no default pin mapping supported PCD8544 lcd(sclk,sdin,dc,reset,sce) PCD8544 (lcd,sclk,sdin,dc,reset,sce) lcd.begin() lcd_begin() lcd.begin(width,height) lcd_begin_wh(width,height) lcd.begin(width,height,chiptype) lcd_begin_full(width,height,chiptype) lcd.stop() lcd_stop() lcd.clear() lcd_clear() lcd.clearLine() lcd_clearLine() lcd.setPower(flag) lcd_setPower(flag) lcd.display() lcd_display() lcd.noDisplay() lcd_noDisplay() lcd.setInverse(flag) lcd_setInverse(flag) lcd.setContrast(level) lcd_setContrast(level) lcd.home() lcd_home() lcd.setCursor(col,line) lcd_setCursor(col,line) result = lcd.write(value) result = lcd_write(value) lcd.createChar(chr,glyph[]) lcd_createChar(chr,glyph) lcd.drawBitmap(data[],columns,lines) lcd_drawBitmap(data[],columns,lines) lcd.drawColumn(lines, value) lcd.drawColumn(lines, value) The default resolution of 84x48 fits the commons Nokia 5110 display.","title":"API"},{"location":"api/PCD8544/#example","text":"#include <PCD8544.h> PCD8544(lcd, PC5, PC6, PC4, PC7, PD1); // sclk,sdin,dc,reset,sce int counter = 0; void setup() { lcd_begin(); // default resolution is 84x48 } void loop() { // Write some text on the first line... lcd_setCursor(0, 0); lcd_print_s(\"Hello, World!\"); // Write the counter on the second line... lcd_setCursor(0, 1); lcd_print_u(counter); delay(200); counter++; }","title":"Example"},{"location":"api/PCD8544/#hardware-connections","text":"To use this library, you must first connect your LCD to the proper pins on the STM8 board. This library uses bitbanging for the SPI data transfer, so you are not bound to the SPI pins for SCLK and MOSI. For a Nokia 5510 display connected to a STM8S103 breakout board, the connections look like this: Display Pin STM8S breakout board Pin 1 (VCC) +3.3V (marked by a square around the pin on the silkscreen) Pin 2 (GND) Ground Pin 3 (SCE) STM8S103 pin PD1 (sduino digital pin 10) Pin 4 (RST) STM8S103 pin PC7 (sduino digital pin 9) Pin 5 (D/C) STM8S103 pin PC4 (sduino digital pin 6) Pin 6 (MOSI) STM8S103 pin PC6 (sduino digital pin 8) Pin 7 (SCLK) STM8S103 pin PC5 (sduino digital pin 7) Pin 8 (LED) 82 Ohm resistor to 3.3V or 330 Ohm to 5V Since the STM8S works on 3.3V you can connect the data lines directly to port lines. If you are using this display with a 5V CPU (like on most Arduino boards), you have to add extra components to connect it to the digital pins of the Arduino (not necessary if you are using a 3.3V variant of the Arduino, such as Sparkfun's Arduino Pro). The background LEDs need only 2.8V/6mA. If you connect them to a port pin, prefer a HS (High sink) pin (see CPU datasheet, all pins except the oscillator and the I2C pin PA1/PA2 and PB4/PB5). PWM pins are the best choice. when soldering the pin connectors, keep in mind that the upside of the display is the thicker part of the metal frame. For a Nokia 3310 display the connections would be the following: Display Pin Arduino Pin Pin 1 +3.3V Pin Pin 2 (SCLK) PC5, digital Pin 7 Pin 3 (SDIN/MOSI) PC6, digital Pin 8 Pin 4 (D/C) PC4, digital Pin 6 Pin 5 (SCE) PD1, digital Pin 10 Pin 6 Ground Pin Pin 7 10uF capacitor to Ground Pin Pin 8 (RST) PC7, digital Pin 9 For this display model, \"Pin 1\" is the leftmost pin when facing the back of the display with the connector on top.","title":"Hardware connections"},{"location":"api/PCD8544/#custom-symbols","text":"The library allows the use of custom bitmap symbols (5x8), defined by an array of five bytes. Checkout the examples in the library folder for usage of this function. To make it easy to create custom symbols, there's a graphical glyph editor available online .","title":"Custom Symbols"},{"location":"api/Print/","text":"Print Formatting functions for use with other output libraries. Involves serious preprocessor magic. See the migration guidelines and the xmacro description This page is only a stub. API Example Implementation details Possible impovements","title":"Print"},{"location":"api/Print/#print","text":"Formatting functions for use with other output libraries. Involves serious preprocessor magic. See the migration guidelines and the xmacro description This page is only a stub.","title":"Print"},{"location":"api/Print/#api","text":"","title":"API"},{"location":"api/Print/#example","text":"","title":"Example"},{"location":"api/Print/#implementation-details","text":"","title":"Implementation details"},{"location":"api/Print/#possible-impovements","text":"","title":"Possible impovements"},{"location":"api/SPI/","text":"SPI Real hardware-SPI up to 10MHz. No interrupt support yet. This page is only a stub. API Example Implementation details Possible impovements","title":"SPI"},{"location":"api/SPI/#spi","text":"Real hardware-SPI up to 10MHz. No interrupt support yet. This page is only a stub.","title":"SPI"},{"location":"api/SPI/#api","text":"","title":"API"},{"location":"api/SPI/#example","text":"","title":"Example"},{"location":"api/SPI/#implementation-details","text":"","title":"Implementation details"},{"location":"api/SPI/#possible-impovements","text":"","title":"Possible impovements"},{"location":"api/Servo/","text":"Servo Library This library can control a great number of servos. It makes careful use of timers: the library can control 12 servos using only 1 timer. Derived from the Arduino Servo library v1.8.0. This library has a slightly diffent user interface than the usual singleton libraries. This allows for handling more than one servo per Sketch but it requires some more attention when porting an existing sketch from C++ to C. Each Servo instance is identified by a channel-ID. In order to match the C++ class constructor syntax it is defined as a type Servo . This channel-ID is used as a file-descriptor-like value and need to be passed to all API functions except for Servo_attach() . This function claimes the next free channel number. Example Read a potentiometer on analog input 0 and set a servo pulse length between 1000us and 2023us: #include <Arduino.h> #include <Servo.h> Servo myservo; // just a simple unsigned char to hold the channel-ID int val; // variable to read the value from the analog pin void setup() { myservo = Servo_attach(9); // attaches the servo on pin 9, returns channel-ID } void loop() { val = analogRead(0); // reads the value of the potentiometer Servo_write(myservo, val+1000);// sets the servo position delay(15); } Original Arduino C++-Sytax: #include <Servo.h> Servo myservo; // create servo object to control a servo int val; // variable to read the value from the analog pin void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { val = analogRead(0); // reads the value of the potentiometer myservo.write(val+1000); // sets the servo position delay(15); } API data type Servo : A type definition for a simple unsigned char to hold the channel number returned my Servo_attach() . Needed for every servo. Syntax identical to the Arduino class constructor. Arduino syntax sduino syntax Servo myservo; Servo myservo; myservo.attach(pin); myservo = Servo_attach(pin); myservo.attach(pin,min,max); Servo_attach_minmax(pin,min,max); myservo.detach(); Servo_detach(byte channel); myservo.write(val); Servo_write(myservo, val); myservo.writeMicroseconds(val); Servo_writeMicroseconds(myservo, val); val = myservo.read(); val = Servo_read(myservo); val = myservo.readMicroseconds(); val = Servo_readMicroseconds(myservo); myservo.attached() Servo_attached(myservo); uint8_t Servo_attach(int pin); attach the given pin to the next free channel, sets pinMode, returns channel number or 0 if failure. uint8_t Servo_attach_minmax(int pin, int min, int max); as above but also sets min and max values for writes. void Servo_detach(byte channel); void Servo_write(byte channel, int value); if value is < 200 it is treated as an angle and scaled according the minimum and maximum pulsewidth defined using the attach() function earlier, otherwise as pulse width in microseconds, unscaled. void Servo_writeMicroseconds(byte channel, int value); Write pulse width in microseconds, unscaled. int Servo_read(byte channel); returns current pulse width as an angle between 0 and 180 degrees. int Servo_readMicroseconds(byte channel); returns current pulse width in microseconds for this servo (was read_us() in first Arduino release). bool Servo_attached(byte channel); return true if this servo is attached, otherwise false . Relationship between PWM/analog output and Servo output It is not possible to use a timer for PWM and the Servo Library at the same time. Since this library currently uses timer1, the PWM function ( analogWrite() ) is disabled for the pins connected to timer1 (for the STM8S103 this is pin PC3 and PC4 or digital pin 5 and 6). Pins connected to timer2 (PA3, PD3, PD4, digital pin 2,12,13) are still usable for PWM output. Possible improvements A more sophisticated pseudo-OO API Define a set of preprocessor macros that more OO-like definitions like this become possible: Current syntax OO-like syntax Arduino syntax myservo = Servo_attach(pin); myservo_attach(pin); myservo.attach(pin); Servo_write(myservo, val); myservo_write(val); myservo_write(val); val = Servo_read(myservo); val = myservo_read(); val = myservo_read(); Optimizing the handle_interrupts() function SDCC compiles this function very inefficiently. The code size is around 500 Bytes, and it is executed as part of the CC interrupt routine. Expected CPU load for a full servo group of 12 servos is approx. 2%. (Calculated for 16MHz CPU clock, 13 interrupts every 20ms = 650 interrupts/sec, approx. 500 clock cycles each) Using more than one CC channel per timer it might be possible to use all capture+compare (CC) channels of one timer at the same time, attaching one servo group to each CC-channel. This way it would be possible to serve up to 48 servos using the four CC-channels of timer TIM1. Monitoring the repetion period might become a little complex, as it must be ensured that all servos on all channels have finshed before.","title":"Servo library"},{"location":"api/Servo/#servo-library","text":"This library can control a great number of servos. It makes careful use of timers: the library can control 12 servos using only 1 timer. Derived from the Arduino Servo library v1.8.0. This library has a slightly diffent user interface than the usual singleton libraries. This allows for handling more than one servo per Sketch but it requires some more attention when porting an existing sketch from C++ to C. Each Servo instance is identified by a channel-ID. In order to match the C++ class constructor syntax it is defined as a type Servo . This channel-ID is used as a file-descriptor-like value and need to be passed to all API functions except for Servo_attach() . This function claimes the next free channel number.","title":"Servo Library"},{"location":"api/Servo/#example","text":"Read a potentiometer on analog input 0 and set a servo pulse length between 1000us and 2023us: #include <Arduino.h> #include <Servo.h> Servo myservo; // just a simple unsigned char to hold the channel-ID int val; // variable to read the value from the analog pin void setup() { myservo = Servo_attach(9); // attaches the servo on pin 9, returns channel-ID } void loop() { val = analogRead(0); // reads the value of the potentiometer Servo_write(myservo, val+1000);// sets the servo position delay(15); } Original Arduino C++-Sytax: #include <Servo.h> Servo myservo; // create servo object to control a servo int val; // variable to read the value from the analog pin void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { val = analogRead(0); // reads the value of the potentiometer myservo.write(val+1000); // sets the servo position delay(15); }","title":"Example"},{"location":"api/Servo/#api","text":"data type Servo : A type definition for a simple unsigned char to hold the channel number returned my Servo_attach() . Needed for every servo. Syntax identical to the Arduino class constructor. Arduino syntax sduino syntax Servo myservo; Servo myservo; myservo.attach(pin); myservo = Servo_attach(pin); myservo.attach(pin,min,max); Servo_attach_minmax(pin,min,max); myservo.detach(); Servo_detach(byte channel); myservo.write(val); Servo_write(myservo, val); myservo.writeMicroseconds(val); Servo_writeMicroseconds(myservo, val); val = myservo.read(); val = Servo_read(myservo); val = myservo.readMicroseconds(); val = Servo_readMicroseconds(myservo); myservo.attached() Servo_attached(myservo); uint8_t Servo_attach(int pin); attach the given pin to the next free channel, sets pinMode, returns channel number or 0 if failure. uint8_t Servo_attach_minmax(int pin, int min, int max); as above but also sets min and max values for writes. void Servo_detach(byte channel); void Servo_write(byte channel, int value); if value is < 200 it is treated as an angle and scaled according the minimum and maximum pulsewidth defined using the attach() function earlier, otherwise as pulse width in microseconds, unscaled. void Servo_writeMicroseconds(byte channel, int value); Write pulse width in microseconds, unscaled. int Servo_read(byte channel); returns current pulse width as an angle between 0 and 180 degrees. int Servo_readMicroseconds(byte channel); returns current pulse width in microseconds for this servo (was read_us() in first Arduino release). bool Servo_attached(byte channel); return true if this servo is attached, otherwise false .","title":"API"},{"location":"api/Servo/#relationship-between-pwmanalog-output-and-servo-output","text":"It is not possible to use a timer for PWM and the Servo Library at the same time. Since this library currently uses timer1, the PWM function ( analogWrite() ) is disabled for the pins connected to timer1 (for the STM8S103 this is pin PC3 and PC4 or digital pin 5 and 6). Pins connected to timer2 (PA3, PD3, PD4, digital pin 2,12,13) are still usable for PWM output.","title":"Relationship between PWM/analog output and Servo output"},{"location":"api/Servo/#possible-improvements","text":"","title":"Possible improvements"},{"location":"api/Servo/#a-more-sophisticated-pseudo-oo-api","text":"Define a set of preprocessor macros that more OO-like definitions like this become possible: Current syntax OO-like syntax Arduino syntax myservo = Servo_attach(pin); myservo_attach(pin); myservo.attach(pin); Servo_write(myservo, val); myservo_write(val); myservo_write(val); val = Servo_read(myservo); val = myservo_read(); val = myservo_read();","title":"A more sophisticated pseudo-OO API"},{"location":"api/Servo/#optimizing-the-handle_interrupts-function","text":"SDCC compiles this function very inefficiently. The code size is around 500 Bytes, and it is executed as part of the CC interrupt routine. Expected CPU load for a full servo group of 12 servos is approx. 2%. (Calculated for 16MHz CPU clock, 13 interrupts every 20ms = 650 interrupts/sec, approx. 500 clock cycles each)","title":"Optimizing the handle_interrupts() function"},{"location":"api/Servo/#using-more-than-one-cc-channel-per-timer","text":"it might be possible to use all capture+compare (CC) channels of one timer at the same time, attaching one servo group to each CC-channel. This way it would be possible to serve up to 48 servos using the four CC-channels of timer TIM1. Monitoring the repetion period might become a little complex, as it must be ensured that all servos on all channels have finshed before.","title":"Using more than one CC channel per timer"},{"location":"api/Stepper/","text":"Stepper Library A Library for driving stepper motors with 2, 4 or 5 phases. Derived from the Arduino Stepper library v1.8.0. API This library is a multi-instance library, it supports an arbitrary number of stepper motors per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . The declaration supports polymorphism, so all that is needed to adopt an existing sketch for use with sduino is moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores. Arduino method sduino function Stepper myStepper(steps, pin1,pin2); Stepper (myStepper,steps,pin1,pin2); Stepper myStepper(steps, pin1,pin2,pin3,pin4); Stepper (myStepper,steps,pin1,pin2,pin3,pin4); Stepper myStepper(steps, pin1,pin2,pin3,pin4,pin5); Stepper (myStepper,steps,pin1,pin2,pin3,pin4,pin5); myStepper.setSpeed(speed); myStepper_setSpeed(speed); myStepper.step(n); myStepper_step(n); myStepper.version(); myStepper_version(); API additions The sduino implementation adds some extra methods to the stock Stepper library to allow to work arounds some limitations of C code vs. C++: Arduino method sduino function done automatically on start up myStepper_activateOutputs(); not impemented myStepper_2phase(steps,pin1,pin2); not impemented myStepper_4phase(steps,pin1,pin2,pin3,pin4); not impemented myStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5); Initializing the output pins on demand In real C++ the internal class constructor method initializes the motor pins to output mode automatically at start up of the programm. In C this doesn't happen automatically. Most libraries implement a begin() method for exactly this purpose, but this one does not include an explicit constructor method. Instead, the output mode is set automatically right before the very first motor step. This means that the driver pins stay uninitialized and are left floating from the time of power up until the first step is requested. This won't be a problem in most cases as most motor drivers are using pull-up or pull-down resistors to ensure proper signal levels. If needed, the application could call the added activateOutputs() method in the setup() function to force an immediate port pin initialization: setup() { myStepper_activateOutputs(); // initializes the motor pins to output mode } Assigning the pin connections at run time The way the instantiation macro works requires compile-time constant values for all parameters (see below in section 'Implementation Details'). In order to be able to (re-) configure the pin connections at run time this version of the library implements the functions 2phase() , 4phase() and 5phase() . These functions act like a constructor and allow for full re-initialisation of an already existing \"object\". If you need to (re-) configure the pin connections at run time (e.g. read it from a configuration EEPROM first) you can initialize a data structure with 0 for the unknown pin numbers and set them later by calling the right xphase()-function: Stepper (myStepper,0,0); setup() { ... figure out the pin numbers somehow ... myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4); ... } loop () { ... myStepper_setSpeed(60); myStepper_step(100); ... } 5 phase support can be deactivated to save code space 5 phase motors are not very common, but supporting them increases the code size significantly. By defining the compiler flag NO_5PHASE it is possible to deactivate the support for 5 phase motors. This saves 736 bytes of code space. Add this line to your Makefile if you don't need 5 phase support: CFLAGS = -DNO_5PHASE Example Notice the slightly different position of the opening parenthesis at the \"class constructor\" 'function' Stepper compared to the C++ instantiation. (available in the examples folder as stepper_oneRevolution.c ) C-Version for use with sduino: #include <Arduino.h> #include <Stepper.h> // change this to fit the number of steps per revolution for your motor #define stepsPerRevolution 200 // initialize the stepper library on pins 8 through 11: Stepper (myStepper,stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper_setSpeed(60); } void loop() { // step one revolution in one direction: myStepper_step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper_step(-stepsPerRevolution); delay(500); } Original Arduino C++-Sytax: #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); } void loop() { // step one revolution in one direction: myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper.step(-stepsPerRevolution); delay(500); } Implementation details Technically, each Stepper instance is represented by a file-descriptor-like structure. This structure is initialized by the instantiation macro Stepper . This means that all values are required to be constant values, known at compile time. A const qualifier is not enough for SDCC, it requires either a #define or an enum : const int numOfSteps = 1; // does not work with SDCC #define MotorPin1 10 // ok, works enum { MotorPin2 = 11 }; // ok, works Stepper (myStepper, numOfSteps, MotorPin1, MotorPin2); All functions require a pointer to the stepper data structur as their first argument to identify the stepper instance. All this pointer handling is hidden by preprocessor magic, but it is still real and pure C. If you insist, you can still call the 'real' functions yourself (but you gain nothing, the compiler produces exactly the same output). Possible impovements This is not a to-do-list, just brainstorming and a collection of random thoughts. Nothing yet.","title":"Stepper library"},{"location":"api/Stepper/#stepper-library","text":"A Library for driving stepper motors with 2, 4 or 5 phases. Derived from the Arduino Stepper library v1.8.0.","title":"Stepper Library"},{"location":"api/Stepper/#api","text":"This library is a multi-instance library, it supports an arbitrary number of stepper motors per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . The declaration supports polymorphism, so all that is needed to adopt an existing sketch for use with sduino is moving the opening bracket at the class declarator line and replacing the dots in the method names for underscores. Arduino method sduino function Stepper myStepper(steps, pin1,pin2); Stepper (myStepper,steps,pin1,pin2); Stepper myStepper(steps, pin1,pin2,pin3,pin4); Stepper (myStepper,steps,pin1,pin2,pin3,pin4); Stepper myStepper(steps, pin1,pin2,pin3,pin4,pin5); Stepper (myStepper,steps,pin1,pin2,pin3,pin4,pin5); myStepper.setSpeed(speed); myStepper_setSpeed(speed); myStepper.step(n); myStepper_step(n); myStepper.version(); myStepper_version();","title":"API"},{"location":"api/Stepper/#api-additions","text":"The sduino implementation adds some extra methods to the stock Stepper library to allow to work arounds some limitations of C code vs. C++: Arduino method sduino function done automatically on start up myStepper_activateOutputs(); not impemented myStepper_2phase(steps,pin1,pin2); not impemented myStepper_4phase(steps,pin1,pin2,pin3,pin4); not impemented myStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5);","title":"API additions"},{"location":"api/Stepper/#initializing-the-output-pins-on-demand","text":"In real C++ the internal class constructor method initializes the motor pins to output mode automatically at start up of the programm. In C this doesn't happen automatically. Most libraries implement a begin() method for exactly this purpose, but this one does not include an explicit constructor method. Instead, the output mode is set automatically right before the very first motor step. This means that the driver pins stay uninitialized and are left floating from the time of power up until the first step is requested. This won't be a problem in most cases as most motor drivers are using pull-up or pull-down resistors to ensure proper signal levels. If needed, the application could call the added activateOutputs() method in the setup() function to force an immediate port pin initialization: setup() { myStepper_activateOutputs(); // initializes the motor pins to output mode }","title":"Initializing the output pins on demand"},{"location":"api/Stepper/#assigning-the-pin-connections-at-run-time","text":"The way the instantiation macro works requires compile-time constant values for all parameters (see below in section 'Implementation Details'). In order to be able to (re-) configure the pin connections at run time this version of the library implements the functions 2phase() , 4phase() and 5phase() . These functions act like a constructor and allow for full re-initialisation of an already existing \"object\". If you need to (re-) configure the pin connections at run time (e.g. read it from a configuration EEPROM first) you can initialize a data structure with 0 for the unknown pin numbers and set them later by calling the right xphase()-function: Stepper (myStepper,0,0); setup() { ... figure out the pin numbers somehow ... myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4); ... } loop () { ... myStepper_setSpeed(60); myStepper_step(100); ... }","title":"Assigning the pin connections at run time"},{"location":"api/Stepper/#5-phase-support-can-be-deactivated-to-save-code-space","text":"5 phase motors are not very common, but supporting them increases the code size significantly. By defining the compiler flag NO_5PHASE it is possible to deactivate the support for 5 phase motors. This saves 736 bytes of code space. Add this line to your Makefile if you don't need 5 phase support: CFLAGS = -DNO_5PHASE","title":"5 phase support can be deactivated to save code space"},{"location":"api/Stepper/#example","text":"Notice the slightly different position of the opening parenthesis at the \"class constructor\" 'function' Stepper compared to the C++ instantiation. (available in the examples folder as stepper_oneRevolution.c ) C-Version for use with sduino: #include <Arduino.h> #include <Stepper.h> // change this to fit the number of steps per revolution for your motor #define stepsPerRevolution 200 // initialize the stepper library on pins 8 through 11: Stepper (myStepper,stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper_setSpeed(60); } void loop() { // step one revolution in one direction: myStepper_step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper_step(-stepsPerRevolution); delay(500); } Original Arduino C++-Sytax: #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); } void loop() { // step one revolution in one direction: myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper.step(-stepsPerRevolution); delay(500); }","title":"Example"},{"location":"api/Stepper/#implementation-details","text":"Technically, each Stepper instance is represented by a file-descriptor-like structure. This structure is initialized by the instantiation macro Stepper . This means that all values are required to be constant values, known at compile time. A const qualifier is not enough for SDCC, it requires either a #define or an enum : const int numOfSteps = 1; // does not work with SDCC #define MotorPin1 10 // ok, works enum { MotorPin2 = 11 }; // ok, works Stepper (myStepper, numOfSteps, MotorPin1, MotorPin2); All functions require a pointer to the stepper data structur as their first argument to identify the stepper instance. All this pointer handling is hidden by preprocessor magic, but it is still real and pure C. If you insist, you can still call the 'real' functions yourself (but you gain nothing, the compiler produces exactly the same output).","title":"Implementation details"},{"location":"api/Stepper/#possible-impovements","text":"This is not a to-do-list, just brainstorming and a collection of random thoughts. Nothing yet.","title":"Possible impovements"},{"location":"api/TM1638/","text":"TM1638 Library A family of libraries for driving serial LED modules based on the TM1638 and TM1640 drivers. Derived from the TM1638 library by Ricardo Batista. This adoption is based on commit 027d415 . API This library is a multi-instance library, it supports an arbitrary number of displays per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . The declaration supports polymorphism, but the 'methods' of the instantiation don't due to C preprocessor constrains. But the different function names are still very similar to the C++ versions. Arduino method sduino function TM1638 module(8,9,10); TM1638 (module,8,9,10); TM1638 module(8,9,10,0); TM1638 (module,8,9,10,0); TM1638 module(8,9,10,1,5); TM1638 (module,8,9,10,1,5); module.setDisplayToHexNumber(n,dots) module_setDisplayToHexNumber(n,dots) module.setDisplayToHexNumber(n,dots,font) module_setDisplayToHexNumber3(n,dots,font) module.setDisplayToDecNumber(n,dots) module_setDisplayToDecNumber(n,dots) module.setDisplayToDecNumber(n,dots,font) module_setDisplayToDecNumber3(n,dots,font) module.setDisplayToSignedDecNumber(n,dots) module_setDisplayToSignedDecNumber(n,dots) module.setDisplayToSignedDecNumber(n,dots,font) module_setDisplayToSignedDecNumber3(n,dots,font) module.setDisplayToBinNumber(n,dots) module_setDisplayToBinNumber(n,dots) module.setDisplayToBinNumber(n,dots,font) module_setDisplayToBinNumber3(n,dots,font) module.setLED(col,pos) module_setLED(col,pos) module.setLEDs(pattern) module_setLEDs(pattern) x = module.getButtons() x = module_getButtons() module.setupDisplay(act,intens) module_setupDisplay(act,intens) module.setDisplayDigit(d,pos,dot) module_setDisplayDigit(d,pos,dot) module.setDisplayDigit(d,pos,dot,font) module_setDisplayDigit4(d,pos,dot,font) module.setDisplayToError() module_setDisplayToError() module.setDisplay(data) module_setDisplay(data) module.setDisplay(data,len) module_setDisplay2(data,len) module.clearDisplayDigit(pos,dot) module_clearDisplayDigit(pos,dot) module.clearDisplay() module_clearDisplay() module.setDisplayToString(s) module_setDisplayToString(s) module.setDisplayToString(s,dots) module_setDisplayToString2(s,dots) module.setDisplayToString(s,dots,pos) module_setDisplayToString3(s,dots,pos) module.setDisplayToString(s,dots,pos,font) module_setDisplayToString4(s,dots,pos,font) API additions The sduino implementation adds some extra methods to the stock Stepper library to allow to work arounds some limitations of C code vs. C++: Arduino method sduino function done automatically on start up myStepper_activateOutputs(); not impemented myStepper_2phase(steps,pin1,pin2); not impemented myStepper_4phase(steps,pin1,pin2,pin3,pin4); not impemented myStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5); Initializing the output pins on demand In real C++ the internal class constructor method initializes the motor pins to output mode automatically at start up of the programm. In C this doesn't happen automatically. Most libraries implement a begin() method for exactly this purpose, but this one does not include an explicit constructor method. Instead, the output mode is set automatically right before the very first motor step. This means that the driver pins stay uninitialized and are left floating from the time of power up until the first step is requested. This won't be a problem in most cases as most motor drivers are using pull-up or pull-down resistors to ensure proper signal levels. If needed, the application could call the added activateOutputs() method in the setup() function to force an immediate port pin initialization: setup() { myStepper_activateOutputs(); // initializes the motor pins to output mode } Assigning the pin connections at run time The way the instantiation macro works requires compile-time constant values for all parameters (see below in section 'Implementation Details'). In order to be able to (re-) configure the pin connections at run time this version of the library implements the functions 2phase() , 4phase() and 5phase() . These functions act like a constructor and allow for full re-initialisation of an already existing \"object\". If you need to (re-) configure the pin connections at run time (e.g. read it from a configuration EEPROM first) you can initialize a data structure with 0 for the unknown pin numbers and set them later by calling the right xphase()-function: Stepper (myStepper,0,0); setup() { ... figure out the pin numbers somehow ... myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4); ... } loop () { ... myStepper_setSpeed(60); myStepper_step(100); ... } 5 phase support can be deactivated to save code space 5 phase motors are not very common, but supporting them increases the code size significantly. By defining the compiler flag NO_5PHASE it is possible to deactivate the support for 5 phase motors. This saves 736 bytes of code space. Add this line to your Makefile if you don't need 5 phase support: CFLAGS = -DNO_5PHASE Example Notice the slightly different position of the opening parenthesis at the \"class constructor\" 'function' Stepper compared to the C++ instantiation. (available in the examples folder as stepper_oneRevolution.c ) C-Version for use with sduino: #include <Arduino.h> #include <Stepper.h> // change this to fit the number of steps per revolution for your motor #define stepsPerRevolution 200 // initialize the stepper library on pins 8 through 11: Stepper (myStepper,stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper_setSpeed(60); } void loop() { // step one revolution in one direction: myStepper_step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper_step(-stepsPerRevolution); delay(500); } Original Arduino C++-Sytax: #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); } void loop() { // step one revolution in one direction: myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper.step(-stepsPerRevolution); delay(500); } Implementation details Technically, each Stepper instance is represented by a file-descriptor-like structure. This structure is initialized by the instantiation macro Stepper . This means that all values are required to be constant values, known at compile time. A const qualifier is not enough for SDCC, it requires either a #define or an enum : const int numOfSteps = 1; // does not work with SDCC #define MotorPin1 10 // ok, works enum { MotorPin2 = 11 }; // ok, works Stepper (myStepper, numOfSteps, MotorPin1, MotorPin2); All functions require a pointer to the stepper data structur as their first argument to identify the stepper instance. All this pointer handling is hidden by preprocessor magic, but it is still real and pure C. If you insist, you can still call the 'real' functions yourself (but you gain nothing, the compiler produces exactly the same output). Possible impovements This is not a to-do-list, just brainstorming and a collection of random thoughts. Nothing yet.","title":"TM1638 Library"},{"location":"api/TM1638/#tm1638-library","text":"A family of libraries for driving serial LED modules based on the TM1638 and TM1640 drivers. Derived from the TM1638 library by Ricardo Batista. This adoption is based on commit 027d415 .","title":"TM1638 Library"},{"location":"api/TM1638/#api","text":"This library is a multi-instance library, it supports an arbitrary number of displays per sketch. The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic . The declaration supports polymorphism, but the 'methods' of the instantiation don't due to C preprocessor constrains. But the different function names are still very similar to the C++ versions. Arduino method sduino function TM1638 module(8,9,10); TM1638 (module,8,9,10); TM1638 module(8,9,10,0); TM1638 (module,8,9,10,0); TM1638 module(8,9,10,1,5); TM1638 (module,8,9,10,1,5); module.setDisplayToHexNumber(n,dots) module_setDisplayToHexNumber(n,dots) module.setDisplayToHexNumber(n,dots,font) module_setDisplayToHexNumber3(n,dots,font) module.setDisplayToDecNumber(n,dots) module_setDisplayToDecNumber(n,dots) module.setDisplayToDecNumber(n,dots,font) module_setDisplayToDecNumber3(n,dots,font) module.setDisplayToSignedDecNumber(n,dots) module_setDisplayToSignedDecNumber(n,dots) module.setDisplayToSignedDecNumber(n,dots,font) module_setDisplayToSignedDecNumber3(n,dots,font) module.setDisplayToBinNumber(n,dots) module_setDisplayToBinNumber(n,dots) module.setDisplayToBinNumber(n,dots,font) module_setDisplayToBinNumber3(n,dots,font) module.setLED(col,pos) module_setLED(col,pos) module.setLEDs(pattern) module_setLEDs(pattern) x = module.getButtons() x = module_getButtons() module.setupDisplay(act,intens) module_setupDisplay(act,intens) module.setDisplayDigit(d,pos,dot) module_setDisplayDigit(d,pos,dot) module.setDisplayDigit(d,pos,dot,font) module_setDisplayDigit4(d,pos,dot,font) module.setDisplayToError() module_setDisplayToError() module.setDisplay(data) module_setDisplay(data) module.setDisplay(data,len) module_setDisplay2(data,len) module.clearDisplayDigit(pos,dot) module_clearDisplayDigit(pos,dot) module.clearDisplay() module_clearDisplay() module.setDisplayToString(s) module_setDisplayToString(s) module.setDisplayToString(s,dots) module_setDisplayToString2(s,dots) module.setDisplayToString(s,dots,pos) module_setDisplayToString3(s,dots,pos) module.setDisplayToString(s,dots,pos,font) module_setDisplayToString4(s,dots,pos,font)","title":"API"},{"location":"api/TM1638/#api-additions","text":"The sduino implementation adds some extra methods to the stock Stepper library to allow to work arounds some limitations of C code vs. C++: Arduino method sduino function done automatically on start up myStepper_activateOutputs(); not impemented myStepper_2phase(steps,pin1,pin2); not impemented myStepper_4phase(steps,pin1,pin2,pin3,pin4); not impemented myStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5);","title":"API additions"},{"location":"api/TM1638/#initializing-the-output-pins-on-demand","text":"In real C++ the internal class constructor method initializes the motor pins to output mode automatically at start up of the programm. In C this doesn't happen automatically. Most libraries implement a begin() method for exactly this purpose, but this one does not include an explicit constructor method. Instead, the output mode is set automatically right before the very first motor step. This means that the driver pins stay uninitialized and are left floating from the time of power up until the first step is requested. This won't be a problem in most cases as most motor drivers are using pull-up or pull-down resistors to ensure proper signal levels. If needed, the application could call the added activateOutputs() method in the setup() function to force an immediate port pin initialization: setup() { myStepper_activateOutputs(); // initializes the motor pins to output mode }","title":"Initializing the output pins on demand"},{"location":"api/TM1638/#assigning-the-pin-connections-at-run-time","text":"The way the instantiation macro works requires compile-time constant values for all parameters (see below in section 'Implementation Details'). In order to be able to (re-) configure the pin connections at run time this version of the library implements the functions 2phase() , 4phase() and 5phase() . These functions act like a constructor and allow for full re-initialisation of an already existing \"object\". If you need to (re-) configure the pin connections at run time (e.g. read it from a configuration EEPROM first) you can initialize a data structure with 0 for the unknown pin numbers and set them later by calling the right xphase()-function: Stepper (myStepper,0,0); setup() { ... figure out the pin numbers somehow ... myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4); ... } loop () { ... myStepper_setSpeed(60); myStepper_step(100); ... }","title":"Assigning the pin connections at run time"},{"location":"api/TM1638/#5-phase-support-can-be-deactivated-to-save-code-space","text":"5 phase motors are not very common, but supporting them increases the code size significantly. By defining the compiler flag NO_5PHASE it is possible to deactivate the support for 5 phase motors. This saves 736 bytes of code space. Add this line to your Makefile if you don't need 5 phase support: CFLAGS = -DNO_5PHASE","title":"5 phase support can be deactivated to save code space"},{"location":"api/TM1638/#example","text":"Notice the slightly different position of the opening parenthesis at the \"class constructor\" 'function' Stepper compared to the C++ instantiation. (available in the examples folder as stepper_oneRevolution.c ) C-Version for use with sduino: #include <Arduino.h> #include <Stepper.h> // change this to fit the number of steps per revolution for your motor #define stepsPerRevolution 200 // initialize the stepper library on pins 8 through 11: Stepper (myStepper,stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper_setSpeed(60); } void loop() { // step one revolution in one direction: myStepper_step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper_step(-stepsPerRevolution); delay(500); } Original Arduino C++-Sytax: #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); } void loop() { // step one revolution in one direction: myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: myStepper.step(-stepsPerRevolution); delay(500); }","title":"Example"},{"location":"api/TM1638/#implementation-details","text":"Technically, each Stepper instance is represented by a file-descriptor-like structure. This structure is initialized by the instantiation macro Stepper . This means that all values are required to be constant values, known at compile time. A const qualifier is not enough for SDCC, it requires either a #define or an enum : const int numOfSteps = 1; // does not work with SDCC #define MotorPin1 10 // ok, works enum { MotorPin2 = 11 }; // ok, works Stepper (myStepper, numOfSteps, MotorPin1, MotorPin2); All functions require a pointer to the stepper data structur as their first argument to identify the stepper instance. All this pointer handling is hidden by preprocessor magic, but it is still real and pure C. If you insist, you can still call the 'real' functions yourself (but you gain nothing, the compiler produces exactly the same output).","title":"Implementation details"},{"location":"api/TM1638/#possible-impovements","text":"This is not a to-do-list, just brainstorming and a collection of random thoughts. Nothing yet.","title":"Possible impovements"},{"location":"api/Wire/","text":"Wire This is an improved version of the stock Arduino Wire library for I2C communication. It shares most of the hardware related code with the re-write of the Sduino I2C library , but holds on to the Arduino API. The main difference between this STM8 version and the Arduino AVR version is the existance of a timeout function to prevent deadlocks due to failed communication. Polling mode is used for communication, interrupts are not supported (yet). So far, only Master Transmit and Master Receive modes are supported, slave modes are not implemented yet. API This is a pre-instantiated singleton library. It is not possible to use more than one instance per sketch or to change the instance name. The API syntax is very similar to the original C++ syntax. Some name mangeling was needed to distinguish the different variants of the write() method. Apart from this replacing the dots in the method names for underscores is all it needs. Arduino syntax sduino syntax real function name Wire.begin() Wire_begin() same Wire.begin(ownaddress) slave mode not supported yet - Wire.end() Wire_end() same Wire.setClock(clock) Wire_setClock(clock) same not implemented Wire_timeOut(millisec) same Wire.beginTransmission(addr) Wire_beginTransmission(addr) same n = Wire.endTransmission() n = Wire_endTransmission() same (inline) n = Wire.endTransmission(stop) n = Wire_endTransmission1(stop) same Wire.write(val) Wire_write(val) same Wire.write(*str) Wire_write_s(*str) same Wire.write(*data, len) Wire_write_sn(*data, len) same n = Wire.available() n = Wire_available() same val = Wire.read() val = Wire_read() same Wire.flush() Wire_flush() same val = Wire.peek() val = Wire_peek() same Wire.requestFrom(addr, n) Wire_requestFrom(addr, n) Wire_requestFrom2 Wire.requestFrom(addr, n, sendStop) Wire_requestFrom(addr, n, sendStop) Wire_requestFrom3 Wire.requestFrom(addr, n, iaddr, isize, sendStop) Wire_requestFrom(addr, n, iaddr, isize, sendStop) Wire_requestFrom5 Wire.print(*str) Wire_print_s(*str) Print_print_s(Write_write1,*str) Wire.print(*data,len) Wire_print_sn(*data,len) Print_print_sn(Write_write1,*data,len) Wire.print(long) Wire_print_i(long) Print_print_i(Write_write1,long) Wire.print(ulong) Wire_print_u(ulong) Print_print_u(Write_write1,ulong) Wire.print(long,base) Wire_print_ib(long,base) Print_print_ib(Write_write1,long,base) Wire.print(ulong,base) Wire_print_ub(ulong,base) Print_print_ub(Write_write1,ulong,base) Wire.print(double) Wire_print_f(float) Print_print_f(Write_write1,float) Wire.print(double,dig) Wire_print_f(float,dig) Print_print_fd(Write_write1,float,dig) Wire.println() Wire_println() Print_println(Write_write1) Wire.println(*str) Wire_println_s(*str) Print_println_s(Write_write1,*str) Wire.println(*data,len) Wire_println_sn(*data,len) Print_println_sn(Write_write1,*data,len) Wire.println(long) Wire_println_i(long) Print_println_i(Write_write1,long) Wire.println(ulong) Wire_println_u(ulong) Print_println_u(Write_write1,ulong) Wire.println(long,base) Wire_println_ib(long,base) Print_println_ib(Write_write1,long,base) Wire.println(ulong,base) Wire_println_ub(ulong,base) Print_println_ub(Write_write1,ulong,base) Wire.println(double) Wire_println_f(float) Print_println_f(Write_write1,float) Wire.println(double,dig) Wire_println_f(float,dig) Print_println_fd(Write_write1,float,dig) Please note the polymorphism of the Wire_requestFrom() method. This is a special case and only possible for pre-instantiated singleton libraries. Due to the way sdcc invokes the preprocessor sdcpp the same trick doesn't work for functions without arguments - so we still need Wire_endTransmission() and Wire_endTransmission1(stop) . Hopefully, this inconsistency does not spread more confusion than it is worth. Timeout The timeout functionality was added for the Sduino port and is not part of the original library. The maximum transmission length is limited by the size of the data buffer of 32 bytes. At 100kHz this would take aprox. 3ms (1 address byte, 32 data bytes, 1 ACK bit after every byte). The default timeout is set to 20ms, that should work for most cases. If using a very slow device, the timeout can be changed using the Wire_setTimeout() function any time after initialzing the library by calling Wire_begin() . The timeout is defined in ms, so the maximum value for this 16 bit value represents about 65s - more than a minute. The value zero disables the timeout feature. Further reading Programming the I2C communication on the register level is quite complex for the STM8, especially in receive mode. The most detailed information on this topic is the application note AN3281 bundeled with the related source code package STSW-STM8004 Downloading from the ST website requires a (free) registration. Somebody uploaded the full package to a github repository There are some important notes on I2C implementation in the errata sheets: STM8S001J3/003xx/103xx/903xx Errata sheet, rev. 5 (CD00265449) STM8S005xx STM8S105xx Errata sheet, rev. 7 (CD00270741) STM8S007xx STM8S20xxx Errata sheet, rev. 6 (CD00244749)","title":"Wire"},{"location":"api/Wire/#wire","text":"This is an improved version of the stock Arduino Wire library for I2C communication. It shares most of the hardware related code with the re-write of the Sduino I2C library , but holds on to the Arduino API. The main difference between this STM8 version and the Arduino AVR version is the existance of a timeout function to prevent deadlocks due to failed communication. Polling mode is used for communication, interrupts are not supported (yet). So far, only Master Transmit and Master Receive modes are supported, slave modes are not implemented yet.","title":"Wire"},{"location":"api/Wire/#api","text":"This is a pre-instantiated singleton library. It is not possible to use more than one instance per sketch or to change the instance name. The API syntax is very similar to the original C++ syntax. Some name mangeling was needed to distinguish the different variants of the write() method. Apart from this replacing the dots in the method names for underscores is all it needs. Arduino syntax sduino syntax real function name Wire.begin() Wire_begin() same Wire.begin(ownaddress) slave mode not supported yet - Wire.end() Wire_end() same Wire.setClock(clock) Wire_setClock(clock) same not implemented Wire_timeOut(millisec) same Wire.beginTransmission(addr) Wire_beginTransmission(addr) same n = Wire.endTransmission() n = Wire_endTransmission() same (inline) n = Wire.endTransmission(stop) n = Wire_endTransmission1(stop) same Wire.write(val) Wire_write(val) same Wire.write(*str) Wire_write_s(*str) same Wire.write(*data, len) Wire_write_sn(*data, len) same n = Wire.available() n = Wire_available() same val = Wire.read() val = Wire_read() same Wire.flush() Wire_flush() same val = Wire.peek() val = Wire_peek() same Wire.requestFrom(addr, n) Wire_requestFrom(addr, n) Wire_requestFrom2 Wire.requestFrom(addr, n, sendStop) Wire_requestFrom(addr, n, sendStop) Wire_requestFrom3 Wire.requestFrom(addr, n, iaddr, isize, sendStop) Wire_requestFrom(addr, n, iaddr, isize, sendStop) Wire_requestFrom5 Wire.print(*str) Wire_print_s(*str) Print_print_s(Write_write1,*str) Wire.print(*data,len) Wire_print_sn(*data,len) Print_print_sn(Write_write1,*data,len) Wire.print(long) Wire_print_i(long) Print_print_i(Write_write1,long) Wire.print(ulong) Wire_print_u(ulong) Print_print_u(Write_write1,ulong) Wire.print(long,base) Wire_print_ib(long,base) Print_print_ib(Write_write1,long,base) Wire.print(ulong,base) Wire_print_ub(ulong,base) Print_print_ub(Write_write1,ulong,base) Wire.print(double) Wire_print_f(float) Print_print_f(Write_write1,float) Wire.print(double,dig) Wire_print_f(float,dig) Print_print_fd(Write_write1,float,dig) Wire.println() Wire_println() Print_println(Write_write1) Wire.println(*str) Wire_println_s(*str) Print_println_s(Write_write1,*str) Wire.println(*data,len) Wire_println_sn(*data,len) Print_println_sn(Write_write1,*data,len) Wire.println(long) Wire_println_i(long) Print_println_i(Write_write1,long) Wire.println(ulong) Wire_println_u(ulong) Print_println_u(Write_write1,ulong) Wire.println(long,base) Wire_println_ib(long,base) Print_println_ib(Write_write1,long,base) Wire.println(ulong,base) Wire_println_ub(ulong,base) Print_println_ub(Write_write1,ulong,base) Wire.println(double) Wire_println_f(float) Print_println_f(Write_write1,float) Wire.println(double,dig) Wire_println_f(float,dig) Print_println_fd(Write_write1,float,dig) Please note the polymorphism of the Wire_requestFrom() method. This is a special case and only possible for pre-instantiated singleton libraries. Due to the way sdcc invokes the preprocessor sdcpp the same trick doesn't work for functions without arguments - so we still need Wire_endTransmission() and Wire_endTransmission1(stop) . Hopefully, this inconsistency does not spread more confusion than it is worth.","title":"API"},{"location":"api/Wire/#timeout","text":"The timeout functionality was added for the Sduino port and is not part of the original library. The maximum transmission length is limited by the size of the data buffer of 32 bytes. At 100kHz this would take aprox. 3ms (1 address byte, 32 data bytes, 1 ACK bit after every byte). The default timeout is set to 20ms, that should work for most cases. If using a very slow device, the timeout can be changed using the Wire_setTimeout() function any time after initialzing the library by calling Wire_begin() . The timeout is defined in ms, so the maximum value for this 16 bit value represents about 65s - more than a minute. The value zero disables the timeout feature.","title":"Timeout"},{"location":"api/Wire/#further-reading","text":"Programming the I2C communication on the register level is quite complex for the STM8, especially in receive mode. The most detailed information on this topic is the application note AN3281 bundeled with the related source code package STSW-STM8004 Downloading from the ST website requires a (free) registration. Somebody uploaded the full package to a github repository There are some important notes on I2C implementation in the errata sheets: STM8S001J3/003xx/103xx/903xx Errata sheet, rev. 5 (CD00265449) STM8S005xx STM8S105xx Errata sheet, rev. 7 (CD00270741) STM8S007xx STM8S20xxx Errata sheet, rev. 6 (CD00244749)","title":"Further reading"},{"location":"api/migration/","text":"Migrating existing code from C++ to C syntax The original Arduino environment uses C++ syntax while sduino can only use plain C syntax. Luckily, not many C++ features are used and in most cases a conversion is not very hard. In most cases a conversion from C++ to C it is just a matter of exchanging a dot for an underscore: A C++ method name class.method() becomes a C function name class_method() . This is possible since most libraries are written to be used as a singleton anyway, so the fixed name prefix is not a problem. Only very few libraries need a slightly more complex approach to be able to deal with multiple instances. There are two bigger problems left: Polymorph functions The concept of polymorphism does not exist for plain C. As a workaround 'mangled' function names are used for the different parameter type combinations supported by the original polymorph methods. Typical name extensions are: _u for unsigned values, _i for signed integer values, _c for characters, _s for strings, _n for data buffer/length combinations. For more non-regular polymorphism the name extension is often related to the different use cases or to the names of the given parameters. Refer to the respective library header file for details. Some examples of typical name changes: C++ name C name Serial.print(int) Serial_print_i Serial.print(unsigned) Serial_print_u Serial.print(float) Serial_print_f Serial.print(char) Serial_print_c Serial.print(char *) Serial_print_s Serial.print(char *buf, int len) Serial_print_n Serial.print(unsigned n, int base) Serial_print_ub random(long) random random(long howsmall, long howbig) random_minmax The _Generic selection The C11 standard introduced the _Generic selection function. This function allows for automatic selection of different function variants at compile time depending on the type of the function arguments mimicing polymorph C++ functions. Recent versions of SDCC already support this function (command line argument --std-sdcc99 ), but it's usefulness is still limited to some special cases. #define Serial_print(X) _Generic((X), \\ char*: Serial_print_s, \\ signed long: Serial_print_i, \\ signed int: Serial_print_i, \\ signed char: Serial_print_c, \\ unsigned long: Serial_print_u, \\ unsigned int: Serial_print_u, \\ unsigned char: Serial_print_u \\ )(X) This would unify some, but not all print function variants: C++ name C name using _Generic Serial.print(int) Serial_print Serial.print(unsigned) Serial_print Serial.print(char) Serial_print Serial.print(char *) Serial_print_s Serial.print(char *buf, int len) Serial_print_n Serial.print(unsigned n, int base) Serial_print_ub Unfortunately cpp does not match string constants and char* resulting in a very non-regular usage pattern: char *string=\"Hello\"; Serial_print(string); // works Serial_print(\"Hello\"); // doesn't work Serial_print_s(\"Hello\");// works To avoid too much confusion it might be better to not use _Generic at all. Another problem using the _Generic selector is configurable instance names. The preprocessor does not allow for variable macro names. That means _Generic would work with fixed name like Serial , but it wouldn't work for SoftwareSerial with no standard instance name. This is a good introduction into the use of _Generic . Inheritance from Print class Most character output modules inherit methods from the Print class by providing a virtual write method. A similar result can be achived by providing a function pointer to the write function to be used to the print functions. This additional parameter is hidden from the user by providing more convinient defines in every library that need to 'inherit' functions from Print. This way lcd.print(\"Hello World!\") becomes lcd_print_s(\"Hello World!\") and Serial.print(\"Hello World!\") becomes Serial_print_s(\"Hello World!\") . Both call the same code from Print, but with different function pointers to their own putchar/write function. Libraries with multiple instances If multiple instances need to be supported, an approach similar to a C file descriptor is used. The \"constructor\" function allocates and initializes a data structure for one particular instance and return a pointer to this structure. Typically, this is done in the setup() -function and this pointer is stored in a global variable to be used as a device descriptor. So far the Stepper library is the only example: #include <Stepper.h> Stepper myStepper; // variable to store the \"device descriptor\" void setup(void) { myStepper = Stepper_2phase(100,11,12); // init a 2 phase stepper } void loop() { Stepper_step(myStepper, 20); // do 20 steps forward } Differences from the original Arduino environment Additional output pin modes Pin mode Pin properties OUTPUT output, push-pull, slow mode (default) OUTPUT_OD output, open drain, fast mode OUTPUT_FAST output, push-pull, fast mode OUTPUT_OD_FAST output, open drain, fast mode Timer millis() uses timer4. The prescaler and end value is calculated at compile time for a cycle time as close to 1ms as possible. Default values @16Mhz: prescaler=64, counter cycle=250 (end value=249), resulting in exactly 1ms intervals. timer1: PWM for PC3, PC4, on alternate mapping PC6, PC7, could be used for ADC timer2: PWM for PA3, PD3, PD4 or PC5 (mutual exclusive) timer4: millis() Leaving out unused parts Some functions of the core Arduino system can be left out on compilation to save code space. This is done by compiler flags that can be defined in the Makefile: BOARD_TAG = stm8sblue CFLAGS = -DNO_SERIAL -DNO_ANALOG_IN -DNO_ANALOG_OUT include ../../../sduino.mk These flags are supported: Flag Bytes saved Functions lost NO_SERIAL 765 all serial communication NO_ANALOG_OUT 406 analogWrite() NO_ANALOG_IN 56 analogRead() Other modifications makeWord(unsigned char, unsigned char) is an inline function now. Additional compile-time flags Some internal details can be influenced by setting compile-time defines using the CFLAGS=-Dflagname line in the Makefile. SUPPORT_ALTERNATE_MAPPINGS : Allow the use of alternateFunctions() ENABLE_SWIM : Do not disable the remote debugging function on the SWIM pin. This means that this pin can not be used for normal I/O functions. USE_SPL : Use SPL functions for I/O access instead of direct register accesses. Useful only for debugging and porting to other CPU variants. Do not use for regular development. General notes on the Arduino port ADC the prescaler is initialised for an ADC clock in the range of 1..2 MHz. The minimum prescaler value is 2, so for a clock speed of less than 2 MHz the required minimum ADC clock frequency can not be reached anymore. Mapping of logical pin numbers to register addresses The lookup-table approach for assigning port and bit adresses to the logical pin numbers is not effient on the STM8. The hole system could be changed to a more regular scheme and replace the tables by hardcoded adress calculations. Inefficient compilation digitalWrite compiles very ineffiently. It might be worth some hand optimization. Accessing the alternate pin functions Added alternateFunction() to allow switching of some pins to their alternate functions. This allows for three more PWM pins, but maybe it adds to much complexity for the Arduino API. Not sure if it should stay. Has to be enabled by defining SUPPORT_ALTERNATE_MAPPINGS . Useful CPU features that are not supported by the Arduino API Input-Capture-Mode: Available for all four channels, at least for timer1. Would be great for precise time measurements. Maybe build a library? Encoder interface mode: Hardware support for reading quadrature encoder and keeping track of the current (motor) position using a hardware timer counter. Perfectly suited to all kinds of position feedback.","title":"API description and migration guidelines"},{"location":"api/migration/#migrating-existing-code-from-c-to-c-syntax","text":"The original Arduino environment uses C++ syntax while sduino can only use plain C syntax. Luckily, not many C++ features are used and in most cases a conversion is not very hard. In most cases a conversion from C++ to C it is just a matter of exchanging a dot for an underscore: A C++ method name class.method() becomes a C function name class_method() . This is possible since most libraries are written to be used as a singleton anyway, so the fixed name prefix is not a problem. Only very few libraries need a slightly more complex approach to be able to deal with multiple instances. There are two bigger problems left:","title":"Migrating existing code from C++ to C syntax"},{"location":"api/migration/#polymorph-functions","text":"The concept of polymorphism does not exist for plain C. As a workaround 'mangled' function names are used for the different parameter type combinations supported by the original polymorph methods. Typical name extensions are: _u for unsigned values, _i for signed integer values, _c for characters, _s for strings, _n for data buffer/length combinations. For more non-regular polymorphism the name extension is often related to the different use cases or to the names of the given parameters. Refer to the respective library header file for details. Some examples of typical name changes: C++ name C name Serial.print(int) Serial_print_i Serial.print(unsigned) Serial_print_u Serial.print(float) Serial_print_f Serial.print(char) Serial_print_c Serial.print(char *) Serial_print_s Serial.print(char *buf, int len) Serial_print_n Serial.print(unsigned n, int base) Serial_print_ub random(long) random random(long howsmall, long howbig) random_minmax","title":"Polymorph functions"},{"location":"api/migration/#the-_generic-selection","text":"The C11 standard introduced the _Generic selection function. This function allows for automatic selection of different function variants at compile time depending on the type of the function arguments mimicing polymorph C++ functions. Recent versions of SDCC already support this function (command line argument --std-sdcc99 ), but it's usefulness is still limited to some special cases. #define Serial_print(X) _Generic((X), \\ char*: Serial_print_s, \\ signed long: Serial_print_i, \\ signed int: Serial_print_i, \\ signed char: Serial_print_c, \\ unsigned long: Serial_print_u, \\ unsigned int: Serial_print_u, \\ unsigned char: Serial_print_u \\ )(X) This would unify some, but not all print function variants: C++ name C name using _Generic Serial.print(int) Serial_print Serial.print(unsigned) Serial_print Serial.print(char) Serial_print Serial.print(char *) Serial_print_s Serial.print(char *buf, int len) Serial_print_n Serial.print(unsigned n, int base) Serial_print_ub Unfortunately cpp does not match string constants and char* resulting in a very non-regular usage pattern: char *string=\"Hello\"; Serial_print(string); // works Serial_print(\"Hello\"); // doesn't work Serial_print_s(\"Hello\");// works To avoid too much confusion it might be better to not use _Generic at all. Another problem using the _Generic selector is configurable instance names. The preprocessor does not allow for variable macro names. That means _Generic would work with fixed name like Serial , but it wouldn't work for SoftwareSerial with no standard instance name. This is a good introduction into the use of _Generic .","title":"The _Generic selection"},{"location":"api/migration/#inheritance-from-print-class","text":"Most character output modules inherit methods from the Print class by providing a virtual write method. A similar result can be achived by providing a function pointer to the write function to be used to the print functions. This additional parameter is hidden from the user by providing more convinient defines in every library that need to 'inherit' functions from Print. This way lcd.print(\"Hello World!\") becomes lcd_print_s(\"Hello World!\") and Serial.print(\"Hello World!\") becomes Serial_print_s(\"Hello World!\") . Both call the same code from Print, but with different function pointers to their own putchar/write function.","title":"Inheritance from Print class"},{"location":"api/migration/#libraries-with-multiple-instances","text":"If multiple instances need to be supported, an approach similar to a C file descriptor is used. The \"constructor\" function allocates and initializes a data structure for one particular instance and return a pointer to this structure. Typically, this is done in the setup() -function and this pointer is stored in a global variable to be used as a device descriptor. So far the Stepper library is the only example: #include <Stepper.h> Stepper myStepper; // variable to store the \"device descriptor\" void setup(void) { myStepper = Stepper_2phase(100,11,12); // init a 2 phase stepper } void loop() { Stepper_step(myStepper, 20); // do 20 steps forward }","title":"Libraries with multiple instances"},{"location":"api/migration/#differences-from-the-original-arduino-environment","text":"","title":"Differences from the original Arduino environment"},{"location":"api/migration/#additional-output-pin-modes","text":"Pin mode Pin properties OUTPUT output, push-pull, slow mode (default) OUTPUT_OD output, open drain, fast mode OUTPUT_FAST output, push-pull, fast mode OUTPUT_OD_FAST output, open drain, fast mode","title":"Additional output pin modes"},{"location":"api/migration/#timer","text":"millis() uses timer4. The prescaler and end value is calculated at compile time for a cycle time as close to 1ms as possible. Default values @16Mhz: prescaler=64, counter cycle=250 (end value=249), resulting in exactly 1ms intervals. timer1: PWM for PC3, PC4, on alternate mapping PC6, PC7, could be used for ADC timer2: PWM for PA3, PD3, PD4 or PC5 (mutual exclusive) timer4: millis()","title":"Timer"},{"location":"api/migration/#leaving-out-unused-parts","text":"Some functions of the core Arduino system can be left out on compilation to save code space. This is done by compiler flags that can be defined in the Makefile: BOARD_TAG = stm8sblue CFLAGS = -DNO_SERIAL -DNO_ANALOG_IN -DNO_ANALOG_OUT include ../../../sduino.mk These flags are supported: Flag Bytes saved Functions lost NO_SERIAL 765 all serial communication NO_ANALOG_OUT 406 analogWrite() NO_ANALOG_IN 56 analogRead()","title":"Leaving out unused parts"},{"location":"api/migration/#other-modifications","text":"makeWord(unsigned char, unsigned char) is an inline function now.","title":"Other modifications"},{"location":"api/migration/#additional-compile-time-flags","text":"Some internal details can be influenced by setting compile-time defines using the CFLAGS=-Dflagname line in the Makefile. SUPPORT_ALTERNATE_MAPPINGS : Allow the use of alternateFunctions() ENABLE_SWIM : Do not disable the remote debugging function on the SWIM pin. This means that this pin can not be used for normal I/O functions. USE_SPL : Use SPL functions for I/O access instead of direct register accesses. Useful only for debugging and porting to other CPU variants. Do not use for regular development.","title":"Additional compile-time flags"},{"location":"api/migration/#general-notes-on-the-arduino-port","text":"","title":"General notes on the Arduino port"},{"location":"api/migration/#adc","text":"the prescaler is initialised for an ADC clock in the range of 1..2 MHz. The minimum prescaler value is 2, so for a clock speed of less than 2 MHz the required minimum ADC clock frequency can not be reached anymore.","title":"ADC"},{"location":"api/migration/#mapping-of-logical-pin-numbers-to-register-addresses","text":"The lookup-table approach for assigning port and bit adresses to the logical pin numbers is not effient on the STM8. The hole system could be changed to a more regular scheme and replace the tables by hardcoded adress calculations.","title":"Mapping of logical pin numbers to register addresses"},{"location":"api/migration/#inefficient-compilation","text":"digitalWrite compiles very ineffiently. It might be worth some hand optimization.","title":"Inefficient compilation"},{"location":"api/migration/#accessing-the-alternate-pin-functions","text":"Added alternateFunction() to allow switching of some pins to their alternate functions. This allows for three more PWM pins, but maybe it adds to much complexity for the Arduino API. Not sure if it should stay. Has to be enabled by defining SUPPORT_ALTERNATE_MAPPINGS .","title":"Accessing the alternate pin functions"},{"location":"api/migration/#useful-cpu-features-that-are-not-supported-by-the-arduino-api","text":"Input-Capture-Mode: Available for all four channels, at least for timer1. Would be great for precise time measurements. Maybe build a library? Encoder interface mode: Hardware support for reading quadrature encoder and keeping track of the current (motor) position using a hardware timer counter. Perfectly suited to all kinds of position feedback.","title":"Useful CPU features that are not supported by the Arduino API"},{"location":"api/EEPROM/examples/eeprom_get/","text":"eeprom_get.ino /*** eeprom_get example. This shows how to use the EEPROM.get() method. To pre-set the EEPROM data, run the example sketch eeprom_put. This sketch will run without it, however, the values shown will be shown from what ever is already on the EEPROM. This may cause the serial object to print out a large string of garbage if there is no null character inside one of the strings loaded. Modified to C for use with SDuino by Michael Mayer 2018 Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void secondTest(); void setup() { float f = 0.00f; //Variable to store data read from EEPROM. int eeAddress = 0; //EEPROM address to start reading from Serial_begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial_print_s(\"Read float from EEPROM: \"); //Get the float data from the EEPROM at position 'eeAddress' EEPROM_get(eeAddress, f); Serial_println_fd(f, 3); //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float. /*** As get also returns a reference to 'f', you can use it inline. E.g: Serial.print( EEPROM.get( eeAddress, f ) ); ***/ /*** Get can be used with custom structures too. I have separated this into an extra function. ***/ secondTest(); //Run the next test. } struct MyObject { float field1; byte field2; char name[10]; }; void secondTest() { int eeAddress = sizeof(float); //Move address to the next byte after float 'f'. struct MyObject customVar; //Variable to store custom object read from EEPROM. EEPROM_get(eeAddress, customVar); Serial_println_s(\"Read custom object from EEPROM: \"); Serial_println_f(customVar.field1); Serial_println_u(customVar.field2); Serial_println_s(customVar.name); } void loop() { /* Empty loop */ }","title":"eeprom_get.ino"},{"location":"api/EEPROM/examples/eeprom_get/#eeprom_getino","text":"/*** eeprom_get example. This shows how to use the EEPROM.get() method. To pre-set the EEPROM data, run the example sketch eeprom_put. This sketch will run without it, however, the values shown will be shown from what ever is already on the EEPROM. This may cause the serial object to print out a large string of garbage if there is no null character inside one of the strings loaded. Modified to C for use with SDuino by Michael Mayer 2018 Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void secondTest(); void setup() { float f = 0.00f; //Variable to store data read from EEPROM. int eeAddress = 0; //EEPROM address to start reading from Serial_begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial_print_s(\"Read float from EEPROM: \"); //Get the float data from the EEPROM at position 'eeAddress' EEPROM_get(eeAddress, f); Serial_println_fd(f, 3); //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float. /*** As get also returns a reference to 'f', you can use it inline. E.g: Serial.print( EEPROM.get( eeAddress, f ) ); ***/ /*** Get can be used with custom structures too. I have separated this into an extra function. ***/ secondTest(); //Run the next test. } struct MyObject { float field1; byte field2; char name[10]; }; void secondTest() { int eeAddress = sizeof(float); //Move address to the next byte after float 'f'. struct MyObject customVar; //Variable to store custom object read from EEPROM. EEPROM_get(eeAddress, customVar); Serial_println_s(\"Read custom object from EEPROM: \"); Serial_println_f(customVar.field1); Serial_println_u(customVar.field2); Serial_println_s(customVar.name); } void loop() { /* Empty loop */ }","title":"eeprom_get.ino"},{"location":"api/EEPROM/examples/eeprom_put/","text":"eeprom_put.ino /*** eeprom_put example. This shows how to use the EEPROM.put() method. Also, this sketch will pre-set the EEPROM data for the example sketch eeprom_get. Note, unlike the single byte version EEPROM.write(), the put method will use update semantics. As in a byte will only be written to the EEPROM if the data is actually different. Modified to C for use with SDuino by Michael Mayer 2018 Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> struct MyObject { float field1; byte field2; char name[10]; }; void setup() { Serial_begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } float f = 123.456f; //Variable to store in EEPROM. int eeAddress = 0; //Location we want the data to be put. //One simple call, with the address first and the object second. EEPROM_put(eeAddress, f); Serial_println_s(\"Written float data type!\"); /** Put is designed for use with custom structures also. **/ //Data to store. struct MyObject customVar = { 3.14f, 65, \"Working!\" }; eeAddress += sizeof(float); //Move address to the next byte after float 'f'. EEPROM_put(eeAddress, customVar); Serial_print_s(\"Written custom data type! \\n\\nView the example sketch eeprom_get to see how you can retrieve the values!\"); } void loop() { /* Empty loop */ }","title":"eeprom_put.ino"},{"location":"api/EEPROM/examples/eeprom_put/#eeprom_putino","text":"/*** eeprom_put example. This shows how to use the EEPROM.put() method. Also, this sketch will pre-set the EEPROM data for the example sketch eeprom_get. Note, unlike the single byte version EEPROM.write(), the put method will use update semantics. As in a byte will only be written to the EEPROM if the data is actually different. Modified to C for use with SDuino by Michael Mayer 2018 Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> struct MyObject { float field1; byte field2; char name[10]; }; void setup() { Serial_begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } float f = 123.456f; //Variable to store in EEPROM. int eeAddress = 0; //Location we want the data to be put. //One simple call, with the address first and the object second. EEPROM_put(eeAddress, f); Serial_println_s(\"Written float data type!\"); /** Put is designed for use with custom structures also. **/ //Data to store. struct MyObject customVar = { 3.14f, 65, \"Working!\" }; eeAddress += sizeof(float); //Move address to the next byte after float 'f'. EEPROM_put(eeAddress, customVar); Serial_print_s(\"Written custom data type! \\n\\nView the example sketch eeprom_get to see how you can retrieve the values!\"); } void loop() { /* Empty loop */ }","title":"eeprom_put.ino"},{"location":"api/EEPROM/examples/eeprom_read/","text":"eeprom_read.ino /* * EEPROM Read * * Reads the value of each byte of the EEPROM and prints it * to the computer. * This example code is in the public domain. * * Modified to C for use with SDuino by Michael Mayer 2018 */ #include <EEPROM.h> // start reading from the first byte (address 0) of the EEPROM int address = 0; byte value; void setup() { // initialize serial and wait for port to open: Serial_begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } } void loop() { // read a byte from the current address of the EEPROM value = EEPROM_read(address); Serial_print_u(address); Serial_print_s(\"\\t\"); Serial_print_ub(value, DEC); Serial_println(); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduno Duemilanove: 512b EEPROM storage. - Arduino Uno: 1kb EEPROM storage. - Arduino Mega: 4kb EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM_length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM_length() - 1; ***/ delay(500); }","title":"eeprom_read.ino"},{"location":"api/EEPROM/examples/eeprom_read/#eeprom_readino","text":"/* * EEPROM Read * * Reads the value of each byte of the EEPROM and prints it * to the computer. * This example code is in the public domain. * * Modified to C for use with SDuino by Michael Mayer 2018 */ #include <EEPROM.h> // start reading from the first byte (address 0) of the EEPROM int address = 0; byte value; void setup() { // initialize serial and wait for port to open: Serial_begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } } void loop() { // read a byte from the current address of the EEPROM value = EEPROM_read(address); Serial_print_u(address); Serial_print_s(\"\\t\"); Serial_print_ub(value, DEC); Serial_println(); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduno Duemilanove: 512b EEPROM storage. - Arduino Uno: 1kb EEPROM storage. - Arduino Mega: 4kb EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM_length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM_length() - 1; ***/ delay(500); }","title":"eeprom_read.ino"},{"location":"api/EEPROM/examples/eeprom_update/","text":"eeprom_update.ino /*** EEPROM Update method Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. If a value has not changed in the EEPROM, it is not overwritten which would reduce the life span of the EEPROM unnecessarily. Modified to C for use with SDuino by Michael Mayer 2018 Released using MIT licence. ***/ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int address = 0; void setup() { /** EMpty setup **/ } void loop() { /*** need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Update the particular EEPROM cell. these values will remain there when the board is turned off. ***/ EEPROM_update(address, val); /*** The function EEPROM.update(address, val) is equivalent to the following: if( EEPROM_read(address) != val ){ EEPROM_write(address, val); } ***/ /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduno Duemilanove: 512b EEPROM storage. - Arduino Uno: 1kb EEPROM storage. - Arduino Mega: 4kb EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM_length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM_length() - 1; ***/ delay(100); }","title":"eeprom_update.ino"},{"location":"api/EEPROM/examples/eeprom_update/#eeprom_updateino","text":"/*** EEPROM Update method Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. If a value has not changed in the EEPROM, it is not overwritten which would reduce the life span of the EEPROM unnecessarily. Modified to C for use with SDuino by Michael Mayer 2018 Released using MIT licence. ***/ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int address = 0; void setup() { /** EMpty setup **/ } void loop() { /*** need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Update the particular EEPROM cell. these values will remain there when the board is turned off. ***/ EEPROM_update(address, val); /*** The function EEPROM.update(address, val) is equivalent to the following: if( EEPROM_read(address) != val ){ EEPROM_write(address, val); } ***/ /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduno Duemilanove: 512b EEPROM storage. - Arduino Uno: 1kb EEPROM storage. - Arduino Mega: 4kb EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM_length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM_length() - 1; ***/ delay(100); }","title":"eeprom_update.ino"},{"location":"api/EEPROM/examples/eeprom_write/","text":"eeprom_write.ino /* * EEPROM Write * * Stores values read from analog input 0 into the EEPROM. * These values will stay in the EEPROM when the board is * turned off and may be retrieved later by another sketch. * * Modified to C for use with SDuino by Michael Mayer 2018 */ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int addr = 0; void setup() { /** Empty setup. **/ } void loop() { /*** Need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Write the value to the appropriate byte of the EEPROM. these values will remain there when the board is turned off. ***/ EEPROM_write(addr, val); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduno Duemilanove: 512b EEPROM storage. - Arduino Uno: 1kb EEPROM storage. - Arduino Mega: 4kb EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ addr = addr + 1; if (addr == EEPROM_length()) { addr = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++addr &= EEPROM_length() - 1; ***/ delay(100); }","title":"eeprom_write.ino"},{"location":"api/EEPROM/examples/eeprom_write/#eeprom_writeino","text":"/* * EEPROM Write * * Stores values read from analog input 0 into the EEPROM. * These values will stay in the EEPROM when the board is * turned off and may be retrieved later by another sketch. * * Modified to C for use with SDuino by Michael Mayer 2018 */ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int addr = 0; void setup() { /** Empty setup. **/ } void loop() { /*** Need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Write the value to the appropriate byte of the EEPROM. these values will remain there when the board is turned off. ***/ EEPROM_write(addr, val); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduno Duemilanove: 512b EEPROM storage. - Arduino Uno: 1kb EEPROM storage. - Arduino Mega: 4kb EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ addr = addr + 1; if (addr == EEPROM_length()) { addr = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++addr &= EEPROM_length() - 1; ***/ delay(100); }","title":"eeprom_write.ino"},{"location":"developer/bare-metal-programming/","text":"Bare metal programming It all started by compiling some plain example programs without using any libraries. This avoids the code overhead of the Arduino libraries. Lujji posted a series of articles on bare metal programming of the STM8S CPUs. This is by far the best introduction I found so far. It would have helped me a lot if it would have been around at the time when I started this project. Modifications for the sdcc example programs I started my journey into the STM8 world with the stm8-examples-sdcc by Valentin Dudouyt (vdudouyt), the author of stm8flash . These examples are still part of the repository in examples/sdcc-examples-stm8. To compile for my STM8S103F3 board they required some modifications: blinky.c : LED pin assignment uart.c : pin assignment (TX is at PD5, RX is at PD6). The UART is sending at 1200 Baud => CPU clock only 2MHz instead of 16MHz. The clock divider needs to be configured or a different baud rate prescale value has to be used. Pitfall: The register address for the clock divider is different for the STM8S and the STM8L.","title":"Bare metal programming on the STM8"},{"location":"developer/bare-metal-programming/#bare-metal-programming","text":"It all started by compiling some plain example programs without using any libraries. This avoids the code overhead of the Arduino libraries. Lujji posted a series of articles on bare metal programming of the STM8S CPUs. This is by far the best introduction I found so far. It would have helped me a lot if it would have been around at the time when I started this project.","title":"Bare metal programming"},{"location":"developer/bare-metal-programming/#modifications-for-the-sdcc-example-programs","text":"I started my journey into the STM8 world with the stm8-examples-sdcc by Valentin Dudouyt (vdudouyt), the author of stm8flash . These examples are still part of the repository in examples/sdcc-examples-stm8. To compile for my STM8S103F3 board they required some modifications: blinky.c : LED pin assignment uart.c : pin assignment (TX is at PD5, RX is at PD6). The UART is sending at 1200 Baud => CPU clock only 2MHz instead of 16MHz. The clock divider needs to be configured or a different baud rate prescale value has to be used. Pitfall: The register address for the clock divider is different for the STM8S and the STM8L.","title":"Modifications for the sdcc example programs"},{"location":"developer/coding-style/","text":"Coding style Development workflow I recently read this great article about a successful branching model for git and will implement it. Highly recommended! Changelog Every feature branch (or pull request) should include an update for Changelog.md Code format When porting an existing Arduino library I try to preserve the original formatting as much as possible to allow for easy comparison to the original state. There is a development of a C++ capable compiler environment going on. There is no public website for that project yet, but I am in contact with the developer. He is even targeting Sduino for his project and at one point in the (still distant) future we might be able to switch back to the orginal library code again. Preserved code structure would be a big plus then. (But don't hold your breath yet) Newly written code is mostly formatted using indent according to the linux kernel coding style, using Tabs, Tab width 8, line length 80: indent -linux","title":"Coding style"},{"location":"developer/coding-style/#coding-style","text":"","title":"Coding style"},{"location":"developer/coding-style/#development-workflow","text":"I recently read this great article about a successful branching model for git and will implement it. Highly recommended!","title":"Development workflow"},{"location":"developer/coding-style/#changelog","text":"Every feature branch (or pull request) should include an update for Changelog.md","title":"Changelog"},{"location":"developer/coding-style/#code-format","text":"When porting an existing Arduino library I try to preserve the original formatting as much as possible to allow for easy comparison to the original state. There is a development of a C++ capable compiler environment going on. There is no public website for that project yet, but I am in contact with the developer. He is even targeting Sduino for his project and at one point in the (still distant) future we might be able to switch back to the orginal library code again. Preserved code structure would be a big plus then. (But don't hold your breath yet) Newly written code is mostly formatted using indent according to the linux kernel coding style, using Tabs, Tab width 8, line length 80: indent -linux","title":"Code format"},{"location":"developer/compiling-the-tools/","text":"Compiling the tools stm8gal Project repository: https://github.com/gicking/stm8gal git clone git@github.com:gicking/stm8gal.git For Linux cd stm8gal make cp -av stm8gal /usr/local/bin For Linux 32 bit on a 64 bit Linux system Required packages: apt install gcc-multilib libusb-1.0-0-dev:i386 Compiling stm8gal requires a small modification in the Makefile. For CFLAGS and LDFLAGS change the = operator to += to allow for additional parameters on the command line: cd stm8gal sed -i '/FLAGS/ s/ = / += /' Makefile Now start the compiler: CFLAGS=-m32 LDFLAGS=-m32 make For Windows Windows does not support an SPI device. Apply this patch to disable the compilation of spi_spidev_comm.c for Windows: patch -p1 < no-spi.patch Now compile: on a Windows system: make using mingw on Linux: make CC=i686-w64-mingw32-gcc OS=Win stm8flash Project repository: https://github.com/vdudouyt/stm8flash Compiling for Linux and OSX is straight forward, Windows is more complicated. For Linux Required packages: apt install libusb-1.0-0-dev Compiling stm8flash: git clone git@github.com:vdudouyt/stm8flash.git cd stm8flash make RELEASE=yes For Linux 32 bit on a 64 bit Linux system Required packages: apt install gcc-multilib libusb-1.0-0-dev:i386 Compiling stm8flash: git clone git@github.com:vdudouyt/stm8flash.git cd stm8flash make RELEASE=yes CFLAGS=-m32 Cross-Compiling for windows on a Linux system Current versions of stm8flash support the espstlink programmer. The programmer is conneced via USB and a virtual serial port, not over Wifi and for serial access the termios library is used. Being a POSIX function, this is not supported by mingw, only by cygwin. As a workaround apply this patch to disable the espstlink functionality on Windows systems: patch -p1 < no-espstlink-10810e88.patch Obviously, a better approach would be the use of a simple intermediate cross-platform layer like libserialport . Required packages: apt install mingw-w64 mingw-w64-tools Get stm8flash and patch the sources to cut out espstlink code: git clone git@github.com:vdudouyt/stm8flash.git cd stm8flash wget https://tenbaht.github.io/sduino/img/no-espstlink-10810e88.patch Download the 7z file containing the latest libusb dll binary . Unpack the archive into a new directory inside the stm8flash directory: 7z -owindows x <libusb-xxx.7z> Compiling stm8flash (as 32 bit binary for XP compatibility): make CC=i686-w64-mingw32-gcc RELEASE=yes CFLAGS=\"-Iwindows/include -Lwindows/MinGW32/dll\" PLATFORM=w7 For Windows on a Windows system https://github.com/orlp/dev-on-windows/wiki/Installing-GCC--&-MSYS2 Open msys window, execute pacman -Syuu , close window. repeat the before step until no more updates are found. do eigther the full install (700MB): pacman -S --needed base-devel mingw-w64-i686-toolchain or the reduced install (350MB): pacman -S --needed mingw-w64-i686-toolchain make grep sed pkg-config minimum install (150MB): pacman -S --needed mingw-w64-i686-binutils mingw-w64-i686-crt-git mingw-w64-i686-gcc mingw-w64-i686-gcc-libs mingw-w64-i686-headers-git mingw-w64-i686-libmangle-git mingw-w64-i686-libwinpthread-git mingw-w64-i686-make mingw-w64-i686-pkg-config mingw-w64-i686-tools-git mingw-w64-i686-winpthreads-git mingw-w64-i686-winstorecompat-git copy libusb-1.0/libusb.h and libusb.dll into current directory make RELEASE=yes CFLAGS=\"-I. -L.\" For Mac OSX stm8flash Required packages (libusb pulls in gcc if not already installed): brew install libusb pkg-config Change into the stm8flash source directory and change the #include \"libusb.h\" to \"#include \"libusb-1.0/libusb.h\"` (same as for Windows). Now it compiles: make RELEASE=yes stm8gal No SPI support, so compiling is similar to Windows and the same modification of the Makefile is necessary: Remove spi_spidev_comm.c from the list of source files in SOURCES in the Makefile. Now we can compile, but we need to convince the Makefile not to set the USE_SPIDEV define. An easy workaround to do so is to fool the Makefile into assuming a Windows build: make OS=Win","title":"Compiling the tools"},{"location":"developer/compiling-the-tools/#compiling-the-tools","text":"","title":"Compiling the tools"},{"location":"developer/compiling-the-tools/#stm8gal","text":"Project repository: https://github.com/gicking/stm8gal git clone git@github.com:gicking/stm8gal.git","title":"stm8gal"},{"location":"developer/compiling-the-tools/#for-linux","text":"cd stm8gal make cp -av stm8gal /usr/local/bin","title":"For Linux"},{"location":"developer/compiling-the-tools/#for-linux-32-bit-on-a-64-bit-linux-system","text":"Required packages: apt install gcc-multilib libusb-1.0-0-dev:i386 Compiling stm8gal requires a small modification in the Makefile. For CFLAGS and LDFLAGS change the = operator to += to allow for additional parameters on the command line: cd stm8gal sed -i '/FLAGS/ s/ = / += /' Makefile Now start the compiler: CFLAGS=-m32 LDFLAGS=-m32 make","title":"For Linux 32 bit on a 64 bit Linux system"},{"location":"developer/compiling-the-tools/#for-windows","text":"Windows does not support an SPI device. Apply this patch to disable the compilation of spi_spidev_comm.c for Windows: patch -p1 < no-spi.patch Now compile: on a Windows system: make using mingw on Linux: make CC=i686-w64-mingw32-gcc OS=Win","title":"For Windows"},{"location":"developer/compiling-the-tools/#stm8flash","text":"Project repository: https://github.com/vdudouyt/stm8flash Compiling for Linux and OSX is straight forward, Windows is more complicated.","title":"stm8flash"},{"location":"developer/compiling-the-tools/#for-linux_1","text":"Required packages: apt install libusb-1.0-0-dev Compiling stm8flash: git clone git@github.com:vdudouyt/stm8flash.git cd stm8flash make RELEASE=yes","title":"For Linux"},{"location":"developer/compiling-the-tools/#for-linux-32-bit-on-a-64-bit-linux-system_1","text":"Required packages: apt install gcc-multilib libusb-1.0-0-dev:i386 Compiling stm8flash: git clone git@github.com:vdudouyt/stm8flash.git cd stm8flash make RELEASE=yes CFLAGS=-m32","title":"For Linux 32 bit on a 64 bit Linux system"},{"location":"developer/compiling-the-tools/#cross-compiling-for-windows-on-a-linux-system","text":"Current versions of stm8flash support the espstlink programmer. The programmer is conneced via USB and a virtual serial port, not over Wifi and for serial access the termios library is used. Being a POSIX function, this is not supported by mingw, only by cygwin. As a workaround apply this patch to disable the espstlink functionality on Windows systems: patch -p1 < no-espstlink-10810e88.patch Obviously, a better approach would be the use of a simple intermediate cross-platform layer like libserialport . Required packages: apt install mingw-w64 mingw-w64-tools Get stm8flash and patch the sources to cut out espstlink code: git clone git@github.com:vdudouyt/stm8flash.git cd stm8flash wget https://tenbaht.github.io/sduino/img/no-espstlink-10810e88.patch Download the 7z file containing the latest libusb dll binary . Unpack the archive into a new directory inside the stm8flash directory: 7z -owindows x <libusb-xxx.7z> Compiling stm8flash (as 32 bit binary for XP compatibility): make CC=i686-w64-mingw32-gcc RELEASE=yes CFLAGS=\"-Iwindows/include -Lwindows/MinGW32/dll\" PLATFORM=w7","title":"Cross-Compiling for windows on a Linux system"},{"location":"developer/compiling-the-tools/#for-windows-on-a-windows-system","text":"https://github.com/orlp/dev-on-windows/wiki/Installing-GCC--&-MSYS2 Open msys window, execute pacman -Syuu , close window. repeat the before step until no more updates are found. do eigther the full install (700MB): pacman -S --needed base-devel mingw-w64-i686-toolchain or the reduced install (350MB): pacman -S --needed mingw-w64-i686-toolchain make grep sed pkg-config minimum install (150MB): pacman -S --needed mingw-w64-i686-binutils mingw-w64-i686-crt-git mingw-w64-i686-gcc mingw-w64-i686-gcc-libs mingw-w64-i686-headers-git mingw-w64-i686-libmangle-git mingw-w64-i686-libwinpthread-git mingw-w64-i686-make mingw-w64-i686-pkg-config mingw-w64-i686-tools-git mingw-w64-i686-winpthreads-git mingw-w64-i686-winstorecompat-git copy libusb-1.0/libusb.h and libusb.dll into current directory make RELEASE=yes CFLAGS=\"-I. -L.\"","title":"For Windows on a Windows system"},{"location":"developer/compiling-the-tools/#for-mac-osx","text":"","title":"For Mac OSX"},{"location":"developer/compiling-the-tools/#stm8flash_1","text":"Required packages (libusb pulls in gcc if not already installed): brew install libusb pkg-config Change into the stm8flash source directory and change the #include \"libusb.h\" to \"#include \"libusb-1.0/libusb.h\"` (same as for Windows). Now it compiles: make RELEASE=yes","title":"stm8flash"},{"location":"developer/compiling-the-tools/#stm8gal_1","text":"No SPI support, so compiling is similar to Windows and the same modification of the Makefile is necessary: Remove spi_spidev_comm.c from the list of source files in SOURCES in the Makefile. Now we can compile, but we need to convince the Makefile not to set the USE_SPIDEV define. An easy workaround to do so is to fool the Makefile into assuming a Windows build: make OS=Win","title":"stm8gal"},{"location":"developer/cross-compile-for-osx/","text":"Cross-Compile for OSX Compiling the tools is really easy. Only setting up the cross compilation environment requires a little more effort. But luckily, the osxcross project already took care of this. Setting up the cross compilation environment on Linux Mint 19 Install the needed dependencies I needed only these (the others were already present): sudo apt install clang llvm-dev uuid-dev libssl-dev libbz2-dev Full list of all dependencies: sudo apt install clang llvm-dev libxml2-dev uuid-dev libssl-dev bash patch make tar xz-utils bzip2 gzip sed cpio libbz2-dev Get the MacOSX SDK The official way Extract the needed files from the official SDKs Xcode 7.3 from the Apple Developer website using the scripts that come with osxcross: sudo apt install cmake libxml2-dev fuse libfuse-dev ./tools/gen_sdk_package_darling_dmg.sh path/to/SDK-file On Ubuntu-based distributions with a name not containing the string \"ubuntu\" (like Linux Mint) you will get an error message \"Required kernel module 'fuse' not loaded\". To fix this, \"echo out\" the line modinfo fuse &>/dev/null in tools/gen_sdk_package_darling_dmg.sh by changing it to echo modinfo fuse &>/dev/null before running it (don't delete it or comment it out). diff --git a/tools/gen_sdk_package_darling_dmg.sh b/tools/gen_sdk_package_darling_dmg.sh index 8cd23e5..b271450 100755 --- a/tools/gen_sdk_package_darling_dmg.sh +++ b/tools/gen_sdk_package_darling_dmg.sh @@ -40,7 +40,7 @@ command -v lsb_release 2>&1 > /dev/null if [[ $? -eq 0 ]] && [[ -n $(lsb_release -a 2>&1 | grep -i ubuntu) ]]; then echo \"Using ubuntu, skipping fuse module check\" else - modinfo fuse &>/dev/null + echo modinfo fuse &>/dev/null fi if [ $? -ne 0 ]; then Now move the resulting file MacOSX10.11.sdk.tar.xz into the tarball directory. The easy way Somebody was kind enough to set up a repository with all the MacOSX SDKs . This saves you the trouble of downloading multiple gigabytes of data and running the extraction script. Download the file MacOSX10.11.sdk.tar.xz into the tarball directory. Build OSXcross: ./build.sh sudo mv target /opt/osxcross Add /opt/osxcross/bin to your $PATH and prepare macports: export MACOSX_DEPLOYMENT_TARGET=10.7 export PATH=$PATH:/opt/osxcross/bin osxcross-macports update-cache Build stm8flash osxcross-macports install libusb-devel make CC=o64-clang CXX=o64-clang++ PKGCONFIG=x86_64-apple-darwin15-pkg-config RELEASE=yes Or with full path if you didn't add the osxcross binary directory do your PATH: make CC=/opt/osxcross/bin/o64-clang CXX=/opt/osxcross/bin/o64-clang++ PKGCONFIG=/opt/osxcross/bin/x86_64-apple-darwin15-pkg-config RELEASE=yes Build stm8gal make CC=o64-clang That's all!","title":"Cross-compiling the tools for OSX"},{"location":"developer/cross-compile-for-osx/#cross-compile-for-osx","text":"Compiling the tools is really easy. Only setting up the cross compilation environment requires a little more effort. But luckily, the osxcross project already took care of this.","title":"Cross-Compile for OSX"},{"location":"developer/cross-compile-for-osx/#setting-up-the-cross-compilation-environment-on-linux-mint-19","text":"","title":"Setting up the cross compilation environment on Linux Mint 19"},{"location":"developer/cross-compile-for-osx/#install-the-needed-dependencies","text":"I needed only these (the others were already present): sudo apt install clang llvm-dev uuid-dev libssl-dev libbz2-dev Full list of all dependencies: sudo apt install clang llvm-dev libxml2-dev uuid-dev libssl-dev bash patch make tar xz-utils bzip2 gzip sed cpio libbz2-dev","title":"Install the needed dependencies"},{"location":"developer/cross-compile-for-osx/#get-the-macosx-sdk","text":"","title":"Get the MacOSX SDK"},{"location":"developer/cross-compile-for-osx/#the-official-way","text":"Extract the needed files from the official SDKs Xcode 7.3 from the Apple Developer website using the scripts that come with osxcross: sudo apt install cmake libxml2-dev fuse libfuse-dev ./tools/gen_sdk_package_darling_dmg.sh path/to/SDK-file On Ubuntu-based distributions with a name not containing the string \"ubuntu\" (like Linux Mint) you will get an error message \"Required kernel module 'fuse' not loaded\". To fix this, \"echo out\" the line modinfo fuse &>/dev/null in tools/gen_sdk_package_darling_dmg.sh by changing it to echo modinfo fuse &>/dev/null before running it (don't delete it or comment it out). diff --git a/tools/gen_sdk_package_darling_dmg.sh b/tools/gen_sdk_package_darling_dmg.sh index 8cd23e5..b271450 100755 --- a/tools/gen_sdk_package_darling_dmg.sh +++ b/tools/gen_sdk_package_darling_dmg.sh @@ -40,7 +40,7 @@ command -v lsb_release 2>&1 > /dev/null if [[ $? -eq 0 ]] && [[ -n $(lsb_release -a 2>&1 | grep -i ubuntu) ]]; then echo \"Using ubuntu, skipping fuse module check\" else - modinfo fuse &>/dev/null + echo modinfo fuse &>/dev/null fi if [ $? -ne 0 ]; then Now move the resulting file MacOSX10.11.sdk.tar.xz into the tarball directory.","title":"The official way"},{"location":"developer/cross-compile-for-osx/#the-easy-way","text":"Somebody was kind enough to set up a repository with all the MacOSX SDKs . This saves you the trouble of downloading multiple gigabytes of data and running the extraction script. Download the file MacOSX10.11.sdk.tar.xz into the tarball directory.","title":"The easy way"},{"location":"developer/cross-compile-for-osx/#build-osxcross","text":"./build.sh sudo mv target /opt/osxcross Add /opt/osxcross/bin to your $PATH and prepare macports: export MACOSX_DEPLOYMENT_TARGET=10.7 export PATH=$PATH:/opt/osxcross/bin osxcross-macports update-cache","title":"Build OSXcross:"},{"location":"developer/cross-compile-for-osx/#build-stm8flash","text":"osxcross-macports install libusb-devel make CC=o64-clang CXX=o64-clang++ PKGCONFIG=x86_64-apple-darwin15-pkg-config RELEASE=yes Or with full path if you didn't add the osxcross binary directory do your PATH: make CC=/opt/osxcross/bin/o64-clang CXX=/opt/osxcross/bin/o64-clang++ PKGCONFIG=/opt/osxcross/bin/x86_64-apple-darwin15-pkg-config RELEASE=yes","title":"Build stm8flash"},{"location":"developer/cross-compile-for-osx/#build-stm8gal","text":"make CC=o64-clang That's all!","title":"Build stm8gal"},{"location":"developer/cross-compile/","text":"The compiler environments for Linux 32 bit and ARM (Raspberry) conflict with each other on Debian/Ubuntu/Mint and uninstall each other: https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211/comments/29","title":"Cross compile"},{"location":"developer/ide-integration/","text":"IDE integration The IDE uses arduino-builder as a build tool. This tool is tightly build around the gcc. It always assumes that the main sketch is a cpp file and it includes hardcoded assumptions about the file suffixes '.o' for object files and '.a' for libraries. As SDCC is not flexible about file suffix' as well we need some wrapper scripts to convert the different suffixes before and after the compiler run: file type gcc file suffix SDCC file suffix source file any .c object file .o .rel library archive .a .lib dependency file .d .d Linux and MacOS I like minimal approaches and usually prefer using dash over bash. Less features => less problems. You know. The linker wrapper sdcc-link.sh is tricky, as we need to parse all arguments, modify them if an object file or a library is found and call sdcc with the full list. The required array handling is not implemented in dash, so we are stuck with the full bash. bash on Windows Using the bash.exe from the MinGW project we can use the same script files even for Windows. Figuring out the path The hard part is locating the executeables without requiring the user to modify the PATH variable. Relative to the location of the wrapper scripts the executeables for cp and rm are in ../win . But a simple simple cd ../win or ../win/cp does't work, as the current working directory at this point is still the Arduino binary directory. Since the script is called with a full absolute path, we can extract the needed path from there. This is the obvious solution: PATH=\"${0%/wrapper/*}\"/win:$PATH It looks ok, but it doesn't work on some Windows systems. It will result in an absolute path like C:\\Users\\michael\\AppData\\Local\\Arduino15\\packages\\sduino\\tools\\STM8Tools/win . On some systems this works, on some it doesn't. Surprisingly, the mingw system somehow decides to set the tools/STM8Tools directory as the root directory. On some systems absolute paths above that point are ok, on some systems they are not. No idea why. And no idea where this root base is defined (or how to influence it). How can the bash.exe know that it was extracted from a tar file below the tools/STM8Tools directory? So we need a plan B. This is technically wrong, but surprisingly it works with Windows: cd $0/../.. PATH=$(pwd)/win:$PATH The pwd has the positive side effect of converting the path from Windows to Unix syntax avoiding all these backslash issues. Finally, this is syntactally correct and works on all systems: cd \"${0%/wrapper/*}\" PATH=$(pwd)/win:$PATH All together it leds to this solution: # check if cp is in the path if ! command -v cp > /dev/null; then cd \"${0%/wrapper/*}\" PATH=$(pwd)/win:$PATH fi Now we are ready to go even on Windows. All used functions command , cd and pwd and the pattern matching are POSIX-conformant builtin shell functions without any external dependencies resulting in almost no overhead and high portability. Using only cmd.exe It might be possible to get away with straight cmd.exe batch programming. But my ambitions of getting into Windows programming are very limited, so maybe somebody else would like to investigate this.","title":"IDE integration"},{"location":"developer/ide-integration/#ide-integration","text":"The IDE uses arduino-builder as a build tool. This tool is tightly build around the gcc. It always assumes that the main sketch is a cpp file and it includes hardcoded assumptions about the file suffixes '.o' for object files and '.a' for libraries. As SDCC is not flexible about file suffix' as well we need some wrapper scripts to convert the different suffixes before and after the compiler run: file type gcc file suffix SDCC file suffix source file any .c object file .o .rel library archive .a .lib dependency file .d .d","title":"IDE integration"},{"location":"developer/ide-integration/#linux-and-macos","text":"I like minimal approaches and usually prefer using dash over bash. Less features => less problems. You know. The linker wrapper sdcc-link.sh is tricky, as we need to parse all arguments, modify them if an object file or a library is found and call sdcc with the full list. The required array handling is not implemented in dash, so we are stuck with the full bash.","title":"Linux and MacOS"},{"location":"developer/ide-integration/#bash-on-windows","text":"Using the bash.exe from the MinGW project we can use the same script files even for Windows.","title":"bash on Windows"},{"location":"developer/ide-integration/#figuring-out-the-path","text":"The hard part is locating the executeables without requiring the user to modify the PATH variable. Relative to the location of the wrapper scripts the executeables for cp and rm are in ../win . But a simple simple cd ../win or ../win/cp does't work, as the current working directory at this point is still the Arduino binary directory. Since the script is called with a full absolute path, we can extract the needed path from there. This is the obvious solution: PATH=\"${0%/wrapper/*}\"/win:$PATH It looks ok, but it doesn't work on some Windows systems. It will result in an absolute path like C:\\Users\\michael\\AppData\\Local\\Arduino15\\packages\\sduino\\tools\\STM8Tools/win . On some systems this works, on some it doesn't. Surprisingly, the mingw system somehow decides to set the tools/STM8Tools directory as the root directory. On some systems absolute paths above that point are ok, on some systems they are not. No idea why. And no idea where this root base is defined (or how to influence it). How can the bash.exe know that it was extracted from a tar file below the tools/STM8Tools directory? So we need a plan B. This is technically wrong, but surprisingly it works with Windows: cd $0/../.. PATH=$(pwd)/win:$PATH The pwd has the positive side effect of converting the path from Windows to Unix syntax avoiding all these backslash issues. Finally, this is syntactally correct and works on all systems: cd \"${0%/wrapper/*}\" PATH=$(pwd)/win:$PATH All together it leds to this solution: # check if cp is in the path if ! command -v cp > /dev/null; then cd \"${0%/wrapper/*}\" PATH=$(pwd)/win:$PATH fi Now we are ready to go even on Windows. All used functions command , cd and pwd and the pattern matching are POSIX-conformant builtin shell functions without any external dependencies resulting in almost no overhead and high portability.","title":"Figuring out the path"},{"location":"developer/ide-integration/#using-only-cmdexe","text":"It might be possible to get away with straight cmd.exe batch programming. But my ambitions of getting into Windows programming are very limited, so maybe somebody else would like to investigate this.","title":"Using only cmd.exe"},{"location":"developer/links/","text":"Links Further reading and application notes A very good and compact primer on STM8S-Programming . Does not rely on any external libraries. A series of articles on bare metal programming of the STM8S CPUs. By far the best introduction I found so far. It would have helped me a lot if it would have around at the time when I started this project. Quick introduction to the Arduino.mk makefile on hackaday.com PM0051 : STM8AF Flash programming manual UM0470 : STM8 SWIM protocol and debug manual AN2658 : Using the analog-to-digital converter of the STM8S microcontroller Many examples and presentations about the STM8S It contains the SPL examples from ST , one of the most useful resources on the STM8. Hardware and pinouts of several ST-Link compatible flash tools Using the ADC by Mark Stevens Example for RS-232 handling with SPL AN3139 : Migration guideline within the STM8L familiy Similar or related projects None of these projects are related to or part of Sduino. They are written independently, but with a similar goal in mind: To simplify STM8 programming for the beginner. STM8Sduino : A minimalistic approach to adopt parts of the Arduino-API to the STM8. Based on IAR and COSMIC compiler (Windows only). Port to SDCC shouldn't be too hard but is not done yet. Low overhead, but basic functions only. No support for porting Arduino libraries. Other interesting STM8-related projects gdb support for the STM8 STM8 toolchain with GDB debugger and SDCC. Use the hardware debugging feature of the STM8 with ST-Link and gdb. STVD-SDCC integration suite","title":"Links and further reading"},{"location":"developer/links/#links","text":"","title":"Links"},{"location":"developer/links/#further-reading-and-application-notes","text":"A very good and compact primer on STM8S-Programming . Does not rely on any external libraries. A series of articles on bare metal programming of the STM8S CPUs. By far the best introduction I found so far. It would have helped me a lot if it would have around at the time when I started this project. Quick introduction to the Arduino.mk makefile on hackaday.com PM0051 : STM8AF Flash programming manual UM0470 : STM8 SWIM protocol and debug manual AN2658 : Using the analog-to-digital converter of the STM8S microcontroller Many examples and presentations about the STM8S It contains the SPL examples from ST , one of the most useful resources on the STM8. Hardware and pinouts of several ST-Link compatible flash tools Using the ADC by Mark Stevens Example for RS-232 handling with SPL AN3139 : Migration guideline within the STM8L familiy","title":"Further reading and application notes"},{"location":"developer/links/#similar-or-related-projects","text":"None of these projects are related to or part of Sduino. They are written independently, but with a similar goal in mind: To simplify STM8 programming for the beginner. STM8Sduino : A minimalistic approach to adopt parts of the Arduino-API to the STM8. Based on IAR and COSMIC compiler (Windows only). Port to SDCC shouldn't be too hard but is not done yet. Low overhead, but basic functions only. No support for porting Arduino libraries.","title":"Similar or related projects"},{"location":"developer/links/#other-interesting-stm8-related-projects","text":"gdb support for the STM8 STM8 toolchain with GDB debugger and SDCC. Use the hardware debugging feature of the STM8 with ST-Link and gdb. STVD-SDCC integration suite","title":"Other interesting STM8-related projects"},{"location":"developer/macro/","text":"Preprocessor macros to disguise plain C as C++ Porting some Arduino-like functions to C is not too difficult. The challenge is to keep the syntax differences to the real C++-based Arduino system as small a possible while still using plain C. There are subtle differences in the API concepts of the Arduino libraries. Unfortunatly, they all require different strategies to mimic a C++ user API. The basic criteria are: multi-instance or single-instance is a constructor call mandatory or not (typically the begin() -method) Additionally, there are some more detailed destinctions: polymorph instantiation declaration or simple declaration general single instance library or pre-instantiated single instance library inheritance via virtual methods (most output-type libraries inherit from the Print class) As a result, there are several different cases to consider: Single-instance, pre-instantiated, with constructor The data is kept locally within the class module. There is no instantiation declaration. No instance references need to be passed to any any function calls. All initialization is done by the constructor function. This is the easiest and most straight-forward case. No help from the preprocessor is required. It is sufficient to choose the function names to match the original class::method names. Polymorph methods are represented by a set of name-mangled functions. The behaviour of this construction is very similar to a real C++ class. Examples: SPI , I2C , HardwareSerial #include <I2C.h> setup() { I2c_begin(); I2c_write(0x1e, 0x02,0x00); } Required preprocessor help none Single-instance, with constructor The data is kept locally within the class module. The instantiation declaration defines the one instance name to be used. It might pass some configuration data which is remembered for later use. As there is always exactly one instance, no instance references need to be remembered and passed to any function calls. The instance name is more a cosmetic issue. The constructor does the actual configuration and initialization. It might use the configuration data given earlier with the instantiation declaration. The behaviour of this construction is very similar to a real C++ class. Polymorph instantiation declarations are possible. Non-constant values for the initialization are supported. Examples: LiquidCrystal int rs_pin = 2; LiquidCrystal (lcd, rs_pin,3,4, 5,6,7,8); setup() { lcd_begin(16,2); lcd_setCursor(0,1); lcd_print_s(\"Hello, world!\"); } Required preprocessor help polymorph instantiation remember configuration data for later use with the constructor setting up alias definitions to include the instance name in the function names. Multi-instance class, with constructor The data can be kept locally within the class module. The constructor allocates and initializes the required data structure and does required I/O-initializations. It returns a reference item to identify the instance. This reference item is typically a pointer to the instance structure or and index number to an internal table. It is passed to any following method call. The behaviour of this construction is very similar to a real C++ class. The main pitfall is the missing automatic destructor call. Luckily, this C++ feature is rarely used, anyway. Polymorph instantiation declarations are possible. Examples: Servo #include <Servo.h> Servo(servo1); Servo(servo2); setup() { servo1_attach(5); servo2_attach(6); } loop() { servo1_write(90); servo2_write(150); } Required preprocessor help polymorph instantiation remember configuration data for later use with the constructor save the instance reference item on initialization setting up alias definitions to include the instance name in the function names and include the instance reference item with the parameter list of every function call. Multi-instance class, no constructor As there is no strictly defined first function call which could allocate and initialize internal data structures, the data has to be kept in a data structure in the user area. A pointer to this data structure is passed to any following method call. This case can be difficult. As there is no dedicated constructor call, the library has to keep track if the current instance has been initialized already and has to do so if not. That means, that the needed I/O resources can't be initialized before the first function call. That might be a problem for some applications as I/O pins might stay in a floating input state for quite some time. Second drawback of this concept is the fact, that the instance data initialization values have to be known at compile time and can't be variables or the result of function calls at run time, e.g. from a configuration space in EEPROM. To solve these two problems it might be necessary to introduce an additional constructor-type function, that can be called from the setup() function or for any needed reconfiguration. Since the instance data is in the user space anyway, it could be modified there directly. But this would be an even worse violation of all modularization concepts and should be avoided. Polymorph instantiation declarations are possible. Examples: Stepper By requiring the user to add a call to the added constructor as the mandatory first call to the instance it could be treated as any other multi-instance class with constructor, see above. The resulting API is not identical to Arduino anymore, but still very similar. #include <Stepper.h> Stepper (StepperA, 100, 6, 7); Stepper (StepperB, 200, 8, 9, 10, 11); void setup() { StepperA_setSpeed(60); StepperB_setSpeed(60); } void loop() { StepperA_step(20); StepperB_step(40); } Required preprocessor help polymorph instantiation. convert the instantiation declaration into an instance data item declaration and initialization. setting up alias definitions to include the instance name in the function names and include a pointer to the instance data item with the parameter list of every function call. Inheritance Most output-type libraries inherit the methods from class Print by providing a matching write() method. This works by providing all print functions a function pointer to the write function, that should be used. Required preprocessor help setting up alias definitions to include the instance name of the output module in the function names of the print functions and include a pointer to the output write function with the parameter list of every (aliased) print function call. Further reading Polymorphism relies on variadic macros. Daniel Hardman wrote a very understandable step-by-step introduction .","title":"C preprocessor macro magic"},{"location":"developer/macro/#preprocessor-macros-to-disguise-plain-c-as-c","text":"Porting some Arduino-like functions to C is not too difficult. The challenge is to keep the syntax differences to the real C++-based Arduino system as small a possible while still using plain C. There are subtle differences in the API concepts of the Arduino libraries. Unfortunatly, they all require different strategies to mimic a C++ user API. The basic criteria are: multi-instance or single-instance is a constructor call mandatory or not (typically the begin() -method) Additionally, there are some more detailed destinctions: polymorph instantiation declaration or simple declaration general single instance library or pre-instantiated single instance library inheritance via virtual methods (most output-type libraries inherit from the Print class) As a result, there are several different cases to consider:","title":"Preprocessor macros to disguise plain C as C++"},{"location":"developer/macro/#single-instance-pre-instantiated-with-constructor","text":"The data is kept locally within the class module. There is no instantiation declaration. No instance references need to be passed to any any function calls. All initialization is done by the constructor function. This is the easiest and most straight-forward case. No help from the preprocessor is required. It is sufficient to choose the function names to match the original class::method names. Polymorph methods are represented by a set of name-mangled functions. The behaviour of this construction is very similar to a real C++ class. Examples: SPI , I2C , HardwareSerial #include <I2C.h> setup() { I2c_begin(); I2c_write(0x1e, 0x02,0x00); }","title":"Single-instance, pre-instantiated, with constructor"},{"location":"developer/macro/#required-preprocessor-help","text":"none","title":"Required preprocessor help"},{"location":"developer/macro/#single-instance-with-constructor","text":"The data is kept locally within the class module. The instantiation declaration defines the one instance name to be used. It might pass some configuration data which is remembered for later use. As there is always exactly one instance, no instance references need to be remembered and passed to any function calls. The instance name is more a cosmetic issue. The constructor does the actual configuration and initialization. It might use the configuration data given earlier with the instantiation declaration. The behaviour of this construction is very similar to a real C++ class. Polymorph instantiation declarations are possible. Non-constant values for the initialization are supported. Examples: LiquidCrystal int rs_pin = 2; LiquidCrystal (lcd, rs_pin,3,4, 5,6,7,8); setup() { lcd_begin(16,2); lcd_setCursor(0,1); lcd_print_s(\"Hello, world!\"); }","title":"Single-instance, with constructor"},{"location":"developer/macro/#required-preprocessor-help_1","text":"polymorph instantiation remember configuration data for later use with the constructor setting up alias definitions to include the instance name in the function names.","title":"Required preprocessor help"},{"location":"developer/macro/#multi-instance-class-with-constructor","text":"The data can be kept locally within the class module. The constructor allocates and initializes the required data structure and does required I/O-initializations. It returns a reference item to identify the instance. This reference item is typically a pointer to the instance structure or and index number to an internal table. It is passed to any following method call. The behaviour of this construction is very similar to a real C++ class. The main pitfall is the missing automatic destructor call. Luckily, this C++ feature is rarely used, anyway. Polymorph instantiation declarations are possible. Examples: Servo #include <Servo.h> Servo(servo1); Servo(servo2); setup() { servo1_attach(5); servo2_attach(6); } loop() { servo1_write(90); servo2_write(150); }","title":"Multi-instance class, with constructor"},{"location":"developer/macro/#required-preprocessor-help_2","text":"polymorph instantiation remember configuration data for later use with the constructor save the instance reference item on initialization setting up alias definitions to include the instance name in the function names and include the instance reference item with the parameter list of every function call.","title":"Required preprocessor help"},{"location":"developer/macro/#multi-instance-class-no-constructor","text":"As there is no strictly defined first function call which could allocate and initialize internal data structures, the data has to be kept in a data structure in the user area. A pointer to this data structure is passed to any following method call. This case can be difficult. As there is no dedicated constructor call, the library has to keep track if the current instance has been initialized already and has to do so if not. That means, that the needed I/O resources can't be initialized before the first function call. That might be a problem for some applications as I/O pins might stay in a floating input state for quite some time. Second drawback of this concept is the fact, that the instance data initialization values have to be known at compile time and can't be variables or the result of function calls at run time, e.g. from a configuration space in EEPROM. To solve these two problems it might be necessary to introduce an additional constructor-type function, that can be called from the setup() function or for any needed reconfiguration. Since the instance data is in the user space anyway, it could be modified there directly. But this would be an even worse violation of all modularization concepts and should be avoided. Polymorph instantiation declarations are possible. Examples: Stepper By requiring the user to add a call to the added constructor as the mandatory first call to the instance it could be treated as any other multi-instance class with constructor, see above. The resulting API is not identical to Arduino anymore, but still very similar. #include <Stepper.h> Stepper (StepperA, 100, 6, 7); Stepper (StepperB, 200, 8, 9, 10, 11); void setup() { StepperA_setSpeed(60); StepperB_setSpeed(60); } void loop() { StepperA_step(20); StepperB_step(40); }","title":"Multi-instance class, no constructor"},{"location":"developer/macro/#required-preprocessor-help_3","text":"polymorph instantiation. convert the instantiation declaration into an instance data item declaration and initialization. setting up alias definitions to include the instance name in the function names and include a pointer to the instance data item with the parameter list of every function call.","title":"Required preprocessor help"},{"location":"developer/macro/#inheritance","text":"Most output-type libraries inherit the methods from class Print by providing a matching write() method. This works by providing all print functions a function pointer to the write function, that should be used.","title":"Inheritance"},{"location":"developer/macro/#required-preprocessor-help_4","text":"setting up alias definitions to include the instance name of the output module in the function names of the print functions and include a pointer to the output write function with the parameter list of every (aliased) print function call.","title":"Required preprocessor help"},{"location":"developer/macro/#further-reading","text":"Polymorphism relies on variadic macros. Daniel Hardman wrote a very understandable step-by-step introduction .","title":"Further reading"},{"location":"developer/optimizations/","text":"Optimizations The goal is to reduce the size of the generated binaries. This is done by aiding the linker to eleminate dead code by splitting large source files and by hand-optimizing individual functions. Results The sum of all these optimizations reduces the total size of Blink.ino by more than 30%, saving more than 800 bytes of precious flash space: code data RAM flash total split stage 2507 138 72 2645 before split 2450 138 72 2588 after splitting wiring.c 2381 138 72 2519 after splitting wiring_digital.c 1799 138 72 1937 after splitting HardwareSerial.c 1686 138 72 1824 after optimizing pinMode() Data is mostly the tables to map the Arduino pin numbers to the actual port registers. RAM is mostly the transmit and receive buffers for serial communication. These can't easily be optimized out. Splitting files The SDCC linker does not detect unused functions and constants in an object file. It always links the whole file even if only a single symbol contained in the file is referenced. This results in pretty bloated binaries if the SPL is used. Splitting larger source files into smaller units and compile them individually before building the libraries helps the SDCC linker to eleminate dead code and to produce smaller binaries. Splitting files is worthwhile for all SPL files and at least some of the bigger Arduino core files. The stategy The SPL consists of many source files with a very regular structure. This allows to automate the splitting process with very little preparation work. All SPL functions are documented with a doxygen comment block. The beginning of this comment block is a line with only \"/**\", that can easily be used as a marker for splitting the files. Only the very first block is special. It contains definitions and prototypes that are needed all over the module. This block is saved as a .h file and #include 'd by all the following blocks. In most cases this is already sufficient. Only in very rare cases the position of a split needs the be edited. To prevent a split : Change the /** line into something different, /*** is used in the scripts. To force a split : Add an empty Doxygen comment block: /** * This is just a split marker */ Splitting the SPL files Splitting and compiling the SPL libraries is moved into the separate project spl-splitter now. Split Arduino core files The Arduino files don't have any regular structure. They need to be edited to become splitable at all and some of the resulting split files still need manual adjustments. wiring.c , wiring_digital.c and HardwareSerial.c all compile into quite large binaries. All of them are linked with almost every project. This is true even if no serial communication is used since main.c references serialEvent() and this way pulls in all of HardwareSerial. Splitting these three files reduces the size of simple sketches significantly. It does not help so much for complex sketches that use almost all functions of these modules. Optimizing individual functions pinMode() sticks out when looking at the size of individual functions. 270 bytes for just setting the IO-mode of a pin. A re-write in assember reduces this to just 147 bytes.","title":"Optimizations"},{"location":"developer/optimizations/#optimizations","text":"The goal is to reduce the size of the generated binaries. This is done by aiding the linker to eleminate dead code by splitting large source files and by hand-optimizing individual functions.","title":"Optimizations"},{"location":"developer/optimizations/#results","text":"The sum of all these optimizations reduces the total size of Blink.ino by more than 30%, saving more than 800 bytes of precious flash space: code data RAM flash total split stage 2507 138 72 2645 before split 2450 138 72 2588 after splitting wiring.c 2381 138 72 2519 after splitting wiring_digital.c 1799 138 72 1937 after splitting HardwareSerial.c 1686 138 72 1824 after optimizing pinMode() Data is mostly the tables to map the Arduino pin numbers to the actual port registers. RAM is mostly the transmit and receive buffers for serial communication. These can't easily be optimized out.","title":"Results"},{"location":"developer/optimizations/#splitting-files","text":"The SDCC linker does not detect unused functions and constants in an object file. It always links the whole file even if only a single symbol contained in the file is referenced. This results in pretty bloated binaries if the SPL is used. Splitting larger source files into smaller units and compile them individually before building the libraries helps the SDCC linker to eleminate dead code and to produce smaller binaries. Splitting files is worthwhile for all SPL files and at least some of the bigger Arduino core files.","title":"Splitting files"},{"location":"developer/optimizations/#the-stategy","text":"The SPL consists of many source files with a very regular structure. This allows to automate the splitting process with very little preparation work. All SPL functions are documented with a doxygen comment block. The beginning of this comment block is a line with only \"/**\", that can easily be used as a marker for splitting the files. Only the very first block is special. It contains definitions and prototypes that are needed all over the module. This block is saved as a .h file and #include 'd by all the following blocks. In most cases this is already sufficient. Only in very rare cases the position of a split needs the be edited. To prevent a split : Change the /** line into something different, /*** is used in the scripts. To force a split : Add an empty Doxygen comment block: /** * This is just a split marker */","title":"The stategy"},{"location":"developer/optimizations/#splitting-the-spl-files","text":"Splitting and compiling the SPL libraries is moved into the separate project spl-splitter now.","title":"Splitting the SPL files"},{"location":"developer/optimizations/#split-arduino-core-files","text":"The Arduino files don't have any regular structure. They need to be edited to become splitable at all and some of the resulting split files still need manual adjustments. wiring.c , wiring_digital.c and HardwareSerial.c all compile into quite large binaries. All of them are linked with almost every project. This is true even if no serial communication is used since main.c references serialEvent() and this way pulls in all of HardwareSerial. Splitting these three files reduces the size of simple sketches significantly. It does not help so much for complex sketches that use almost all functions of these modules.","title":"Split Arduino core files"},{"location":"developer/optimizations/#optimizing-individual-functions","text":"pinMode() sticks out when looking at the size of individual functions. 270 bytes for just setting the IO-mode of a pin. A re-write in assember reduces this to just 147 bytes.","title":"Optimizing individual functions"},{"location":"developer/performance/","text":"Performance The STM8 backend for SDCC has improved a lot since the release of version 3.6.0 in June 2016. But due to the very small number of registers the code size will almost always be bigger than for the AVR. Depending on the exact application the difference is anywhere between negligible and factor two. Comparing code size with the original AVR Arduino Benchmarking the original Arduino examples from Arduino 1.0.5. The simple Blinky compiles to 57 bytes of code, the total binary including the sduino libraries is 1868 Bytes (0x74c). So far, wiring_analog depends on wiring_digital, even when analogWrite is not used. This could be solved by compiling the sduino functions separately into a library. Name Code Total Linked files other than main and wiring 01. Basics/ BareMinimum 2 1238 - Blink 57 1870 wiring_digital AnalogReadSerial 205 3452 digital, analog, serial, print DigitalReadSerial 57 3160 digital, serial, print Fade 226 2189 digital, analog ReadAnalogVoltage float not yet implemented 02. Digital/ Debounce 192 2016 digital Float arithmetics Floating point arithmetics is supported by the SDCC standard library, but it comes at a pretty high cost in terms of code space and CPU load. This is how much the generated code grows by using a single float operation compared to using a long int: Floating point operation approx. code size addition 736 Bytes subtraction 754 Bytes division 673 Bytes multiplication 907 Bytes sinf() or cosf() 3346 Bytes log10f() 3437 Bytes The Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple simple program with only very little floating point arithmetics. But it already uses 7336 bytes of flash. A similar sketch using integer arithmetics results in much more compact code occuping only 3791 bytes. Float does work, but is better to be avoided and replaced by fixed point arithmetics whenever possible.","title":"Performance comparison and benchmarking"},{"location":"developer/performance/#performance","text":"The STM8 backend for SDCC has improved a lot since the release of version 3.6.0 in June 2016. But due to the very small number of registers the code size will almost always be bigger than for the AVR. Depending on the exact application the difference is anywhere between negligible and factor two.","title":"Performance"},{"location":"developer/performance/#comparing-code-size-with-the-original-avr-arduino","text":"Benchmarking the original Arduino examples from Arduino 1.0.5. The simple Blinky compiles to 57 bytes of code, the total binary including the sduino libraries is 1868 Bytes (0x74c). So far, wiring_analog depends on wiring_digital, even when analogWrite is not used. This could be solved by compiling the sduino functions separately into a library. Name Code Total Linked files other than main and wiring 01. Basics/ BareMinimum 2 1238 - Blink 57 1870 wiring_digital AnalogReadSerial 205 3452 digital, analog, serial, print DigitalReadSerial 57 3160 digital, serial, print Fade 226 2189 digital, analog ReadAnalogVoltage float not yet implemented 02. Digital/ Debounce 192 2016 digital","title":"Comparing code size with the original AVR Arduino"},{"location":"developer/performance/#float-arithmetics","text":"Floating point arithmetics is supported by the SDCC standard library, but it comes at a pretty high cost in terms of code space and CPU load. This is how much the generated code grows by using a single float operation compared to using a long int: Floating point operation approx. code size addition 736 Bytes subtraction 754 Bytes division 673 Bytes multiplication 907 Bytes sinf() or cosf() 3346 Bytes log10f() 3437 Bytes The Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple simple program with only very little floating point arithmetics. But it already uses 7336 bytes of flash. A similar sketch using integer arithmetics results in much more compact code occuping only 3791 bytes. Float does work, but is better to be avoided and replaced by fixed point arithmetics whenever possible.","title":"Float arithmetics"},{"location":"developer/pin_mapping/","text":"Pin mapping scheme Many Arduino sketches and libraries contain hard-coded assumptions about the number of pins with special functions. Ideally, all these numbers would be the same and all programs could be compiled without changes. This is not possible, but let's check how close we could get for the STM8S103F. Possible logical pin number mappings Functional mapping would try to match the pins with special functions (like serial, SPI, I2C, analog input and PWM output) as closely as possible. Geometrical mapping would choose a logical order of the CPU pins as they are accessible on the CPU or with a breakout board. Functional mapping would allow for designing a PCB using the Arduino Uno form factor and take advantage of all the existing shields (as long as they are 3.3V compatible). The number of needed changes to existing sketches would be cut down to a minimum. The downside would be a pretty random order of pin numbers when using a simple breakout board. Geometrical mapping is easier for breadboard use, but will always require changes on existing sketches. Since we need to modify them from C++ to C syntax anyway that is maybe a less severe problem than it sounds. a) Matching the communication pins STM8 pin Name Alt Arduino pin ATmega pin Alt PD6 RX Ain6 0 PD0 PD5 TX Ain5 1 PD1 PA3 SS 10 PB2 PWM PC6 MOSI 11 PB3 PWM PC7 MISO 12 PB4 PC5 SCK 13 PB5 LED PB5 SDA LED 18 PC4 Ain4 PB4 SCL 19 PC5 Ain5 b) Matching the analog inputs STM8 pin Name Alt Arduino pin ATmega pin Alt C4 Ain2 D2 Ain3 D3 Ain4 D5 Ain5 TX D6 Ain6 RX c) Matching the PWM-capable pins STM8 pin Name Alt Arduino pin ATmega pin Alt 3 5 6 9 ( 10 ) ( 11 ) d) Matching the LED: (collision) STM8 pin Name Alt Arduino pin ATmega pin Alt PB5 SDA 13 SCK e) Simple geometric numbering for SO20 package (count up from 1, starting at pin 1) 1-3 -> PD4-PD6 4-6 -> PA1-PA3 7-8 -> PB5-PB4 (reverse order) 9-13 -> PC3-PC7 14-16 -> PD1-PD3 SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings -> error prone) I2C: 7,8 serial: 2,3 Analog: 2,3,10,15,16 (data sheet order would be: 10,15,16,2,3) Easy and logical for use on a breadboard Logical port pin ordering Analog pins are scattered All functions use totally different pin numbers than Arduino f) Simple geometric numbering for square UFQFPN20 package (count up from 0, starting at pin 2/PA1) 0-2 -> PA1-PA3 3-4 -> PB5-PB4 (reverse order) 5-9 -> PC3-PC7 10-15 -> PD1-PD6 serial: 14,15 SPI: 2,7,8,9 I2C: 3,4 Analog: 6,11,12,14,15 (for an easier structure maybe use non-continous numbers for the Arduino-like Ax-numbers: A0, A1, A2, A4, A5) PWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping) PWM Bitmap pin 15-0: 0011 0000 0110 0100 = 0x3064 (regular mapping) PWM Bitmap pin 15-0: 0001 0011 1110 0100 = 0x13e4 (alternate mapping) Easy and logical for use on a breadboard Very clear and logical port pin ordering Analog pins are still scattered around TX and RX would be the rarely used analog pin numbers A3/A4 or A4/A5 at the end of the analog pin number list At least the analog pins are in data sheet order All functions use totally different pin numbers than Arduino Comparing the results Compare logical/functional mapping vs. simple geometrical numbering Phys. STM8 pin Name Functions Functional mapping Geometrical mapping strict from PA1 1 PD4 UART_CLK/T2-1/beep 5 1~ 13~ 2 PD5 TX/Ain5 1 2 14/A3 3 PD6 RX/Ain6 0 3 15/A4 5 PA1 (OscIn, kein HS) 6 4 0 6 PA2 (OscIn, kein HS) 7 5 1 10 PA3 SS/T2-3 10 6~ 2~ 11 PB5 SDA LED 18 7 3 12 PB4 SCL 19 8 4 13 PC3 T1-3/[T1-n1] 9 9~ 5~(n~) 14 PC4 T1-4/Ain2/[T1-n2] 4 10~ 6~(n~)/A0 15 PC5 SCK/[T2-1] 13 11~ 7(~) 16 PC6 MOSI/[T1-1] 11 12~ 8(~) 17 PC7 MISO/[T1-2] 12 13~ 9(~) 18 PD1 (SWIM) 8 14 10 19 PD2 Ain3/[T2-3] 3 15(~) 11(~~)/A1 20 PD3 Ain4/T2-2 2 16~ 12~/A2 Functional pin mapping: TX/RX,SPI,I2C match the Arduino numbers Analog mapped to D0-D4 (instead of D14-D19), PWM 2,3,4,5,9,10,11,12,13 (Arduino PWM: 3,5,6,9,10,11, all matched except for pin 6) non-existant: 14-17 -> it might be better to map I2C to 14 and 15. Strict geometrical pin mapping: SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings -> error prone) I2C: 7,8 serial: 2,3 analog: 2,3,10,15,16 PWM regular: 2,12,13 PWM alternate: 7,8,9 PWM alternate negative: 5,6 PWM alternate (duplicates): 11 Pin remapping Some functions share the same CPU port pin. The Alternate function remapping register (AFR) is used to choose the actual function. Most important choice is for pin PC5-PC7: SPI (default) or PWM (alternate). Unfortunatly, this influences PD4 as well (default PWM, alternate non-PWM). The AFR is two EEPROM cells at 0x4803 (OPT2) and 0x4804 (NOPT2, inverted). Programmable via SWIM (see UM0470) and in IAP-Mode (see PM0051). Bit Pin influenced Function for 0 Function for 1 AFR7 PC3,PC4 default TIM1_CH1N, TIM1_CH2N AFR4 PB4,PB5 default ADC_ETR, TIM1_BKIN AFR3 PC3 default TLI AFR1 PA3,PD2 default SPI_NSS, TIM2_CH3 AFR0 PC5-PC7 GPIO/SPI TIM2_CH1, TIM1_CH1, TIM1_CH2","title":"Ways to define a pin mapping"},{"location":"developer/pin_mapping/#pin-mapping-scheme","text":"Many Arduino sketches and libraries contain hard-coded assumptions about the number of pins with special functions. Ideally, all these numbers would be the same and all programs could be compiled without changes. This is not possible, but let's check how close we could get for the STM8S103F.","title":"Pin mapping scheme"},{"location":"developer/pin_mapping/#possible-logical-pin-number-mappings","text":"Functional mapping would try to match the pins with special functions (like serial, SPI, I2C, analog input and PWM output) as closely as possible. Geometrical mapping would choose a logical order of the CPU pins as they are accessible on the CPU or with a breakout board. Functional mapping would allow for designing a PCB using the Arduino Uno form factor and take advantage of all the existing shields (as long as they are 3.3V compatible). The number of needed changes to existing sketches would be cut down to a minimum. The downside would be a pretty random order of pin numbers when using a simple breakout board. Geometrical mapping is easier for breadboard use, but will always require changes on existing sketches. Since we need to modify them from C++ to C syntax anyway that is maybe a less severe problem than it sounds.","title":"Possible logical pin number mappings"},{"location":"developer/pin_mapping/#a-matching-the-communication-pins","text":"STM8 pin Name Alt Arduino pin ATmega pin Alt PD6 RX Ain6 0 PD0 PD5 TX Ain5 1 PD1 PA3 SS 10 PB2 PWM PC6 MOSI 11 PB3 PWM PC7 MISO 12 PB4 PC5 SCK 13 PB5 LED PB5 SDA LED 18 PC4 Ain4 PB4 SCL 19 PC5 Ain5","title":"a) Matching the communication pins"},{"location":"developer/pin_mapping/#b-matching-the-analog-inputs","text":"STM8 pin Name Alt Arduino pin ATmega pin Alt C4 Ain2 D2 Ain3 D3 Ain4 D5 Ain5 TX D6 Ain6 RX","title":"b) Matching the analog inputs"},{"location":"developer/pin_mapping/#c-matching-the-pwm-capable-pins","text":"STM8 pin Name Alt Arduino pin ATmega pin Alt 3 5 6 9 ( 10 ) ( 11 )","title":"c) Matching the PWM-capable pins"},{"location":"developer/pin_mapping/#d-matching-the-led-collision","text":"STM8 pin Name Alt Arduino pin ATmega pin Alt PB5 SDA 13 SCK","title":"d) Matching the LED: (collision)"},{"location":"developer/pin_mapping/#e-simple-geometric-numbering-for-so20-package-count-up-from-1-starting-at-pin-1","text":"1-3 -> PD4-PD6 4-6 -> PA1-PA3 7-8 -> PB5-PB4 (reverse order) 9-13 -> PC3-PC7 14-16 -> PD1-PD3 SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings -> error prone) I2C: 7,8 serial: 2,3 Analog: 2,3,10,15,16 (data sheet order would be: 10,15,16,2,3) Easy and logical for use on a breadboard Logical port pin ordering Analog pins are scattered All functions use totally different pin numbers than Arduino","title":"e) Simple geometric numbering for SO20 package (count up from 1, starting at pin 1)"},{"location":"developer/pin_mapping/#f-simple-geometric-numbering-for-square-ufqfpn20-package-count-up-from-0-starting-at-pin-2pa1","text":"0-2 -> PA1-PA3 3-4 -> PB5-PB4 (reverse order) 5-9 -> PC3-PC7 10-15 -> PD1-PD6 serial: 14,15 SPI: 2,7,8,9 I2C: 3,4 Analog: 6,11,12,14,15 (for an easier structure maybe use non-continous numbers for the Arduino-like Ax-numbers: A0, A1, A2, A4, A5) PWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping) PWM Bitmap pin 15-0: 0011 0000 0110 0100 = 0x3064 (regular mapping) PWM Bitmap pin 15-0: 0001 0011 1110 0100 = 0x13e4 (alternate mapping) Easy and logical for use on a breadboard Very clear and logical port pin ordering Analog pins are still scattered around TX and RX would be the rarely used analog pin numbers A3/A4 or A4/A5 at the end of the analog pin number list At least the analog pins are in data sheet order All functions use totally different pin numbers than Arduino","title":"f) Simple geometric numbering for square UFQFPN20 package (count up from 0, starting at pin 2/PA1)"},{"location":"developer/pin_mapping/#comparing-the-results","text":"Compare logical/functional mapping vs. simple geometrical numbering Phys. STM8 pin Name Functions Functional mapping Geometrical mapping strict from PA1 1 PD4 UART_CLK/T2-1/beep 5 1~ 13~ 2 PD5 TX/Ain5 1 2 14/A3 3 PD6 RX/Ain6 0 3 15/A4 5 PA1 (OscIn, kein HS) 6 4 0 6 PA2 (OscIn, kein HS) 7 5 1 10 PA3 SS/T2-3 10 6~ 2~ 11 PB5 SDA LED 18 7 3 12 PB4 SCL 19 8 4 13 PC3 T1-3/[T1-n1] 9 9~ 5~(n~) 14 PC4 T1-4/Ain2/[T1-n2] 4 10~ 6~(n~)/A0 15 PC5 SCK/[T2-1] 13 11~ 7(~) 16 PC6 MOSI/[T1-1] 11 12~ 8(~) 17 PC7 MISO/[T1-2] 12 13~ 9(~) 18 PD1 (SWIM) 8 14 10 19 PD2 Ain3/[T2-3] 3 15(~) 11(~~)/A1 20 PD3 Ain4/T2-2 2 16~ 12~/A2 Functional pin mapping: TX/RX,SPI,I2C match the Arduino numbers Analog mapped to D0-D4 (instead of D14-D19), PWM 2,3,4,5,9,10,11,12,13 (Arduino PWM: 3,5,6,9,10,11, all matched except for pin 6) non-existant: 14-17 -> it might be better to map I2C to 14 and 15. Strict geometrical pin mapping: SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings -> error prone) I2C: 7,8 serial: 2,3 analog: 2,3,10,15,16 PWM regular: 2,12,13 PWM alternate: 7,8,9 PWM alternate negative: 5,6 PWM alternate (duplicates): 11","title":"Comparing the results"},{"location":"developer/pin_mapping/#pin-remapping","text":"Some functions share the same CPU port pin. The Alternate function remapping register (AFR) is used to choose the actual function. Most important choice is for pin PC5-PC7: SPI (default) or PWM (alternate). Unfortunatly, this influences PD4 as well (default PWM, alternate non-PWM). The AFR is two EEPROM cells at 0x4803 (OPT2) and 0x4804 (NOPT2, inverted). Programmable via SWIM (see UM0470) and in IAP-Mode (see PM0051). Bit Pin influenced Function for 0 Function for 1 AFR7 PC3,PC4 default TIM1_CH1N, TIM1_CH2N AFR4 PB4,PB5 default ADC_ETR, TIM1_BKIN AFR3 PC3 default TLI AFR1 PA3,PD2 default SPI_NSS, TIM2_CH3 AFR0 PC5-PC7 GPIO/SPI TIM2_CH1, TIM1_CH1, TIM1_CH2","title":"Pin remapping"},{"location":"developer/sdcc/","text":"Compiler Tutorials: http://www.cnx-software.com/2015/04/13/how-to-program-stm8s-1-board-in-linux/ STM8-Support only started with Version 3.4 in Ubuntu 14.10. For Ubuntu 14.4: add-apt-repository ppa:laczik/ppa apt-get update apt-get install sdcc But even this version is fairly old and contains some known bugs. Better download a current snapshot build from http://sdcc.sourceforge.net/ and unpack it to /opt/sdcc . This requires a current version of libstdc++6: add-apt-repository ppa:ubuntu-toolchain-r/test apt-get update apt-get install libstdc++6 If you prefer to compile stm8flash yourself instead of using the Linux binaries in the tools directory: git clone https://github.com/vdudouyt/stm8flash.git cd stm8flash make sudo make install Download some example code: git clone https://github.com/vdudouyt/sdcc-examples-stm8.git cd sdcc-examples-stm8 The examples are meant for the STM8L, not the STM8S. This requires some changes to account for the different pinout and register addresses (see below). Finally upload the binary to the CPU: stm8flash -c stlinkv2 -p stm8s103?3 -w blinky.ihx Mixing assembler code with C code c-code: stacktest(0x1234, 0x5678); assember: push #0x78 push #0x56 push #0x34 push #0x12 call _stacktest resulting stack content (starting at [SP], using simulator sstm8): 0> dch 0x17f9 0x017f9 c0 80 ab 12 34 56 78 5b ....4Vx[ => first paramter starts at [SP+3], MSB first. Register assignment return values : 8 bit values in A, 16 bit values in X, 32 bit values in Y/X (Y=MSB, X=LSB) register preservation : Not implemented for the STM8 (yet?). For some architectures SDCC implements the possibility to mark a function that it does not effect the contents of some registers: void f(void) __preserves_regs(b, c, iyl, iyh); Direct memory access To access a memory location without using a pointer variable it is possible to do things like this: #define ODR (*((unsigned char *)0x5005)) #define bitSet(value, bit) ((value) |= (1 << (bit))) void main() { bitSet(ODR, 3); *((unsigned char *) 0x5005) |= 4; } Notes on SDCC The linker sdld does not automatically link the object file for main.c if it is part of a library. It must be part of the list of object files. (Important for the build process with Arduino.mk) Befehl __critical{..} sollte eigentlich den vorherigen Interrupt-Zustand wiederherstellen, es wird aber einfach ein festes Paar sim/rim produziert. Mit \"push cc; sim\" und \"pop cc\" klappt es im Simulator, aber nicht in der Realit\u00e4t. F\u00fcr jeden benutzten Interrupt muss ein Prototyp in der Datei stehen, in der auch main() definiert ist. Aber f\u00fcr jeden Prototypen, f\u00fcr den es keine Funktion gibt, ergibt einen Linkerfehler. Das erkl\u00e4rt den Sinn von stm8s_it.h im Projektverzeichniss. Eine Arduino-\u00e4hnliche Umgebung muss diese Datei also nach Analyse aller Sourcen selber erzeugen. Simulator sstm8 Has improved a lot recently. The UART and timer part is usable now (as of rev. 9998) and the subtle differences in the memory layout of the I/O section for the different cpu subtypes are factored in. Make sure to use a recent snapshot build if you are planing to use simulator! Missing peephole optimisations See discussion of issue #14 Missing compiler features _ _preserves_regs() function attribute not supported _ attribute _((weak)) _ _critical{} generates sim/rim instead of push cc,sim/pop cc dead code elimination: Does not recognize tables of const values. Using a const table would still pull in the whole object file, even when all accesses to the table have been eleminated by the optimizer. Only way out is to use #define statements instead.","title":"Using the SDCC compiler"},{"location":"developer/sdcc/#compiler","text":"Tutorials: http://www.cnx-software.com/2015/04/13/how-to-program-stm8s-1-board-in-linux/ STM8-Support only started with Version 3.4 in Ubuntu 14.10. For Ubuntu 14.4: add-apt-repository ppa:laczik/ppa apt-get update apt-get install sdcc But even this version is fairly old and contains some known bugs. Better download a current snapshot build from http://sdcc.sourceforge.net/ and unpack it to /opt/sdcc . This requires a current version of libstdc++6: add-apt-repository ppa:ubuntu-toolchain-r/test apt-get update apt-get install libstdc++6 If you prefer to compile stm8flash yourself instead of using the Linux binaries in the tools directory: git clone https://github.com/vdudouyt/stm8flash.git cd stm8flash make sudo make install Download some example code: git clone https://github.com/vdudouyt/sdcc-examples-stm8.git cd sdcc-examples-stm8 The examples are meant for the STM8L, not the STM8S. This requires some changes to account for the different pinout and register addresses (see below). Finally upload the binary to the CPU: stm8flash -c stlinkv2 -p stm8s103?3 -w blinky.ihx","title":"Compiler"},{"location":"developer/sdcc/#mixing-assembler-code-with-c-code","text":"c-code: stacktest(0x1234, 0x5678); assember: push #0x78 push #0x56 push #0x34 push #0x12 call _stacktest resulting stack content (starting at [SP], using simulator sstm8): 0> dch 0x17f9 0x017f9 c0 80 ab 12 34 56 78 5b ....4Vx[ => first paramter starts at [SP+3], MSB first.","title":"Mixing assembler code with C code"},{"location":"developer/sdcc/#register-assignment","text":"return values : 8 bit values in A, 16 bit values in X, 32 bit values in Y/X (Y=MSB, X=LSB) register preservation : Not implemented for the STM8 (yet?). For some architectures SDCC implements the possibility to mark a function that it does not effect the contents of some registers: void f(void) __preserves_regs(b, c, iyl, iyh);","title":"Register assignment"},{"location":"developer/sdcc/#direct-memory-access","text":"To access a memory location without using a pointer variable it is possible to do things like this: #define ODR (*((unsigned char *)0x5005)) #define bitSet(value, bit) ((value) |= (1 << (bit))) void main() { bitSet(ODR, 3); *((unsigned char *) 0x5005) |= 4; }","title":"Direct memory access"},{"location":"developer/sdcc/#notes-on-sdcc","text":"The linker sdld does not automatically link the object file for main.c if it is part of a library. It must be part of the list of object files. (Important for the build process with Arduino.mk) Befehl __critical{..} sollte eigentlich den vorherigen Interrupt-Zustand wiederherstellen, es wird aber einfach ein festes Paar sim/rim produziert. Mit \"push cc; sim\" und \"pop cc\" klappt es im Simulator, aber nicht in der Realit\u00e4t. F\u00fcr jeden benutzten Interrupt muss ein Prototyp in der Datei stehen, in der auch main() definiert ist. Aber f\u00fcr jeden Prototypen, f\u00fcr den es keine Funktion gibt, ergibt einen Linkerfehler. Das erkl\u00e4rt den Sinn von stm8s_it.h im Projektverzeichniss. Eine Arduino-\u00e4hnliche Umgebung muss diese Datei also nach Analyse aller Sourcen selber erzeugen.","title":"Notes on SDCC"},{"location":"developer/sdcc/#simulator-sstm8","text":"Has improved a lot recently. The UART and timer part is usable now (as of rev. 9998) and the subtle differences in the memory layout of the I/O section for the different cpu subtypes are factored in. Make sure to use a recent snapshot build if you are planing to use simulator!","title":"Simulator sstm8"},{"location":"developer/sdcc/#missing-peephole-optimisations","text":"See discussion of issue #14","title":"Missing peephole optimisations"},{"location":"developer/sdcc/#missing-compiler-features","text":"_ _preserves_regs() function attribute not supported _ attribute _((weak)) _ _critical{} generates sim/rim instead of push cc,sim/pop cc dead code elimination: Does not recognize tables of const values. Using a const table would still pull in the whole object file, even when all accesses to the table have been eleminated by the optimizer. Only way out is to use #define statements instead.","title":"Missing compiler features"},{"location":"developer/spl/","text":"ST Standard Peripherie Library The Library an be downloaded from the ST website (free registration required). A slightly older version is part of the STM8S_Teach presentation , Don't miss the Examples folder within the downloaded zip file. This and Lujji's blog is the most useful reference on using this library and programming the STM8 in general. For use with SDCC the library needs to be patched with Georg's SPL-SDCC patches : unzip en.stsw-stm8069.zip wget https://raw.githubusercontent.com/gicking/STM8-SPL_SDCC_patch/master/STM8S_StdPeriph_Lib_V2.3.1_sdcc.patch patch -p0 < STM8S_StdPeriph_Lib_V2.3.1_sdcc.patch Check out the test project and the project template in STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_test and STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template SDCC uses .rel as the file extension for its object files. Now the library can be compiled for the STM8S103 using this Makefile: CC=sdcc AR=sdar CFLAGS=-c -mstm8 -DSTM8S103 -I ../inc --opt-code-size -I. LDFLAGS=-rc SOURCES= \\ stm8s_adc1.c stm8s_awu.c stm8s_beep.c stm8s_clk.c \\ stm8s_exti.c stm8s_flash.c stm8s_gpio.c stm8s_i2c.c \\ stm8s_itc.c stm8s_iwdg.c stm8s_rst.c stm8s_spi.c \\ stm8s_tim1.c stm8s_tim2.c stm8s_tim4.c stm8s_uart1.c \\ stm8s_wwdg.c OBJECTS=$(SOURCES:.c=.o) OBJECTS_LINK=$(SOURCES:.c=.rel) EXECUTABLE=stm8s.lib all: $(SOURCES) $(EXECUTABLE) $(EXECUTABLE): $(OBJECTS) $(AR) $(LDFLAGS) $(EXECUTABLE) $(OBJECTS_LINK) .c.o: $(CC) $(CFLAGS) $< -o $@ clean: rm -f *.lib *.rst *.rel *.lst *.ihx *.sym *.asm *.lk *.map rm -f $(EXECUTABLE) This library can now be used for linking with blink_spl or uart_spl. The files stm8s_conf.h and stm8s_it.h are still needed for compilation. Optimizing the code The linker does not remove individual unused functions from an object file, only complete object files can be skipped. => for building a library it is better to separate all functions into individual source files See here for details. A suggestion how to move at least the IRQ vectors away from the libray into the own source files: http://richs-words.blogspot.de/2010/09/stm8s-interrupt-handling.html Interrupts Interrupt names are defined in stm8s_itc.h Declaration of an interrupt function for SDCC: /* UART1 TX */ void UART1_TX_IRQHandler(void) __interrupt(ITC_IRQ_UART1_TX) { } Set the matching IRQ enable flag and globally allow interrupts: UART1_ITConfig(UART1_IT_TXE, ENABLE); enableInterrupts(); Not sure about the meaning of the ITC priorities. It works even without them: ITC_DeInit(); ITC_SetSoftwarePriority(ITC_IRQ_UART1_TX, ITC_PRIORITYLEVEL_2);","title":"Using the SPL with SDCC and sduino"},{"location":"developer/spl/#st-standard-peripherie-library","text":"The Library an be downloaded from the ST website (free registration required). A slightly older version is part of the STM8S_Teach presentation , Don't miss the Examples folder within the downloaded zip file. This and Lujji's blog is the most useful reference on using this library and programming the STM8 in general. For use with SDCC the library needs to be patched with Georg's SPL-SDCC patches : unzip en.stsw-stm8069.zip wget https://raw.githubusercontent.com/gicking/STM8-SPL_SDCC_patch/master/STM8S_StdPeriph_Lib_V2.3.1_sdcc.patch patch -p0 < STM8S_StdPeriph_Lib_V2.3.1_sdcc.patch Check out the test project and the project template in STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_test and STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template SDCC uses .rel as the file extension for its object files. Now the library can be compiled for the STM8S103 using this Makefile: CC=sdcc AR=sdar CFLAGS=-c -mstm8 -DSTM8S103 -I ../inc --opt-code-size -I. LDFLAGS=-rc SOURCES= \\ stm8s_adc1.c stm8s_awu.c stm8s_beep.c stm8s_clk.c \\ stm8s_exti.c stm8s_flash.c stm8s_gpio.c stm8s_i2c.c \\ stm8s_itc.c stm8s_iwdg.c stm8s_rst.c stm8s_spi.c \\ stm8s_tim1.c stm8s_tim2.c stm8s_tim4.c stm8s_uart1.c \\ stm8s_wwdg.c OBJECTS=$(SOURCES:.c=.o) OBJECTS_LINK=$(SOURCES:.c=.rel) EXECUTABLE=stm8s.lib all: $(SOURCES) $(EXECUTABLE) $(EXECUTABLE): $(OBJECTS) $(AR) $(LDFLAGS) $(EXECUTABLE) $(OBJECTS_LINK) .c.o: $(CC) $(CFLAGS) $< -o $@ clean: rm -f *.lib *.rst *.rel *.lst *.ihx *.sym *.asm *.lk *.map rm -f $(EXECUTABLE) This library can now be used for linking with blink_spl or uart_spl. The files stm8s_conf.h and stm8s_it.h are still needed for compilation.","title":"ST Standard Peripherie Library"},{"location":"developer/spl/#optimizing-the-code","text":"The linker does not remove individual unused functions from an object file, only complete object files can be skipped. => for building a library it is better to separate all functions into individual source files See here for details. A suggestion how to move at least the IRQ vectors away from the libray into the own source files: http://richs-words.blogspot.de/2010/09/stm8s-interrupt-handling.html","title":"Optimizing the code"},{"location":"developer/spl/#interrupts","text":"Interrupt names are defined in stm8s_itc.h Declaration of an interrupt function for SDCC: /* UART1 TX */ void UART1_TX_IRQHandler(void) __interrupt(ITC_IRQ_UART1_TX) { } Set the matching IRQ enable flag and globally allow interrupts: UART1_ITConfig(UART1_IT_TXE, ENABLE); enableInterrupts(); Not sure about the meaning of the ITC priorities. It works even without them: ITC_DeInit(); ITC_SetSoftwarePriority(ITC_IRQ_UART1_TX, ITC_PRIORITYLEVEL_2);","title":"Interrupts"},{"location":"developer/update-to-manual/","text":"Update to Manual Installation Using the Arduino Board Manager is now the recommended way of installation. Updating to a manual install is only useful if you are planning to use development or experimental branches of Sduino or if you outgrow the possibilities of the Arduino IDE and you are looking for more control by using a proper Makefile controlled build process. Let's compare: Board Manager manual install Difficulty very easy easy on Linux and MacOS, more difficult on Windows. Used Packages latest release release, development or experimental IDE/GUI based builds yes yes Makefile based builds no yes Compiling without Arduino libraries no yes Ok, let's start. Start by cloning or downloading and extracting the repository to a convenient location. Now we need to copy some files from the automatic install into the hardware/sduino/tools folder of this repository to end with a folder structure like this: + hardware/ + sduino (this is a link) + stm8/ core, variants, etc. + tools/ + wrapper/ + win/ stm8flash, libusb.dll, bash, ls, make etc. + linux (link) + linux32/ stm8flash, stmgal + linux64/ stm8flash, stmgal + sdcc can be a link to a full sdcc install After copying you MUST NOT FORGET to use the Board Manager to remove the auto-installed package. Otherwise your are going to use different versions of the sduino core for IDE and Makefile builds. Confusion would be guaranteed! Linux Your local hardware folder is usually in ~/sketchbook or ~/Arduino . Create the hardware folder, if not already present. cd ~/Arduino mkdir hardware Link the hardware/sduino folder of the downloaded repository to your local Arduino hardware folder: ln -s [the-extracted-repository]/sduino/hardware/sduino hardware The needed files from the Board Manager install are in ~/.arduino15/packages/sduino/tools . We want to copy sdcc to /opt and the content of STM8STools into tools : sudo mkdir /opt sudo cp -av ~/.arduino15/packages/sduino/tools/sdcc/<version> /opt/sdcc cp -av ~/.arduino15/packages/sduino/tools/STM8STools/<version>/* tools/ Alternatively, you could download the lastest SDCC snapshot build and extract that into /opt/sdcc instead of copying the packaged version. Create a link to SDCC from the tools directory of the sduino repository (only needed for IDE builds): ln -s /opt/sdcc . stm8flash and stm8gal are both included as precompiled binaries in this tools directory. Copy them to a convient place in your path, e.g. /usr/local/bin : sudo cp -av linux/* /usr/local/bin make and libusb-1.0 (needed by stm8flash) are part of the standard repository for any Linux distribution. Example for Debian-type systems (like Ubuntu, Mint, Elementary etc.): sudo apt-get install make libusb-1.0-0 Now use the Board Manager to remove the auto-installed Sduino package and you are ready. MacOS Quite similar to the Linux install. Install Homebrew if you haven't done it yet, than install make and unpack the sdcc snapshot (if not re-using the packaged version): brew make mkdir /opt tar xvjf sdcc-snapshot* -C /opt Adopt the other steps from the Linux install. The arduino hardware folder is in your Documents folder at /Users/<username>/Documents/Arduino/hardware . Not sure about stm8flash, I didn't try it. Have a look at the stm8flash repository . It would be great if someone could summarize the procedure and send it to me together with a compiled binary for the repository. Windows Link (not copy!) the hardware/sduino folder of the downloaded repository to your local Arduino hardware folder (in Documents/Arduino/hardware ). Create the hardware folder, if not already present. Expected folder structure: Documents/ + Arduino/ + hardware/ + sduino (this is a link) + stm8/ core, variants, etc. + tools/ + wrapper/ + win/ stm8flash, libusb.dll, bash, ls, make etc. + sdcc can be a link to a full sdcc install Don't despair of the stock Windows terminal window. Installing e.g. console2 will make your life on the command line so much more enjoyable. The needed Board Manager install files are in your user folder in AppData/Local/Arduino/packages/sduino/tools . Copy sdcc/<version> and the content of STM8STools/<version into hardware/sduino/tools . Mind the slightly different folder structure. Update your %PATH% : Add a link c:\\sdcc to your SDCC installation directory and add this to your %PATH% . It is very important, that this name does not contain any spaces. Add the sduino/tools/win directory to your path or move/copy/link the files in there to a directory that is already in your path. Open a terminal window and make sure that the binaries are found: $ ls $ sdcc -v If you have installed console2 before, you could even configure it to use bash as your default command shell instead of cmd.exe . Now use the Board Manager to remove the auto-installed Sduino package and you are ready. (Keep the Known problems using Windows in mind)","title":"Update an automatic installation to a manual installation"},{"location":"developer/update-to-manual/#update-to-manual-installation","text":"Using the Arduino Board Manager is now the recommended way of installation. Updating to a manual install is only useful if you are planning to use development or experimental branches of Sduino or if you outgrow the possibilities of the Arduino IDE and you are looking for more control by using a proper Makefile controlled build process. Let's compare: Board Manager manual install Difficulty very easy easy on Linux and MacOS, more difficult on Windows. Used Packages latest release release, development or experimental IDE/GUI based builds yes yes Makefile based builds no yes Compiling without Arduino libraries no yes","title":"Update to Manual Installation"},{"location":"developer/update-to-manual/#ok-lets-start","text":"Start by cloning or downloading and extracting the repository to a convenient location. Now we need to copy some files from the automatic install into the hardware/sduino/tools folder of this repository to end with a folder structure like this: + hardware/ + sduino (this is a link) + stm8/ core, variants, etc. + tools/ + wrapper/ + win/ stm8flash, libusb.dll, bash, ls, make etc. + linux (link) + linux32/ stm8flash, stmgal + linux64/ stm8flash, stmgal + sdcc can be a link to a full sdcc install After copying you MUST NOT FORGET to use the Board Manager to remove the auto-installed package. Otherwise your are going to use different versions of the sduino core for IDE and Makefile builds. Confusion would be guaranteed!","title":"Ok, let's start."},{"location":"developer/update-to-manual/#linux","text":"Your local hardware folder is usually in ~/sketchbook or ~/Arduino . Create the hardware folder, if not already present. cd ~/Arduino mkdir hardware Link the hardware/sduino folder of the downloaded repository to your local Arduino hardware folder: ln -s [the-extracted-repository]/sduino/hardware/sduino hardware The needed files from the Board Manager install are in ~/.arduino15/packages/sduino/tools . We want to copy sdcc to /opt and the content of STM8STools into tools : sudo mkdir /opt sudo cp -av ~/.arduino15/packages/sduino/tools/sdcc/<version> /opt/sdcc cp -av ~/.arduino15/packages/sduino/tools/STM8STools/<version>/* tools/ Alternatively, you could download the lastest SDCC snapshot build and extract that into /opt/sdcc instead of copying the packaged version. Create a link to SDCC from the tools directory of the sduino repository (only needed for IDE builds): ln -s /opt/sdcc . stm8flash and stm8gal are both included as precompiled binaries in this tools directory. Copy them to a convient place in your path, e.g. /usr/local/bin : sudo cp -av linux/* /usr/local/bin make and libusb-1.0 (needed by stm8flash) are part of the standard repository for any Linux distribution. Example for Debian-type systems (like Ubuntu, Mint, Elementary etc.): sudo apt-get install make libusb-1.0-0 Now use the Board Manager to remove the auto-installed Sduino package and you are ready.","title":"Linux"},{"location":"developer/update-to-manual/#macos","text":"Quite similar to the Linux install. Install Homebrew if you haven't done it yet, than install make and unpack the sdcc snapshot (if not re-using the packaged version): brew make mkdir /opt tar xvjf sdcc-snapshot* -C /opt Adopt the other steps from the Linux install. The arduino hardware folder is in your Documents folder at /Users/<username>/Documents/Arduino/hardware . Not sure about stm8flash, I didn't try it. Have a look at the stm8flash repository . It would be great if someone could summarize the procedure and send it to me together with a compiled binary for the repository.","title":"MacOS"},{"location":"developer/update-to-manual/#windows","text":"Link (not copy!) the hardware/sduino folder of the downloaded repository to your local Arduino hardware folder (in Documents/Arduino/hardware ). Create the hardware folder, if not already present. Expected folder structure: Documents/ + Arduino/ + hardware/ + sduino (this is a link) + stm8/ core, variants, etc. + tools/ + wrapper/ + win/ stm8flash, libusb.dll, bash, ls, make etc. + sdcc can be a link to a full sdcc install Don't despair of the stock Windows terminal window. Installing e.g. console2 will make your life on the command line so much more enjoyable. The needed Board Manager install files are in your user folder in AppData/Local/Arduino/packages/sduino/tools . Copy sdcc/<version> and the content of STM8STools/<version into hardware/sduino/tools . Mind the slightly different folder structure. Update your %PATH% : Add a link c:\\sdcc to your SDCC installation directory and add this to your %PATH% . It is very important, that this name does not contain any spaces. Add the sduino/tools/win directory to your path or move/copy/link the files in there to a directory that is already in your path. Open a terminal window and make sure that the binaries are found: $ ls $ sdcc -v If you have installed console2 before, you could even configure it to use bash as your default command shell instead of cmd.exe . Now use the Board Manager to remove the auto-installed Sduino package and you are ready. (Keep the Known problems using Windows in mind)","title":"Windows"},{"location":"hardware/esp14/","text":"ESP-14 An ESP-8266 Wifi-Controller together with a STM8S003 CPU for about $2 - incredible. Since the STM8S003 is almost identical to the STM8S103 used on the STM8S103 breakout boards all software runs here as well. Using the same pin numbering scheme as with the stm8blue boards it looks like this: Differences between the '003 and the '103 CPUs Very slim. All differences that I could find so far: Feature STM8S003 STM8S103 EEPROM size 128 Bytes 640 Bytes I am not sure why the '003 is sold for half the price, or, to put it the other way around, why anybody should choose the '103 at all. Did I miss an important difference? Using the Wifi connection The ESP-14 is basically an ESP-01 Wifi-module together with a STM8S breakout board combined into one PCB. The ESP part comes preprogrammed with the usual ESP AT-Firmware and is connected to the RX/TX pins of the STM8S. It feels like having a classic ATmega8-Arduino with a build-in ESP-01 module. Using the WiFiEsp library we could have a programming experience very similar to using an Arduino with a Wifi-shield or an Arduino Yun. The main problem is the limited flash space of the '003. Even the very basic WebServer example that comes with the WiFiEsp library needs more then 14kB flash and more than 1kB RAM when compiled for an Arduino Uno. Even if the library could be carefully optimized to fit into the 8kB flash of an '003 - there would be no space left for the actual user code. It is still possible to do very simple task by just sending AT-strings to the ESP. But here we are definitly leaving Ardunio territory. Here we have to start from scratch and do it all by ourself. This is not going to be beginner-friendly anymore. The major remaining advantage of the STM8S over the ESP is power efficiency. The STM8S runs on almost nothing, while the ESP draws anything between 50 and 200mA even for the simplest tasks. In most cases you might want to implement the external communication part of the application on the ESP, using the ESP8266 Arduino port . The STM8S is better suited to local control and measurement and other energy- and time-critical tasks. Both CPUs use separate power supply inputs. Using an additional PMOS transistor the STM8S could control the power supply for the ESP and help extending battery life by activating the big brother only when its services are actually required. Poor design choice Overall, the '003 is a very questionable CPU choice by AI Thinker. The '003 is clearly one of the cheapest CPUs on the market, but the applications for this module are heavily restricted the the small flash memory. Why didn't they use an ATmega328? Just one dollar more and the whole Arduino universe opens up. Or at least an STM8S005K6T6C, offering 32kB flash and 2kB RAM for only 40 cents more, if you want to go really cheap. And why would you need an external PMOS to control the ESP power supply? Why is this not included on the PCB already? This could the big killer feature of the current combination. The upside Having a beefy 32 bit CPU and using it as an I/O-coprocessor while running the main application on an resticted 8-bitter is a weired concept. Things like the Arduino Yun or the Arduino WiFi-shield don't make too much sense. It is much more sensible to use the big CPU to control the small one than the other way around. Maybe this board can help to promote that concept.","title":"ESP14 Wifi board (STM8S003F3P6)"},{"location":"hardware/esp14/#esp-14","text":"An ESP-8266 Wifi-Controller together with a STM8S003 CPU for about $2 - incredible. Since the STM8S003 is almost identical to the STM8S103 used on the STM8S103 breakout boards all software runs here as well. Using the same pin numbering scheme as with the stm8blue boards it looks like this:","title":"ESP-14"},{"location":"hardware/esp14/#differences-between-the-003-and-the-103-cpus","text":"Very slim. All differences that I could find so far: Feature STM8S003 STM8S103 EEPROM size 128 Bytes 640 Bytes I am not sure why the '003 is sold for half the price, or, to put it the other way around, why anybody should choose the '103 at all. Did I miss an important difference?","title":"Differences between the '003 and the '103 CPUs"},{"location":"hardware/esp14/#using-the-wifi-connection","text":"The ESP-14 is basically an ESP-01 Wifi-module together with a STM8S breakout board combined into one PCB. The ESP part comes preprogrammed with the usual ESP AT-Firmware and is connected to the RX/TX pins of the STM8S. It feels like having a classic ATmega8-Arduino with a build-in ESP-01 module. Using the WiFiEsp library we could have a programming experience very similar to using an Arduino with a Wifi-shield or an Arduino Yun. The main problem is the limited flash space of the '003. Even the very basic WebServer example that comes with the WiFiEsp library needs more then 14kB flash and more than 1kB RAM when compiled for an Arduino Uno. Even if the library could be carefully optimized to fit into the 8kB flash of an '003 - there would be no space left for the actual user code. It is still possible to do very simple task by just sending AT-strings to the ESP. But here we are definitly leaving Ardunio territory. Here we have to start from scratch and do it all by ourself. This is not going to be beginner-friendly anymore. The major remaining advantage of the STM8S over the ESP is power efficiency. The STM8S runs on almost nothing, while the ESP draws anything between 50 and 200mA even for the simplest tasks. In most cases you might want to implement the external communication part of the application on the ESP, using the ESP8266 Arduino port . The STM8S is better suited to local control and measurement and other energy- and time-critical tasks. Both CPUs use separate power supply inputs. Using an additional PMOS transistor the STM8S could control the power supply for the ESP and help extending battery life by activating the big brother only when its services are actually required.","title":"Using the Wifi connection"},{"location":"hardware/esp14/#poor-design-choice","text":"Overall, the '003 is a very questionable CPU choice by AI Thinker. The '003 is clearly one of the cheapest CPUs on the market, but the applications for this module are heavily restricted the the small flash memory. Why didn't they use an ATmega328? Just one dollar more and the whole Arduino universe opens up. Or at least an STM8S005K6T6C, offering 32kB flash and 2kB RAM for only 40 cents more, if you want to go really cheap. And why would you need an external PMOS to control the ESP power supply? Why is this not included on the PCB already? This could the big killer feature of the current combination.","title":"Poor design choice"},{"location":"hardware/esp14/#the-upside","text":"Having a beefy 32 bit CPU and using it as an I/O-coprocessor while running the main application on an resticted 8-bitter is a weired concept. Things like the Arduino Yun or the Arduino WiFi-shield don't make too much sense. It is much more sensible to use the big CPU to control the small one than the other way around. Maybe this board can help to promote that concept.","title":"The upside"},{"location":"hardware/flashtool/","text":"Flash tool The STM8-Discovery-Boards come with an integrated ST-Link-Interface, but for any other board you need a special flash tools in order to program the CPU. These litte devices look like a generic USB thumb drive and are sold for well under $3 on aliexpress, just search for st-link. As far as I know there is no solution to use a regular Arduino board as a SWIM-capable flash programmer. The universal programmer uprog2 (website in german only) is based on an ATmega664 and it might be possible to use an Arduino Mega board with this software (untested). esp-stlink is a ST-Link programmer based on the ESP8266. It allows programming an STM8 via a Wifi connection. The use of this programmer is supported by stm8flash now, but not yet integrated into the Arduino IDE. I didn't test this yet. Classic ST-Link V2 flash tools There are two main versions of the ST-Link V2 compatible flash tool available: One in a USB-Drive-like metal housing (often pink or blue) and one made by Baite in a green plastic housing. Both work well, but they use a different pinout. Both flash tools support the SWIM protocol for STM8 CPUs and the SWD protocol for the STM32 CPUs. The programmer from Baite additionally supports JTAG and is slightly superior to the more common one in the metal housing. Pinout Recently, very similar looking versions of the metal housing flash tool, but with different pinouts, have been seen. Make sure to check your specific tool before building cables! More information on the hardware and the pinouts Pinout of Chinese ST-Link V2-clone made by Baite with green plasic housing (supports SWIM, SWD and JTAG): +-----+ T_JRST | 1 2| 3V3 5V | 3 4| T_JTCK/T_SWCLK SWIM 5 6| T_JTMS/T_SWDIO GND | 7 8| T_JTDO SWIM RST| 9 10| T_JTDI +-----+ Pinout of Chinese ST-Link V2-clone with metal housing (supports SWIM and SWD): +-----+ RST | 1 2| SWDIO GND | 3 4| GND SWIM 5 6| SWCLK 3V3 | 7 8| 3V3 5V | 9 10| 5V +-----+ Installation for Linux Save this as root in in /etc/udev/rules.d/99-stlink.rules : # ST-Link/V2 programming adapter # ST-Link V1, if using a STM8S discovery board # important: It needs a special entry in /etc/modprob/blacklist ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\" # ST-Link/V2, the china adapter with the green plastic housing ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\" Using the STM8S-Discovery board as a flash programmer is a special case and requires some additional blacklisting . Installation for Windows Download and install the ST-Link/v2 driver before you plug in the flash tool : STSW-LINK009 driver download (Registration required, but very easy) I would love to include this driver with the Sduino install package, but I am not sure if this is covered by the ST licence terms for the driver. Connection to the CPU board The pinout of the SWIM connector P3 on my STM8S103 breakout board fits the pinout of the flash tool in the metal housing perfectly: Signal SWIM connector P3 Baite ST-Link Metal ST-Link 3V3 1 2 7 SWIM 2 5 5 GND 3 7 3 NRST 4 9 1 The Discovery boards made by ST all feature a ST-Link interface as well, but only the Discovery STM8S105 supports the SWIM protocol. The Discovery STM32F0308 implements SWD only and is not usable for the STM8. Pin out CN3 SWD 1 ? detect oder so? 2 JTCK/SWCLK 3 GND 4 JTMS/SWDIO 5 NRST 6 SWO","title":"Flash tool"},{"location":"hardware/flashtool/#flash-tool","text":"The STM8-Discovery-Boards come with an integrated ST-Link-Interface, but for any other board you need a special flash tools in order to program the CPU. These litte devices look like a generic USB thumb drive and are sold for well under $3 on aliexpress, just search for st-link. As far as I know there is no solution to use a regular Arduino board as a SWIM-capable flash programmer. The universal programmer uprog2 (website in german only) is based on an ATmega664 and it might be possible to use an Arduino Mega board with this software (untested). esp-stlink is a ST-Link programmer based on the ESP8266. It allows programming an STM8 via a Wifi connection. The use of this programmer is supported by stm8flash now, but not yet integrated into the Arduino IDE. I didn't test this yet.","title":"Flash tool"},{"location":"hardware/flashtool/#classic-st-link-v2-flash-tools","text":"There are two main versions of the ST-Link V2 compatible flash tool available: One in a USB-Drive-like metal housing (often pink or blue) and one made by Baite in a green plastic housing. Both work well, but they use a different pinout. Both flash tools support the SWIM protocol for STM8 CPUs and the SWD protocol for the STM32 CPUs. The programmer from Baite additionally supports JTAG and is slightly superior to the more common one in the metal housing.","title":"Classic ST-Link V2 flash tools"},{"location":"hardware/flashtool/#pinout","text":"Recently, very similar looking versions of the metal housing flash tool, but with different pinouts, have been seen. Make sure to check your specific tool before building cables! More information on the hardware and the pinouts Pinout of Chinese ST-Link V2-clone made by Baite with green plasic housing (supports SWIM, SWD and JTAG): +-----+ T_JRST | 1 2| 3V3 5V | 3 4| T_JTCK/T_SWCLK SWIM 5 6| T_JTMS/T_SWDIO GND | 7 8| T_JTDO SWIM RST| 9 10| T_JTDI +-----+ Pinout of Chinese ST-Link V2-clone with metal housing (supports SWIM and SWD): +-----+ RST | 1 2| SWDIO GND | 3 4| GND SWIM 5 6| SWCLK 3V3 | 7 8| 3V3 5V | 9 10| 5V +-----+","title":"Pinout"},{"location":"hardware/flashtool/#installation-for-linux","text":"Save this as root in in /etc/udev/rules.d/99-stlink.rules : # ST-Link/V2 programming adapter # ST-Link V1, if using a STM8S discovery board # important: It needs a special entry in /etc/modprob/blacklist ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\" # ST-Link/V2, the china adapter with the green plastic housing ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\" Using the STM8S-Discovery board as a flash programmer is a special case and requires some additional blacklisting .","title":"Installation for Linux"},{"location":"hardware/flashtool/#installation-for-windows","text":"Download and install the ST-Link/v2 driver before you plug in the flash tool : STSW-LINK009 driver download (Registration required, but very easy) I would love to include this driver with the Sduino install package, but I am not sure if this is covered by the ST licence terms for the driver.","title":"Installation for Windows"},{"location":"hardware/flashtool/#connection-to-the-cpu-board","text":"The pinout of the SWIM connector P3 on my STM8S103 breakout board fits the pinout of the flash tool in the metal housing perfectly: Signal SWIM connector P3 Baite ST-Link Metal ST-Link 3V3 1 2 7 SWIM 2 5 5 GND 3 7 3 NRST 4 9 1 The Discovery boards made by ST all feature a ST-Link interface as well, but only the Discovery STM8S105 supports the SWIM protocol. The Discovery STM32F0308 implements SWD only and is not usable for the STM8. Pin out CN3 SWD 1 ? detect oder so? 2 JTCK/SWCLK 3 GND 4 JTMS/SWDIO 5 NRST 6 SWO","title":"Connection to the CPU board"},{"location":"hardware/nucleo8s208rb/","text":"STM8S208MB Nucleo CPU: STM8S208RBT6, 24 MHz, 128kB flash, 6kB RAM Crystal: 8MHz button: PE4 LED: PC5/D13, active high, buffered UART3 as main serial connection Arduino pin GPIO pin Usage D0 PD6 RX (UART3) D1 PD5 TX (UART3) D2 PE0 D3 PC1 PWM D4 PG0 D5 PC2 PWM D6 PC3 PWM D7 PD1 D8 PD3 D9 PC4 PWM D10 PE5 PWM, SPI_SS D11 PC6 PWM, SPI_MOSI D12 PC7 SPI_MISO D13 PC5 SPI_SCK, LED D14 PE2 I2C_SDA D15 PE1 I2C_SCL A0 PB5 A1 PB4 A2 PB3 A3 PB2 A4 PB1 A5 PB0","title":"STM8S208MB Nucleo"},{"location":"hardware/nucleo8s208rb/#stm8s208mb-nucleo","text":"CPU: STM8S208RBT6, 24 MHz, 128kB flash, 6kB RAM Crystal: 8MHz button: PE4 LED: PC5/D13, active high, buffered UART3 as main serial connection Arduino pin GPIO pin Usage D0 PD6 RX (UART3) D1 PD5 TX (UART3) D2 PE0 D3 PC1 PWM D4 PG0 D5 PC2 PWM D6 PC3 PWM D7 PD1 D8 PD3 D9 PC4 PWM D10 PE5 PWM, SPI_SS D11 PC6 PWM, SPI_MOSI D12 PC7 SPI_MISO D13 PC5 SPI_SCK, LED D14 PE2 I2C_SDA D15 PE1 I2C_SCL A0 PB5 A1 PB4 A2 PB3 A3 PB2 A4 PB1 A5 PB0","title":"STM8S208MB Nucleo"},{"location":"hardware/stm8blue/","text":"Generic STM8S103 breakout board These simple breakout boards are available on aliexpress for well under one Dollar (I got mine for 67 cent each, including shipping from China). These boards are my main development platform. Features The hardware features are quite similar to an ATmega8: Boardname stm8blue CPU STM8S103F3P6 Clock 16MHz, internal oscillator Flash 8kB RAM 1kB EEPROM 640 byte I/O voltage 3.3V GPIO 14 serial connections UART, SPI, I2C PWM 4 (up to 7 via alternate mapping) ADC 5 channel, 10 bit LED PB5 (Arduino D3), active low, shared with I2C, red programming interface SWIM, no serial bootloader USB connector mini, power only (data lines not connected) One (red) LED is connected to GPIO PB5 (CPU pin 11). This LED is low active. Please keep in mind that this is one of the I2C signals and using the LED blocks the I2C bus . The push button is for reset. The CPU runs on 3.3V, a linear regulator is integrated on the board. The micro USB connector is only for (5V) power supply, the data lines are not connected. All CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm, perfect for breadboards). They are very similar to the ESP14 Wifi-boards and most programs will work fine on those chinese gems as well. Connection to the flash tool I am using the ST-Link V2 compatible flash tool in the green plastic housing. The one in the metal housing uses a different pinout. Connection to the flashtool: Signal name P3 on CPU board Green flash tool Metal flash tool 3V3 1 2 7 SWIM 2 5 5 GND 3 7 3 NRST 4 9 1 Crap alert Due to bad PCB production quality, some more recent lots (as of 2020) of the stm8blue boards seem to have either no working connection to GND on the SWIM connector or a short circuit from the SWIM pin to GND. The SWIM pin is shortend to GND Try connecting GND to the other GND board pin or power the board via USB. Most boards ship with a pre-programmed blinky. If the LED blinks when the board is powered via USB but doesn't when it is only connected to the flash tool, your board is probably missing the GND connection. Unlocking a write protected MCU My breakout boards came preprogrammed with a blink program and with active write protection bits. For unlocking before first use using the command line: stm8flash -cstlinkv2 -pstm8s103?3 -u The same can be done from the Arduino IDE by clicking on Tools->Burn Bootloader after selecting an STM8 based board and choosing the correct programmer type (ST-Link V2). The name of this menu entry is not self-explanatory, but I couldn't find any way to change it or to add another entry with a better name. (If you know how, please open an issue) The required binary for stm8flash is included in the download of the automatic install. On Windows systems it can be found in the directory AppData\\Local\\Arduino15\\packages\\sduino\\tools\\STM8Tools\\2019.02.05\\win . A GUI alternative is the STVP tool by ST, but this involves installing another software package (see issue#85 ). Pin number mappings The Arduino environment uses its own pin numbering scheme independent from the physical CPU pin numbers. Many Arduino sketches and libraries contain hard-coded assumptions about the number of pins with special functions. Ideally, all these numbers would be the same and all programs could be compiled without changes. Here I discuss some possible pin mapping schemes and check how close we could get to the ideal mapping. Unfortunatly, it turns out that a perfect mapping is not possible. In the end I chose a simple geometric numbering for the square UFQFPN20 package starting with port pin PA1 and counting up from 0. This results in this mapping: sduino pin STM8S103 CPU port pin 0-2 PA1-PA3 (PA1 and PA2 only weak output drivers) 3-4 PB5-PB4 (reverse order) 5-9 PC3-PC7 10-15 PD1-PD6 serial: 14,15 SPI: 2,7,8,9 I2C: 3,4 (true open drain. can't drive a high signal without an external pull-up resistor) Analog: 6,11,12,14,15 PWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping) pros of this approach: Easy and logical for use on a breadboard Very clear and logical port pin ordering TX and RX would be the rarely used analog pin numbers A3/A4 at the end of the analog pin number list At least the analog pins are in data sheet order cons of this approach: Analog pins are still scattered around All functions use totally different pin numbers than Arduino I am still not really happy with this mapping. Instead of simplifing things it only adds another layer of abstraction and confusion. To avoid this I added definitions for the regular CPU pin names like PA1 and PD2 . In the end, this notation seems to be a lot easier to me. I am open for suggestions for a better pin number mapping. The chosen pin mapping for the STM8S103 (possible alternate function in paratheses): Phys. STM8 pin Name Functions Geometrical mapping special funcion 1 PD4 UART_CLK/T2-1/beep 13 PWM 2 PD5 TX/Ain5 14 Analog A3 3 PD6 RX/Ain6 15 Analog A4 5 PA1 (OscIn, no HS) 0 6 PA2 (OscIn, no HS) 1 10 PA3 SS/T2-3 2 PWM 11 PB5 SDA LED 3 12 PB4 SCL 4 13 PC3 T1-3/[T1-n1] 5 PWM, (n~) 14 PC4 T1-4/Ain2/[T1-n2] 6 PWM, Analog A0, (n~) 15 PC5 SCK/[T2-1] 7 (~) 16 PC6 MOSI/[T1-1] 8 (~) 17 PC7 MISO/[T1-2] 9 (~) 18 PD1 (SWIM) 10 19 PD2 Ain3/[T2-3] 11 Analog A1, (~~) 20 PD3 Ain4/T2-2 12 PWM, Analog A2 Special pins The pins D3/D4 (SDA/SCL, PB5/PB4) are different from the others as they are true open drain pins. That means, they only can drive the output low or open. To drive it high, they require an external pull-up resistor. This is the reason why the LED on this breakout board is connected between +3.3V and the pins and not between the pin and GND as usual. This way it is possible to drive the LED by writing a zero to the output register. D5/D6 (PA1/PA2, OscIn/OscOut) are weaker than the other pins. Try avoiding these pins for LEDs and other higher current applications. Schematic","title":"Generic STM8S103F3 breakout board (stm8blue)"},{"location":"hardware/stm8blue/#generic-stm8s103-breakout-board","text":"These simple breakout boards are available on aliexpress for well under one Dollar (I got mine for 67 cent each, including shipping from China). These boards are my main development platform.","title":"Generic STM8S103 breakout board"},{"location":"hardware/stm8blue/#features","text":"The hardware features are quite similar to an ATmega8: Boardname stm8blue CPU STM8S103F3P6 Clock 16MHz, internal oscillator Flash 8kB RAM 1kB EEPROM 640 byte I/O voltage 3.3V GPIO 14 serial connections UART, SPI, I2C PWM 4 (up to 7 via alternate mapping) ADC 5 channel, 10 bit LED PB5 (Arduino D3), active low, shared with I2C, red programming interface SWIM, no serial bootloader USB connector mini, power only (data lines not connected) One (red) LED is connected to GPIO PB5 (CPU pin 11). This LED is low active. Please keep in mind that this is one of the I2C signals and using the LED blocks the I2C bus . The push button is for reset. The CPU runs on 3.3V, a linear regulator is integrated on the board. The micro USB connector is only for (5V) power supply, the data lines are not connected. All CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm, perfect for breadboards). They are very similar to the ESP14 Wifi-boards and most programs will work fine on those chinese gems as well.","title":"Features"},{"location":"hardware/stm8blue/#connection-to-the-flash-tool","text":"I am using the ST-Link V2 compatible flash tool in the green plastic housing. The one in the metal housing uses a different pinout. Connection to the flashtool: Signal name P3 on CPU board Green flash tool Metal flash tool 3V3 1 2 7 SWIM 2 5 5 GND 3 7 3 NRST 4 9 1","title":"Connection to the flash tool"},{"location":"hardware/stm8blue/#crap-alert","text":"Due to bad PCB production quality, some more recent lots (as of 2020) of the stm8blue boards seem to have either no working connection to GND on the SWIM connector or a short circuit from the SWIM pin to GND. The SWIM pin is shortend to GND Try connecting GND to the other GND board pin or power the board via USB. Most boards ship with a pre-programmed blinky. If the LED blinks when the board is powered via USB but doesn't when it is only connected to the flash tool, your board is probably missing the GND connection.","title":"Crap alert"},{"location":"hardware/stm8blue/#unlocking-a-write-protected-mcu","text":"My breakout boards came preprogrammed with a blink program and with active write protection bits. For unlocking before first use using the command line: stm8flash -cstlinkv2 -pstm8s103?3 -u The same can be done from the Arduino IDE by clicking on Tools->Burn Bootloader after selecting an STM8 based board and choosing the correct programmer type (ST-Link V2). The name of this menu entry is not self-explanatory, but I couldn't find any way to change it or to add another entry with a better name. (If you know how, please open an issue) The required binary for stm8flash is included in the download of the automatic install. On Windows systems it can be found in the directory AppData\\Local\\Arduino15\\packages\\sduino\\tools\\STM8Tools\\2019.02.05\\win . A GUI alternative is the STVP tool by ST, but this involves installing another software package (see issue#85 ).","title":"Unlocking a write protected MCU"},{"location":"hardware/stm8blue/#pin-number-mappings","text":"The Arduino environment uses its own pin numbering scheme independent from the physical CPU pin numbers. Many Arduino sketches and libraries contain hard-coded assumptions about the number of pins with special functions. Ideally, all these numbers would be the same and all programs could be compiled without changes. Here I discuss some possible pin mapping schemes and check how close we could get to the ideal mapping. Unfortunatly, it turns out that a perfect mapping is not possible. In the end I chose a simple geometric numbering for the square UFQFPN20 package starting with port pin PA1 and counting up from 0. This results in this mapping: sduino pin STM8S103 CPU port pin 0-2 PA1-PA3 (PA1 and PA2 only weak output drivers) 3-4 PB5-PB4 (reverse order) 5-9 PC3-PC7 10-15 PD1-PD6 serial: 14,15 SPI: 2,7,8,9 I2C: 3,4 (true open drain. can't drive a high signal without an external pull-up resistor) Analog: 6,11,12,14,15 PWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping) pros of this approach: Easy and logical for use on a breadboard Very clear and logical port pin ordering TX and RX would be the rarely used analog pin numbers A3/A4 at the end of the analog pin number list At least the analog pins are in data sheet order cons of this approach: Analog pins are still scattered around All functions use totally different pin numbers than Arduino I am still not really happy with this mapping. Instead of simplifing things it only adds another layer of abstraction and confusion. To avoid this I added definitions for the regular CPU pin names like PA1 and PD2 . In the end, this notation seems to be a lot easier to me. I am open for suggestions for a better pin number mapping. The chosen pin mapping for the STM8S103 (possible alternate function in paratheses): Phys. STM8 pin Name Functions Geometrical mapping special funcion 1 PD4 UART_CLK/T2-1/beep 13 PWM 2 PD5 TX/Ain5 14 Analog A3 3 PD6 RX/Ain6 15 Analog A4 5 PA1 (OscIn, no HS) 0 6 PA2 (OscIn, no HS) 1 10 PA3 SS/T2-3 2 PWM 11 PB5 SDA LED 3 12 PB4 SCL 4 13 PC3 T1-3/[T1-n1] 5 PWM, (n~) 14 PC4 T1-4/Ain2/[T1-n2] 6 PWM, Analog A0, (n~) 15 PC5 SCK/[T2-1] 7 (~) 16 PC6 MOSI/[T1-1] 8 (~) 17 PC7 MISO/[T1-2] 9 (~) 18 PD1 (SWIM) 10 19 PD2 Ain3/[T2-3] 11 Analog A1, (~~) 20 PD3 Ain4/T2-2 12 PWM, Analog A2","title":"Pin number mappings"},{"location":"hardware/stm8blue/#special-pins","text":"The pins D3/D4 (SDA/SCL, PB5/PB4) are different from the others as they are true open drain pins. That means, they only can drive the output low or open. To drive it high, they require an external pull-up resistor. This is the reason why the LED on this breakout board is connected between +3.3V and the pins and not between the pin and GND as usual. This way it is possible to drive the LED by writing a zero to the output register. D5/D6 (PA1/PA2, OscIn/OscOut) are weaker than the other pins. Try avoiding these pins for LEDs and other higher current applications.","title":"Special pins"},{"location":"hardware/stm8blue/#schematic","text":"","title":"Schematic"},{"location":"hardware/stm8s003/","text":"STM8S003 The STM8S003 is almost identical to the STM8S103. The only difference I am aware of is the size of the EEPROM: 128 bytes vs. 640 bytes. I am not sure why the '003 is sold for half the price, or, to put it the other way around, why anybody should choose the '103 at all. Did I miss an important difference? All you have to do in order to develop for the STM8S003 is setting the board manager for ' Generic STM8S103 breakout board '. Just keep in mind not to use EEPROM locations above 127/0x7f. All differences between the CPUs: Feature STM8S003 STM8S103 EEPROM size 128 Bytes 640 Bytes Known development boards I am not aware of any dedicated STM8S003 breakout board, but this CPU is used in many other low-cost boards: ESP-14 Wifi-Module W1209 Temperature controller HC-12 Wireless serial remote module The stm8ef wiki lists more.","title":"Generic STM8S003 support"},{"location":"hardware/stm8s003/#stm8s003","text":"The STM8S003 is almost identical to the STM8S103. The only difference I am aware of is the size of the EEPROM: 128 bytes vs. 640 bytes. I am not sure why the '003 is sold for half the price, or, to put it the other way around, why anybody should choose the '103 at all. Did I miss an important difference? All you have to do in order to develop for the STM8S003 is setting the board manager for ' Generic STM8S103 breakout board '. Just keep in mind not to use EEPROM locations above 127/0x7f. All differences between the CPUs: Feature STM8S003 STM8S103 EEPROM size 128 Bytes 640 Bytes","title":"STM8S003"},{"location":"hardware/stm8s003/#known-development-boards","text":"I am not aware of any dedicated STM8S003 breakout board, but this CPU is used in many other low-cost boards: ESP-14 Wifi-Module W1209 Temperature controller HC-12 Wireless serial remote module The stm8ef wiki lists more.","title":"Known development boards"},{"location":"hardware/stm8sblack/","text":"Generic STM8S105 breakout board These simple breakout boards are are available on aliexpress and the other usual china web sites as \"stm8s105k4t6 development board\" for $1.60 including shipping. STM8S105K4T6 microcontroller, 16 KB Flash, 2 KB RAM, 1 KB EEPROM LED on PE5, active low. external crystal 8MHz on PA1/PA2 or internal oszillator with 16 MHz build-in serial bootloader all I/O-pins accessible on header pins mounting position for 4 pin SWIM connector (for ST-Link flash tool) micro-USB connector for power supply only (data lines not connected) 3.3V I/O voltage, regulator on board These boards are the bigger brother of the STM8S103 breakout boards with more I/O lines, more flash and more EEPROM. They are build around a CPU STM8S105K4T6 with 16MHz internal oscillator, 16kB flash, 2kB RAM, and 1kB EEPROM. The CPU includes a UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 25 I/O pins - almost like an Arduino Nano, but only half the flash space. One (red) LED is connected to GPIO PE5. The push button is for reset. The CPU runs on 3.3V, a linear regulator is integrated on the board. The micro USB connector is only for (5V) power supply, the data lines are not connected. All CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm, perfect for breadboards). I2C not easy accessible Unfortunatly, I2C is only available as an alternate pin function on this CPU. So far, there is no support in Sduino for handling the alternate function remapping bits in the option byte. It is possible to modify these configuration registers via SWIM using a flash tool and stm8flash, but you are on your own there. Connection to the flash tool I am using the ST-Link V2 compatible flash tool in the green plastic housing. The one in the metal housing uses a different pinout. Connection to the flashtool: Signal name P3 on CPU board Green flash tool Metal flash tool 3V3 1 2 7 SWIM 2 5 5 GND 3 7 3 NRST 4 9 1 Pin number mappings The Arduino environment uses its own pin numbering scheme independent from the physical CPU pin numbers. Many Arduino sketches and libraries contain hard-coded assumptions about the number of pins with special functions. Ideally, all these numbers would be the same and all programs could be compiled without changes. Unfortunatly, it turns out that a perfect mapping is not possible. In the end I chose a simple geometric numbering for the module. The numbering is similar to a classic DIP package with the USB connector as the pin 1 marking. It starts with port pin PC3 and counting up from 0. This results in this mapping: sduino pin STM8S105 CPU port pin 0-4 PC3-PC7 5-12 PD0-PD7 13,14 PA1-PA2, connected to the 8 MHz crystal, weak output drivers 16-21 PB5-PB0 (reverse order, weak output drivers) 22 PE5, weak output driver 23,24 PC1-PC2, weak output drivers serial: 10,11 SPI: 2,3,4,22 I2C: 16,17 (has to be activated as an alternative function first) Analog: 16-21 PWM: 0,1,5,7-9,23,24 LED: 22 pros of this approach: Easy and logical for use on a breadboard Very clear and logical port pin ordering cons of this approach: All functions use totally different pin numbers than Arduino I am still not really happy with this mapping. Instead of simplifing things it only adds another layer of abstraction and confusion. To avoid this I added definitions for the regular CPU pin names like PA1 and PD2 . In the end, this notation seems to be a lot easier to me. I am open for suggestions for a better pin number mapping. The chosen pin mapping for the STM8S105K (possible alternate function in paratheses): Phys. STM8 pin Name Functions Geometrical mapping special funcion 2 PA1 (OscIn, no HS) 13 3 PA2 (OscOut, no HS) 14 8 PF4 Ain12 (not supported, no HS) 15 11 PB5 Ain5, [SDA], no HS 16 Analog A0 12 PB4 Ain4, [SCL], no HS 17 Analog A1 13 PB3 Ain3, no HS 18 Analog A2 14 PB2 Ain2, no HS 19 Analog A3 15 PB1 Ain1, no HS 20 Analog A4 16 PB0 Ain0, no HS 21 Analog A5 17 PE5 SPI_NSS, no HS 22 LED 18 PC1 T1-1 23 PWM 19 PC2 T1-2 24 PWM 20 PC3 T1-3 0 PWM 21 PC4 T1-4 1 PWM 22 PC5 SCK 2 23 PC6 MOSI 3 24 PC7 MISO 4 25 PD0 T3-2 5 PWM 26 PD1 SWIM 6 27 PD2 T3-1 7 PWM 28 PD3 T2-2 8 PWM 29 PD4 T2-1/Beep 9 PWM 30 PD5 TX 10 31 PD6 RX 11 32 PD7 TLI 12 Special pins Most pins on the right side are weaker than the other pins. Try avoiding these pins for LEDs and other higher current applications: D13-D22 (PA1/PA2, PF4, PB5-PB0, PE5)","title":"Generic STM8S105K4 breakout board (stm8sblack)"},{"location":"hardware/stm8sblack/#generic-stm8s105-breakout-board","text":"These simple breakout boards are are available on aliexpress and the other usual china web sites as \"stm8s105k4t6 development board\" for $1.60 including shipping. STM8S105K4T6 microcontroller, 16 KB Flash, 2 KB RAM, 1 KB EEPROM LED on PE5, active low. external crystal 8MHz on PA1/PA2 or internal oszillator with 16 MHz build-in serial bootloader all I/O-pins accessible on header pins mounting position for 4 pin SWIM connector (for ST-Link flash tool) micro-USB connector for power supply only (data lines not connected) 3.3V I/O voltage, regulator on board These boards are the bigger brother of the STM8S103 breakout boards with more I/O lines, more flash and more EEPROM. They are build around a CPU STM8S105K4T6 with 16MHz internal oscillator, 16kB flash, 2kB RAM, and 1kB EEPROM. The CPU includes a UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 25 I/O pins - almost like an Arduino Nano, but only half the flash space. One (red) LED is connected to GPIO PE5. The push button is for reset. The CPU runs on 3.3V, a linear regulator is integrated on the board. The micro USB connector is only for (5V) power supply, the data lines are not connected. All CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm, perfect for breadboards).","title":"Generic STM8S105 breakout board"},{"location":"hardware/stm8sblack/#i2c-not-easy-accessible","text":"Unfortunatly, I2C is only available as an alternate pin function on this CPU. So far, there is no support in Sduino for handling the alternate function remapping bits in the option byte. It is possible to modify these configuration registers via SWIM using a flash tool and stm8flash, but you are on your own there.","title":"I2C not easy accessible"},{"location":"hardware/stm8sblack/#connection-to-the-flash-tool","text":"I am using the ST-Link V2 compatible flash tool in the green plastic housing. The one in the metal housing uses a different pinout. Connection to the flashtool: Signal name P3 on CPU board Green flash tool Metal flash tool 3V3 1 2 7 SWIM 2 5 5 GND 3 7 3 NRST 4 9 1","title":"Connection to the flash tool"},{"location":"hardware/stm8sblack/#pin-number-mappings","text":"The Arduino environment uses its own pin numbering scheme independent from the physical CPU pin numbers. Many Arduino sketches and libraries contain hard-coded assumptions about the number of pins with special functions. Ideally, all these numbers would be the same and all programs could be compiled without changes. Unfortunatly, it turns out that a perfect mapping is not possible. In the end I chose a simple geometric numbering for the module. The numbering is similar to a classic DIP package with the USB connector as the pin 1 marking. It starts with port pin PC3 and counting up from 0. This results in this mapping: sduino pin STM8S105 CPU port pin 0-4 PC3-PC7 5-12 PD0-PD7 13,14 PA1-PA2, connected to the 8 MHz crystal, weak output drivers 16-21 PB5-PB0 (reverse order, weak output drivers) 22 PE5, weak output driver 23,24 PC1-PC2, weak output drivers serial: 10,11 SPI: 2,3,4,22 I2C: 16,17 (has to be activated as an alternative function first) Analog: 16-21 PWM: 0,1,5,7-9,23,24 LED: 22 pros of this approach: Easy and logical for use on a breadboard Very clear and logical port pin ordering cons of this approach: All functions use totally different pin numbers than Arduino I am still not really happy with this mapping. Instead of simplifing things it only adds another layer of abstraction and confusion. To avoid this I added definitions for the regular CPU pin names like PA1 and PD2 . In the end, this notation seems to be a lot easier to me. I am open for suggestions for a better pin number mapping. The chosen pin mapping for the STM8S105K (possible alternate function in paratheses): Phys. STM8 pin Name Functions Geometrical mapping special funcion 2 PA1 (OscIn, no HS) 13 3 PA2 (OscOut, no HS) 14 8 PF4 Ain12 (not supported, no HS) 15 11 PB5 Ain5, [SDA], no HS 16 Analog A0 12 PB4 Ain4, [SCL], no HS 17 Analog A1 13 PB3 Ain3, no HS 18 Analog A2 14 PB2 Ain2, no HS 19 Analog A3 15 PB1 Ain1, no HS 20 Analog A4 16 PB0 Ain0, no HS 21 Analog A5 17 PE5 SPI_NSS, no HS 22 LED 18 PC1 T1-1 23 PWM 19 PC2 T1-2 24 PWM 20 PC3 T1-3 0 PWM 21 PC4 T1-4 1 PWM 22 PC5 SCK 2 23 PC6 MOSI 3 24 PC7 MISO 4 25 PD0 T3-2 5 PWM 26 PD1 SWIM 6 27 PD2 T3-1 7 PWM 28 PD3 T2-2 8 PWM 29 PD4 T2-1/Beep 9 PWM 30 PD5 TX 10 31 PD6 RX 11 32 PD7 TLI 12","title":"Pin number mappings"},{"location":"hardware/stm8sblack/#special-pins","text":"Most pins on the right side are weaker than the other pins. Try avoiding these pins for LEDs and other higher current applications: D13-D22 (PA1/PA2, PF4, PB5-PB0, PE5)","title":"Special pins"},{"location":"hardware/stm8sdiscovery/","text":"STM8S Discovery A widespread evaluation board made by ST. All CPU pins are easily accessible on 2x6 pin headers. It costs only $9 and includes a ST-Link/v1 flash programmer on board. It should work now, but the support is not thoroughly tested. At least Blink.c is known to work already. STM8S105C6T6 microcontroller, 32 KB Flash, 2 KB RAM, 1 KB EEPROM LED on PD0, active low. Touch button on PC1, PC2, PC3 external crystal 16MHz on PA1/PA2 The touch pins PC1 and PC3 (Arduino-Pin 24 and 26) are not connected to the pin header on the board. To use them as I/O-pins you need to modify some solder bridges (See STM8S-Discovery user manual). SWIM connector Pinout of CN7 SWIM connector Pin Signal 1 Vdd (3.3V) 2 SWIM 3 GND 4 NRST Usage with Linux and stm8flash The discovery board implements two USB devices: A ST-LINK/V1 interface and a (not very useful) mass storage device with some links to the ST website. The implementation of this mass storage device is very buggy and renders the hole board useless. You need to make modprobe to ignore it by adding this line to /etc/modprobe.conf or by adding a file /etc/modprobe.d/stdiscovery.conf with this line: options usb-storage quirks=0483:3744:i Unplug the Discovery board and unload the usb mass storage driver with modprobe -r uas usb_storage If you can't unload the usb_storage drive because it is in use with other devices you can temporary trigger the same effect by this line: echo \"0483:3744:i\" >/sys/module/usb_storage/parameters/quirks The second step is to add a new udev rule in order to access the USB port. Save this as root in in /etc/udev/rules.d/99-stlink.rules : # ST-Link/V2 programming adapter # ST-Link V1, if using a STM8S discovery board # important: It needs a special entry in /etc/modprobe.d ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\" # ST-Link/V2, the china adapter with the green plastic housing ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\" Finally, it is time to (re-) connect the board. Now dmesg should show that the mass storage device of the Discovery board is ignored: [ 815.228928] usbcore: deregistering interface driver uas [ 815.229201] usbcore: deregistering interface driver usb-storage [ 823.001086] usb 1-3: new full-speed USB device number 7 using xhci_hcd [ 823.374719] usb 1-3: New USB device found, idVendor=0483, idProduct=3744 [ 823.374724] usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3 [ 823.374726] usb 1-3: Product: STM32 STLink [ 823.374728] usb 1-3: Manufacturer: STMicroelectronics [ 823.374730] usb 1-3: SerialNumber: W\\xffffffc3\\xffffffbf\\xffffffbfp\\x06reWW7\\x18\\x12g [ 823.746878] usb-storage 1-3:1.0: USB Mass Storage device detected [ 823.748299] usb-storage 1-3:1.0: device ignored [ 823.748453] usbcore: registered new interface driver usb-storage [ 823.771094] usbcore: registered new interface driver uas Let's read the preinstalled firmware of the STM8S105: stm8flash -cstlink \"-pstm8s105?6\" -r flash.img Further reading AN3332 : Generating PWM signals using STM8S-DISCOVERY AN3259 : RS232 communications with a terminal using the STM8S-DISCOVERY","title":"STM8S105Discovery evaluation board made by ST (STM8S105C6)"},{"location":"hardware/stm8sdiscovery/#stm8s-discovery","text":"A widespread evaluation board made by ST. All CPU pins are easily accessible on 2x6 pin headers. It costs only $9 and includes a ST-Link/v1 flash programmer on board. It should work now, but the support is not thoroughly tested. At least Blink.c is known to work already. STM8S105C6T6 microcontroller, 32 KB Flash, 2 KB RAM, 1 KB EEPROM LED on PD0, active low. Touch button on PC1, PC2, PC3 external crystal 16MHz on PA1/PA2 The touch pins PC1 and PC3 (Arduino-Pin 24 and 26) are not connected to the pin header on the board. To use them as I/O-pins you need to modify some solder bridges (See STM8S-Discovery user manual).","title":"STM8S Discovery"},{"location":"hardware/stm8sdiscovery/#swim-connector","text":"Pinout of CN7 SWIM connector Pin Signal 1 Vdd (3.3V) 2 SWIM 3 GND 4 NRST","title":"SWIM connector"},{"location":"hardware/stm8sdiscovery/#usage-with-linux-and-stm8flash","text":"The discovery board implements two USB devices: A ST-LINK/V1 interface and a (not very useful) mass storage device with some links to the ST website. The implementation of this mass storage device is very buggy and renders the hole board useless. You need to make modprobe to ignore it by adding this line to /etc/modprobe.conf or by adding a file /etc/modprobe.d/stdiscovery.conf with this line: options usb-storage quirks=0483:3744:i Unplug the Discovery board and unload the usb mass storage driver with modprobe -r uas usb_storage If you can't unload the usb_storage drive because it is in use with other devices you can temporary trigger the same effect by this line: echo \"0483:3744:i\" >/sys/module/usb_storage/parameters/quirks The second step is to add a new udev rule in order to access the USB port. Save this as root in in /etc/udev/rules.d/99-stlink.rules : # ST-Link/V2 programming adapter # ST-Link V1, if using a STM8S discovery board # important: It needs a special entry in /etc/modprobe.d ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\" # ST-Link/V2, the china adapter with the green plastic housing ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\" Finally, it is time to (re-) connect the board. Now dmesg should show that the mass storage device of the Discovery board is ignored: [ 815.228928] usbcore: deregistering interface driver uas [ 815.229201] usbcore: deregistering interface driver usb-storage [ 823.001086] usb 1-3: new full-speed USB device number 7 using xhci_hcd [ 823.374719] usb 1-3: New USB device found, idVendor=0483, idProduct=3744 [ 823.374724] usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3 [ 823.374726] usb 1-3: Product: STM32 STLink [ 823.374728] usb 1-3: Manufacturer: STMicroelectronics [ 823.374730] usb 1-3: SerialNumber: W\\xffffffc3\\xffffffbf\\xffffffbfp\\x06reWW7\\x18\\x12g [ 823.746878] usb-storage 1-3:1.0: USB Mass Storage device detected [ 823.748299] usb-storage 1-3:1.0: device ignored [ 823.748453] usbcore: registered new interface driver usb-storage [ 823.771094] usbcore: registered new interface driver uas Let's read the preinstalled firmware of the STM8S105: stm8flash -cstlink \"-pstm8s105?6\" -r flash.img","title":"Usage with Linux and stm8flash"},{"location":"hardware/stm8sdiscovery/#further-reading","text":"AN3332 : Generating PWM signals using STM8S-DISCOVERY AN3259 : RS232 communications with a terminal using the STM8S-DISCOVERY","title":"Further reading"},{"location":"hardware/w1209-thermostat/","text":"W1209 Thermostat module Insanly cheap module with a relay, 3 digit display and a sensor connector. All of that for $1.60 including shipping! STM8S000F3P6 microcontroller, 8 KB Flash, 1 KB RAM, 128 bytes EEPROM 12V supply voltage One relay with indikator LED, max. 5A DC or 15A AC three buttons three digit 7-segment-display, multiplexed external NTC temperture sensor, 10k But please be aware that the PCB layout violates all common safety rules on the high voltage side. No sufficient creeping distance, the PCB traces are way too small to actually carry 15A and the screw terminals are not up to that task either. SWIM connector Pinout of SWIM connector Pin Signal 1 Vcc (5V) 2 SWIM 3 NRST 4 GND Schematic Further reading Functionally identical firmware, GPL2'ed","title":"W1209 thermostat board (STM8S003F3P6)"},{"location":"hardware/w1209-thermostat/#w1209-thermostat-module","text":"Insanly cheap module with a relay, 3 digit display and a sensor connector. All of that for $1.60 including shipping! STM8S000F3P6 microcontroller, 8 KB Flash, 1 KB RAM, 128 bytes EEPROM 12V supply voltage One relay with indikator LED, max. 5A DC or 15A AC three buttons three digit 7-segment-display, multiplexed external NTC temperture sensor, 10k But please be aware that the PCB layout violates all common safety rules on the high voltage side. No sufficient creeping distance, the PCB traces are way too small to actually carry 15A and the screw terminals are not up to that task either.","title":"W1209 Thermostat module"},{"location":"hardware/w1209-thermostat/#swim-connector","text":"Pinout of SWIM connector Pin Signal 1 Vcc (5V) 2 SWIM 3 NRST 4 GND","title":"SWIM connector"},{"location":"hardware/w1209-thermostat/#schematic","text":"","title":"Schematic"},{"location":"hardware/w1209-thermostat/#further-reading","text":"Functionally identical firmware, GPL2'ed","title":"Further reading"},{"location":"usage/board-manager-install/","text":"Installation Using the Arduino Board Manager This is the recommanded way of installation now. Open the Settings tab of the Preferences dialog Enter https://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json as an Additional Boards Manager URL Select sduino in the Boards Manager list (Tools->Board:...->Boards Manager) Click on Install Wait for the download to finsh and you are ready to blink: Open the Boards list at Tools->Board:... You should find a new entry \"STM8S Boards\". Choose STM8S103F3 Breakout Board from the list Open the standard Blink example from File->Examples->01. Basics->Blink Compile it by hitting 'Verify' Easy, isn't it? In order to upload the compiled sketch to a connected board you need to install your flash tool first. Manual install Only if you prefer a Makefile based build over using the Arduino IDE or if you would like to help with the development of Sduino you will have to do a manual installation instead.","title":"Automatic Installation"},{"location":"usage/board-manager-install/#installation","text":"","title":"Installation"},{"location":"usage/board-manager-install/#using-the-arduino-board-manager","text":"This is the recommanded way of installation now. Open the Settings tab of the Preferences dialog Enter https://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json as an Additional Boards Manager URL Select sduino in the Boards Manager list (Tools->Board:...->Boards Manager) Click on Install Wait for the download to finsh and you are ready to blink: Open the Boards list at Tools->Board:... You should find a new entry \"STM8S Boards\". Choose STM8S103F3 Breakout Board from the list Open the standard Blink example from File->Examples->01. Basics->Blink Compile it by hitting 'Verify' Easy, isn't it? In order to upload the compiled sketch to a connected board you need to install your flash tool first.","title":"Using the Arduino Board Manager"},{"location":"usage/board-manager-install/#manual-install","text":"Only if you prefer a Makefile based build over using the Arduino IDE or if you would like to help with the development of Sduino you will have to do a manual installation instead.","title":"Manual install"},{"location":"usage/build-cli/","text":"Building with the Makefile A preconfigured IDE is a great way to start, but sooner or later you will want more control and flexibility. The manual install of Sduino comes with an easy-to-use powerful Makefile based on the amazing Arduino.mk makefile by Sudar . Let's blink an LED using the Blink example from Arduino: /* Blink Turns on an LED on for one second, then off for one second, repeatedly. This example code is in the public domain. */ #include <Arduino.h> // Pin 13 has an LED connected on most Arduino boards. // Pin 3 for the STM8S103 break out board // give it a name: int led = LED_BUILTIN; // the setup routine runs once when you press reset: void setup() { // initialize the digital pin as an output. pinMode(led, OUTPUT); } // the loop routine runs over and over again forever: void loop() { digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(led, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } All we need for a full build is this very basic Makefile (adopt the path of the include statement for your situation): BOARD_TAG = stm8sblue include ../../sduino/sduino.mk Compile and upload it: make upload Done! Your first STM8 based project is up and running! Differences to using the IDE The Arduino IDE saves sketches as .ino or .pde files. These are basically C++ files, but without the need to #include \"Arduino.h\" and without the need to declare function prototypes. These elements are auto-generated by the arduino-builder tool at compile time. The Makefile has only very limited support of these features. If compiling a .pde or .ino file it prepends the source file with an #include \"Arduino.h\" line and tries to compile it as a C file. This is only useful, if your sketch is actually written in C. It doesn't magically converts C++ to C. The main purpose of this simple conversion is to allow compiling the same source file either with the Makefile or with the IDE as the IDE requires the main file to have an .ino extention.","title":"Building with a Makefile"},{"location":"usage/build-cli/#building-with-the-makefile","text":"A preconfigured IDE is a great way to start, but sooner or later you will want more control and flexibility. The manual install of Sduino comes with an easy-to-use powerful Makefile based on the amazing Arduino.mk makefile by Sudar . Let's blink an LED using the Blink example from Arduino: /* Blink Turns on an LED on for one second, then off for one second, repeatedly. This example code is in the public domain. */ #include <Arduino.h> // Pin 13 has an LED connected on most Arduino boards. // Pin 3 for the STM8S103 break out board // give it a name: int led = LED_BUILTIN; // the setup routine runs once when you press reset: void setup() { // initialize the digital pin as an output. pinMode(led, OUTPUT); } // the loop routine runs over and over again forever: void loop() { digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(led, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } All we need for a full build is this very basic Makefile (adopt the path of the include statement for your situation): BOARD_TAG = stm8sblue include ../../sduino/sduino.mk Compile and upload it: make upload Done! Your first STM8 based project is up and running!","title":"Building with the Makefile"},{"location":"usage/build-cli/#differences-to-using-the-ide","text":"The Arduino IDE saves sketches as .ino or .pde files. These are basically C++ files, but without the need to #include \"Arduino.h\" and without the need to declare function prototypes. These elements are auto-generated by the arduino-builder tool at compile time. The Makefile has only very limited support of these features. If compiling a .pde or .ino file it prepends the source file with an #include \"Arduino.h\" line and tries to compile it as a C file. This is only useful, if your sketch is actually written in C. It doesn't magically converts C++ to C. The main purpose of this simple conversion is to allow compiling the same source file either with the Makefile or with the IDE as the IDE requires the main file to have an .ino extention.","title":"Differences to using the IDE"},{"location":"usage/build-ide/","text":"Building with the Arduino IDE Sduino now blends in smoothly with the Arduino IDE. Just choose a matching board type from the list of supported boards at Tools->Board and work as usual. Open the Boards list at Tools->Board:... You should find a new entry \"STM8S Boards\". Choose STM8S103F3 Breakout Board from the list Open the standard Blink example from File->Examples->01. Basics->Blink Compile it by clickin 'Verify' Or upload it to the connected board by clicking 'Upload' Done! Your first STM8 based project is up and running! But keep in mind that it still based on plain C and not 100% Arduino syntax. It is close enough, that even some of the stock example sketches work right out of the box, but others will require small modifications. FIXME: How to access the Sduino adopted example sketches","title":"Building with the IDE"},{"location":"usage/build-ide/#building-with-the-arduino-ide","text":"Sduino now blends in smoothly with the Arduino IDE. Just choose a matching board type from the list of supported boards at Tools->Board and work as usual. Open the Boards list at Tools->Board:... You should find a new entry \"STM8S Boards\". Choose STM8S103F3 Breakout Board from the list Open the standard Blink example from File->Examples->01. Basics->Blink Compile it by clickin 'Verify' Or upload it to the connected board by clicking 'Upload' Done! Your first STM8 based project is up and running! But keep in mind that it still based on plain C and not 100% Arduino syntax. It is close enough, that even some of the stock example sketches work right out of the box, but others will require small modifications. FIXME: How to access the Sduino adopted example sketches","title":"Building with the Arduino IDE"},{"location":"usage/faq/","text":"FAQ/common problems Compilation issues ASlink-Warning-No definition of area SSEG This happens when there is no .pde or .ino file in the project directory, Serial_begin() is not used and only *.c files are compiled. This message means that main.c is not pulled in by the linker because there was no reference to main() anywhere. When processing *.pde/ino files wrapper/sdcc.sh (for IDE builds) or Arduino.mk (for Makefile builds) adds a reference to main: /* add a dummy reference to main() to make sure to pull in main.c from the core library */ void main(void); void (*dummy_variable) () = main; If there is no pde/ino file the user has to make sure main.c is pulled in by the linker or define its own main(). Possible ways to pull in main.c: Use Serial_begin(): This references the variable runSerialEvent which in turn pulls in main.c (some overhead) reference the variable runSerialEvent yourself: begin(){runSerialEvent=0;} (Overhead: 4 bytes flash) add a reference to main() like above. (Overhead: 2 bytes RAM and 2 bytes flash) define your own main() function. Flashing fails on the new board It might be locked/write protected. Check this Hardware issues My new stm8blue board seems dead and does not respond to the flash tool Crap alert: There are known quality issues with some more recent PCB production lots of the stm8blue boards.","title":"FAQ/common problems"},{"location":"usage/faq/#faqcommon-problems","text":"","title":"FAQ/common problems"},{"location":"usage/faq/#compilation-issues","text":"","title":"Compilation issues"},{"location":"usage/faq/#aslink-warning-no-definition-of-area-sseg","text":"This happens when there is no .pde or .ino file in the project directory, Serial_begin() is not used and only *.c files are compiled. This message means that main.c is not pulled in by the linker because there was no reference to main() anywhere. When processing *.pde/ino files wrapper/sdcc.sh (for IDE builds) or Arduino.mk (for Makefile builds) adds a reference to main: /* add a dummy reference to main() to make sure to pull in main.c from the core library */ void main(void); void (*dummy_variable) () = main; If there is no pde/ino file the user has to make sure main.c is pulled in by the linker or define its own main(). Possible ways to pull in main.c: Use Serial_begin(): This references the variable runSerialEvent which in turn pulls in main.c (some overhead) reference the variable runSerialEvent yourself: begin(){runSerialEvent=0;} (Overhead: 4 bytes flash) add a reference to main() like above. (Overhead: 2 bytes RAM and 2 bytes flash) define your own main() function.","title":"ASlink-Warning-No definition of area SSEG"},{"location":"usage/faq/#flashing-fails-on-the-new-board","text":"It might be locked/write protected. Check this","title":"Flashing fails on the new board"},{"location":"usage/faq/#hardware-issues","text":"","title":"Hardware issues"},{"location":"usage/faq/#my-new-stm8blue-board-seems-dead-and-does-not-respond-to-the-flash-tool","text":"Crap alert: There are known quality issues with some more recent PCB production lots of the stm8blue boards.","title":"My new stm8blue board seems dead and does not respond to the flash tool"},{"location":"usage/interrupts/","text":"Pin change interrupts attachInterrupt() and detachInterrupt() implement the pin change external interrupts of the STM8. Pin change interrupts are supported for all pins on ports PA, PB, PC, PD and PE except for PA0, PA1, PA7 and PD7. The higher ports PF..PJ (high pin count CPUs only) don't support interrupts. Pin change interrupt means there is only one common ISR vector for every port. E.g. pin PB2 and PB3 share a common ISR routine and the ISR has to figure out which pin triggered the interrupt. Description The first parameter to attachInterrupt() and detachInterrupt() is an interrupt number. For SDuino this number is identical with the pin number, but for compatibility reasons you should still use digitalPinToInterrupt(pin) to translate the actual digital pin to the specific interrupt number. For example, if you connect to pin 3, use digitalPinToInterrupt(3) as the first parameter to attachInterrupt() . About the Interrupt Service Routine The ISR should be as short and fast as possible. Other interrupts are blocked while the ISR is running. This means millis() will not increment and delay() can't work. delayMicroseconds() does not use any counter, so it will work as normal. Typically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile . Syntax attachInterrupt(digitalPinToInterrupt(pin), ISR, mode) (recommended, fully Arduino compatible) attachInterrupt(interrupt, ISR, mode) (not recommended, only for Arduino compatibility) attachInterrupt(pin, ISR, mode) (Not recommended, even if this call matches the actual implementation. Apart from SDuino this syntax only works on Arduino SAMD Boards, Uno WiFi Rev2, Due, and 101.) Parameters interrupt : For Arduino compatibility only. The interrupt number definitions are identical with the pin numbers. pin : The Arduino pin number (or a generic pin specifier like PB2 ) ISR : the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine. mode : defines when the interrupt should be triggered. Four constants are predefined as valid values: LOW : Falling edge and low level (Arduino: low level only) CHANGE : Rising and falling edge RISING : Rising edge FALLING : Falling edge Returns Nothing Example Code // the pin where the input button is attached. Change, if needed #define BUTTON PA2 // volatile is important, because this variable is modified in IRQ routine volatile uint8_t flag = 0; void on_button_pressed(void) { flag = 1; } void setup() { pinMode(LED_BUILTIN, OUTPUT); digitalWrite(LED_BUILTIN, 1); // turn off the LED pinMode(BUTTON, INPUT_PULLUP); attachInterrupt(digitalPinToInterrupt(BUTTON), on_button_pressed, FALLING); } void loop() { if (flag) { digitalWrite(LED_BUILTIN, 0); delay(300); digitalWrite(LED_BUILTIN, 1); flag = 0; } } Interrupt Numbers Normally you should use digitalPinToInterrupt(pin) , rather than place an interrupt/pin number directly into your sketch. For SDuino the interrupt numbers are identical with the pin numbers and digitalPinToInterrupt(pin) is just an empty preprecessor macro. The only thing to loose is some typing efficiency when writing the sketch, but it preserves some more Arduino compatibility. Sleep mode If enabled, these interrupts wake the CPU from all sleep modes, including halt mode. References Parts of this text are copied from the Arduino Reference The Arduino Reference text and this text is licensed under a Creative Commons Attribution-Share Alike 3.0 License .","title":"Pin change interrupts"},{"location":"usage/interrupts/#pin-change-interrupts","text":"attachInterrupt() and detachInterrupt() implement the pin change external interrupts of the STM8. Pin change interrupts are supported for all pins on ports PA, PB, PC, PD and PE except for PA0, PA1, PA7 and PD7. The higher ports PF..PJ (high pin count CPUs only) don't support interrupts. Pin change interrupt means there is only one common ISR vector for every port. E.g. pin PB2 and PB3 share a common ISR routine and the ISR has to figure out which pin triggered the interrupt.","title":"Pin change interrupts"},{"location":"usage/interrupts/#description","text":"The first parameter to attachInterrupt() and detachInterrupt() is an interrupt number. For SDuino this number is identical with the pin number, but for compatibility reasons you should still use digitalPinToInterrupt(pin) to translate the actual digital pin to the specific interrupt number. For example, if you connect to pin 3, use digitalPinToInterrupt(3) as the first parameter to attachInterrupt() .","title":"Description"},{"location":"usage/interrupts/#about-the-interrupt-service-routine","text":"The ISR should be as short and fast as possible. Other interrupts are blocked while the ISR is running. This means millis() will not increment and delay() can't work. delayMicroseconds() does not use any counter, so it will work as normal. Typically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile .","title":"About the Interrupt Service Routine"},{"location":"usage/interrupts/#syntax","text":"attachInterrupt(digitalPinToInterrupt(pin), ISR, mode) (recommended, fully Arduino compatible) attachInterrupt(interrupt, ISR, mode) (not recommended, only for Arduino compatibility) attachInterrupt(pin, ISR, mode) (Not recommended, even if this call matches the actual implementation. Apart from SDuino this syntax only works on Arduino SAMD Boards, Uno WiFi Rev2, Due, and 101.)","title":"Syntax"},{"location":"usage/interrupts/#parameters","text":"interrupt : For Arduino compatibility only. The interrupt number definitions are identical with the pin numbers. pin : The Arduino pin number (or a generic pin specifier like PB2 ) ISR : the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine. mode : defines when the interrupt should be triggered. Four constants are predefined as valid values: LOW : Falling edge and low level (Arduino: low level only) CHANGE : Rising and falling edge RISING : Rising edge FALLING : Falling edge","title":"Parameters"},{"location":"usage/interrupts/#returns","text":"Nothing","title":"Returns"},{"location":"usage/interrupts/#example-code","text":"// the pin where the input button is attached. Change, if needed #define BUTTON PA2 // volatile is important, because this variable is modified in IRQ routine volatile uint8_t flag = 0; void on_button_pressed(void) { flag = 1; } void setup() { pinMode(LED_BUILTIN, OUTPUT); digitalWrite(LED_BUILTIN, 1); // turn off the LED pinMode(BUTTON, INPUT_PULLUP); attachInterrupt(digitalPinToInterrupt(BUTTON), on_button_pressed, FALLING); } void loop() { if (flag) { digitalWrite(LED_BUILTIN, 0); delay(300); digitalWrite(LED_BUILTIN, 1); flag = 0; } }","title":"Example Code"},{"location":"usage/interrupts/#interrupt-numbers","text":"Normally you should use digitalPinToInterrupt(pin) , rather than place an interrupt/pin number directly into your sketch. For SDuino the interrupt numbers are identical with the pin numbers and digitalPinToInterrupt(pin) is just an empty preprecessor macro. The only thing to loose is some typing efficiency when writing the sketch, but it preserves some more Arduino compatibility.","title":"Interrupt Numbers"},{"location":"usage/interrupts/#sleep-mode","text":"If enabled, these interrupts wake the CPU from all sleep modes, including halt mode.","title":"Sleep mode"},{"location":"usage/interrupts/#references","text":"Parts of this text are copied from the Arduino Reference The Arduino Reference text and this text is licensed under a Creative Commons Attribution-Share Alike 3.0 License .","title":"References"},{"location":"usage/limitations/","text":"Limitations Compatibility with the Arduino world I adopted the Arduino core functionality for the STM8S to set up a simple programming environment. But unfortunatly there is no free C++ compiler for these CPUs. This makes it impossible to do a full port of the whole enviroment and integrate it 100% in the Arduino world as it has been done for the STM32 and the ESP8266. This is not a drop-in replacement for an AVR, but the programming API is still very, very similar. Adopting existing libraries from C++ to C for use with the simplified C API is often easy and can be done quite fast, depending on the degree of dependency on specific hardware features. Using a converter/compiler like cfront to translate from C++ to C might be an option. Float arithmetics Floating point arithmetics is supported by the SDCC standard library, but it comes at a pretty high cost in terms of code space and CPU load. This is how much the generated code grows by using a single float operation compared to using a long int: Floating point operation approx. code size addition 736 Bytes subtraction 754 Bytes division 673 Bytes multiplication 907 Bytes sinf() or cosf() 3346 Bytes log10f() 3437 Bytes The Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple simple program with only very little floating point arithmetics. But it already uses 7336 bytes of flash. A similar sketch using integer arithmetics results in much more compact code occuping only 3791 bytes. Float does work, but is better to be avoided and replaced by fixed point arithmetics whenever possible. Known problems using Windows It works, but using the Arduino.mk makefile with Windows is slow. Very slow. Painfully slow. Compiling-the-Blink-example-takes-about-40-seconds kind of slow. Yes, seriously. No kidding. 40 seconds. Measured on a 3GHz machine with 4GB RAM. There is no easy fix, the underlying problem is a fundamental one. It is not about the compilation itself, it is the way Makefiles are written and executed. The whole concept relies on forking subprocesses for all the shell calls. Unfortunately, there is nothing like a fork in Windows and to work around that is painfully slow. It would be great if somebody would replace the painfully slow parameter checking part of the makefile (that causes the majority of forking) by a single shell script that gets called by the makefile and delivers the results in no time. Or use cmake . Or integrate it somehow into the STVD IDE (This STVD-SDCC integration suite might be useful). Or whatever. Until then the least annoying way out might be using a virtual machine running a simple Linux system. Ubuntu Mate or a basic Debian install for example. Virtual Box is great for this purpose and freely available. The new Linux Subsystem feature of Windows 10 might be another option.","title":"Limitations"},{"location":"usage/limitations/#limitations","text":"","title":"Limitations"},{"location":"usage/limitations/#compatibility-with-the-arduino-world","text":"I adopted the Arduino core functionality for the STM8S to set up a simple programming environment. But unfortunatly there is no free C++ compiler for these CPUs. This makes it impossible to do a full port of the whole enviroment and integrate it 100% in the Arduino world as it has been done for the STM32 and the ESP8266. This is not a drop-in replacement for an AVR, but the programming API is still very, very similar. Adopting existing libraries from C++ to C for use with the simplified C API is often easy and can be done quite fast, depending on the degree of dependency on specific hardware features. Using a converter/compiler like cfront to translate from C++ to C might be an option.","title":"Compatibility with the Arduino world"},{"location":"usage/limitations/#float-arithmetics","text":"Floating point arithmetics is supported by the SDCC standard library, but it comes at a pretty high cost in terms of code space and CPU load. This is how much the generated code grows by using a single float operation compared to using a long int: Floating point operation approx. code size addition 736 Bytes subtraction 754 Bytes division 673 Bytes multiplication 907 Bytes sinf() or cosf() 3346 Bytes log10f() 3437 Bytes The Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple simple program with only very little floating point arithmetics. But it already uses 7336 bytes of flash. A similar sketch using integer arithmetics results in much more compact code occuping only 3791 bytes. Float does work, but is better to be avoided and replaced by fixed point arithmetics whenever possible.","title":"Float arithmetics"},{"location":"usage/limitations/#known-problems-using-windows","text":"It works, but using the Arduino.mk makefile with Windows is slow. Very slow. Painfully slow. Compiling-the-Blink-example-takes-about-40-seconds kind of slow. Yes, seriously. No kidding. 40 seconds. Measured on a 3GHz machine with 4GB RAM. There is no easy fix, the underlying problem is a fundamental one. It is not about the compilation itself, it is the way Makefiles are written and executed. The whole concept relies on forking subprocesses for all the shell calls. Unfortunately, there is nothing like a fork in Windows and to work around that is painfully slow. It would be great if somebody would replace the painfully slow parameter checking part of the makefile (that causes the majority of forking) by a single shell script that gets called by the makefile and delivers the results in no time. Or use cmake . Or integrate it somehow into the STVD IDE (This STVD-SDCC integration suite might be useful). Or whatever. Until then the least annoying way out might be using a virtual machine running a simple Linux system. Ubuntu Mate or a basic Debian install for example. Virtual Box is great for this purpose and freely available. The new Linux Subsystem feature of Windows 10 might be another option.","title":"Known problems using Windows"},{"location":"usage/manual-install/","text":"Manual Installation The recommanded way of installation is now the automatic installation using the Arduino Board Manager. The manual installation described here is only useful if you prefer a Makefile based build over using the Arduino IDE or if you would like to help with the development of Sduino. In any case it is still possible to use the IDE. For all systems start with this: Clone or download and extract the repository to a convenient location. Download the lastest SDCC snapshot build for your system. Support for the STM8 improves significantly from version to version. Do not use the older version of SDCC that might be included in your distribution (Version 3.6 is definitely too old). Linux Sduino core Link the sduino folder of the downloaded repository to your local Arduino hardware folder (usually in ~/sketchbook or ~/Arduino ). Create the hardware folder, if not already present: cd ~/Arduino mkdir hardware # only if not already present ln -s [the-extracted-repository]/sduino hardware SDCC Extract the downloaded SDCC archive under /opt : sudo mkdir /opt sudo tar xvjf ~/Downloads/sdcc-snapshot* -C /opt Create a link to SDCC from the tools directory of the sduino repository (required for IDE builds): cd ~/Arduino/hardware/sduino/tools ln -s /opt/sdcc . Flashtools stm8flash and stm8gal are both included as precompiled binaries in this tools directory. Create a link linux to the linux tools directory that matches your system and copy the binaries to a convient place in your path, e.g. /usr/local/bin : ln -s linux64 linux cp -av linux/* /usr/local/bin make and libusb-1.0 (needed by stm8flash) are part of the standard repository for any Linux distribution. Example for Debian-type systems (like Ubuntu, Mint, Elementary etc.): sudo apt install make libusb-1.0-0 Finally, add a udev rule in order to access the USB port for your flash tool. Save this as root in in /etc/udev/rules.d/99-stlink.rules : # ST-Link/V2 programming adapter # ST-Link V1, if using a STM8S discovery board # important: It needs a special entry in /etc/modprobe.d SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3744\", \\ MODE:=\"0666\", \\ SYMLINK+=\"stlinkv1_%n\" # ST-Link/V2, the china adapter with the green plastic housing SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", \\ MODE:=\"0666\", \\ SYMLINK+=\"stlinkv2_%n\" # ST-Link/V2.1, the new Nucleo STM8 boards SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", \\ MODE:=\"0666\", \\ SYMLINK+=\"stlinkv2-1_%n\" Using the STM8S-Discovery board as a flash programmer requires a special modprobe configuration entry . MacOS Quite similar to the Linux install. Install Homebrew if you haven't done it yet, than install make and unpack the sdcc snapshot: brew make mkdir /opt tar xvjf sdcc-snapshot* -C /opt Adopt the other steps from the Linux install. The arduino hardware folder is in your Documents folder at /Users/<username>/Documents/Arduino/hardware . Not sure about stm8flash, I didn't try it. Have a look at the stm8flash repository . It would be great if someone could summarize the procedure and send it to me. Windows Same idea again, but additionally we need to install a minimal command line environment with all the tools needed by make and the Makefile. Let's start with that: Installing a command line environment This can be any of these options (in order of complexity): busybox and make Msys2 MinGW Cygwin The makefile sduino.mk uses busybox by default when running on Windows. To change that, set these environment variables accordingly: SHELL=bash .SHELLFLAGS=-c Alternativly, it is possible to include these lines in the project Makefile or edit sduino.mk directly (lines 68, 69). Install busybox and make This is by far the easiest way to get going. busybox already comes with sduino in the hardware/sduino/tools/win/ folder. A statically linked copy of make-4.2 can be found in the windowstools repository. Just copy these two binaries into a place somewhere in your %PATH% . Install Msys2 Msys2/mingw is more capable than busybox and even comes with a proper package manager. Install this if you plan on using the command line tools for more than just running sdunio compilations. mingw is a full (cross-) compilation environment and it uses msys2, which is just a collection of basic UNIX tools. msys2 is enough for using sduino. Download and run the installer from http://www.msys2.org Install make: pacman -S make define the environment variable HOME in the windows settings as %USERPROFILE% close and re-open the terminal window Now we can start working. (Or read the excellent and more comprehensive installation guide on https://github.com/orlp/dev-on-windows/wiki/Installing-GCC--&-MSYS2 ) Cygwin cygwin is similar to msys2, but even more complete in the sense that it tries to emulate a full POSIX environment. It is really more like a virtual machine than just a set of libraries. Almost anything that compiles for UNIX can be compiled for cygwin with minimal effort. The downside is that the resulting binaries are linked against cygwin specific libraries and that they don't mix very well with Windows native applications. It is possible to do it, but it might require some extra effort. Install this if you need full POSIX compliance. (e.g. compiling stm8flash with support for espstlink, that requires the POSIX termios library). Install the core files and SDCC Thanks to the running bash the remaining steps are the same as for Linux, the only difference is your Arduino folder in Documents/Arduino . ST-Link, stm8flash If not already done, install the ST-Link driver from the ST website for hardware access. You are not bound to stm8flash , you can use the regular flash tool by ST if you prefer. stm8flash and libusb-1.0.dll are both included as precompiled binaries in the tools directory. Copy or link them to a directory in your path: cd hardware/sduino/tools/win cp -av stm8flash.exe libusb-1.0.dll /bin Limitations Keep the known problems using Windows in mind. Additional suggestions for Windows users Get a better console There is no good reason to keep suffering from the stock Windows terminal window. Installing e.g. console2 will make your life on the command line so much more enjoyable. Installation shortcut Instead of installing mingw and sdcc from scratch you can manually unpack the latest board manager tools archive sduino-tools_mingw32*.tar.bz2 into the hardware/sduino/tools folder set c:\\sdcc as a link to the sdcc folder Add tools/win and c:\\sdcc\\bin to your `%PATH% As a workaround for unpacking a tar.bz2 file (again, Windows is lacking even the most basic tools...) you could use the board manager and copy the needed files out of Appdata/Arduino/packages/sduino. But mind the slightly different directory layout and don't forget to remove the package again after you are done copying. Otherwise your are going to use different versions of the sduino core for IDE and Makefile builds. Confusion would be guaranteed! Using MinGW instead of msys2 I used to recommand using MinGW, because it is more compact than msys2. But installation is a little more complicated. If you are like me and prefer minimal solutions over big packages: Check the MinGW Installation Notes Download and run mingw-get-setup.exe You can safely deactivate the graphical option. Add ;c:\\mingw\\bin;c:\\mingw\\msys\\1.0\\bin to the end of your %PATH% Open a command line and install msys-base: mingw-get install msys-base Now ls or make should work. Start a bash: bash For now you might want to set the HOME variable: export HOME=/c/Users/<yourusername> . In the long run this goes in .bashrc . Additional general tweaks The full SDCC archive includes support for many CPUs, but you only need the stm8. You can safely delete all the files related to the PIC CPUs in the pic* and non-free directories. That safes more than 90% of the used disk space and leaves only 20MB out of 240MB.","title":"Manual Installation"},{"location":"usage/manual-install/#manual-installation","text":"The recommanded way of installation is now the automatic installation using the Arduino Board Manager. The manual installation described here is only useful if you prefer a Makefile based build over using the Arduino IDE or if you would like to help with the development of Sduino. In any case it is still possible to use the IDE. For all systems start with this: Clone or download and extract the repository to a convenient location. Download the lastest SDCC snapshot build for your system. Support for the STM8 improves significantly from version to version. Do not use the older version of SDCC that might be included in your distribution (Version 3.6 is definitely too old).","title":"Manual Installation"},{"location":"usage/manual-install/#linux","text":"","title":"Linux"},{"location":"usage/manual-install/#sduino-core","text":"Link the sduino folder of the downloaded repository to your local Arduino hardware folder (usually in ~/sketchbook or ~/Arduino ). Create the hardware folder, if not already present: cd ~/Arduino mkdir hardware # only if not already present ln -s [the-extracted-repository]/sduino hardware","title":"Sduino core"},{"location":"usage/manual-install/#sdcc","text":"Extract the downloaded SDCC archive under /opt : sudo mkdir /opt sudo tar xvjf ~/Downloads/sdcc-snapshot* -C /opt Create a link to SDCC from the tools directory of the sduino repository (required for IDE builds): cd ~/Arduino/hardware/sduino/tools ln -s /opt/sdcc .","title":"SDCC"},{"location":"usage/manual-install/#flashtools","text":"stm8flash and stm8gal are both included as precompiled binaries in this tools directory. Create a link linux to the linux tools directory that matches your system and copy the binaries to a convient place in your path, e.g. /usr/local/bin : ln -s linux64 linux cp -av linux/* /usr/local/bin make and libusb-1.0 (needed by stm8flash) are part of the standard repository for any Linux distribution. Example for Debian-type systems (like Ubuntu, Mint, Elementary etc.): sudo apt install make libusb-1.0-0 Finally, add a udev rule in order to access the USB port for your flash tool. Save this as root in in /etc/udev/rules.d/99-stlink.rules : # ST-Link/V2 programming adapter # ST-Link V1, if using a STM8S discovery board # important: It needs a special entry in /etc/modprobe.d SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3744\", \\ MODE:=\"0666\", \\ SYMLINK+=\"stlinkv1_%n\" # ST-Link/V2, the china adapter with the green plastic housing SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", \\ MODE:=\"0666\", \\ SYMLINK+=\"stlinkv2_%n\" # ST-Link/V2.1, the new Nucleo STM8 boards SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", \\ MODE:=\"0666\", \\ SYMLINK+=\"stlinkv2-1_%n\" Using the STM8S-Discovery board as a flash programmer requires a special modprobe configuration entry .","title":"Flashtools"},{"location":"usage/manual-install/#macos","text":"Quite similar to the Linux install. Install Homebrew if you haven't done it yet, than install make and unpack the sdcc snapshot: brew make mkdir /opt tar xvjf sdcc-snapshot* -C /opt Adopt the other steps from the Linux install. The arduino hardware folder is in your Documents folder at /Users/<username>/Documents/Arduino/hardware . Not sure about stm8flash, I didn't try it. Have a look at the stm8flash repository . It would be great if someone could summarize the procedure and send it to me.","title":"MacOS"},{"location":"usage/manual-install/#windows","text":"Same idea again, but additionally we need to install a minimal command line environment with all the tools needed by make and the Makefile. Let's start with that:","title":"Windows"},{"location":"usage/manual-install/#installing-a-command-line-environment","text":"This can be any of these options (in order of complexity): busybox and make Msys2 MinGW Cygwin The makefile sduino.mk uses busybox by default when running on Windows. To change that, set these environment variables accordingly: SHELL=bash .SHELLFLAGS=-c Alternativly, it is possible to include these lines in the project Makefile or edit sduino.mk directly (lines 68, 69).","title":"Installing a command line environment"},{"location":"usage/manual-install/#install-busybox-and-make","text":"This is by far the easiest way to get going. busybox already comes with sduino in the hardware/sduino/tools/win/ folder. A statically linked copy of make-4.2 can be found in the windowstools repository. Just copy these two binaries into a place somewhere in your %PATH% .","title":"Install busybox and make"},{"location":"usage/manual-install/#install-msys2","text":"Msys2/mingw is more capable than busybox and even comes with a proper package manager. Install this if you plan on using the command line tools for more than just running sdunio compilations. mingw is a full (cross-) compilation environment and it uses msys2, which is just a collection of basic UNIX tools. msys2 is enough for using sduino. Download and run the installer from http://www.msys2.org Install make: pacman -S make define the environment variable HOME in the windows settings as %USERPROFILE% close and re-open the terminal window Now we can start working. (Or read the excellent and more comprehensive installation guide on https://github.com/orlp/dev-on-windows/wiki/Installing-GCC--&-MSYS2 )","title":"Install Msys2"},{"location":"usage/manual-install/#cygwin","text":"cygwin is similar to msys2, but even more complete in the sense that it tries to emulate a full POSIX environment. It is really more like a virtual machine than just a set of libraries. Almost anything that compiles for UNIX can be compiled for cygwin with minimal effort. The downside is that the resulting binaries are linked against cygwin specific libraries and that they don't mix very well with Windows native applications. It is possible to do it, but it might require some extra effort. Install this if you need full POSIX compliance. (e.g. compiling stm8flash with support for espstlink, that requires the POSIX termios library).","title":"Cygwin"},{"location":"usage/manual-install/#install-the-core-files-and-sdcc","text":"Thanks to the running bash the remaining steps are the same as for Linux, the only difference is your Arduino folder in Documents/Arduino .","title":"Install the core files and SDCC"},{"location":"usage/manual-install/#st-link-stm8flash","text":"If not already done, install the ST-Link driver from the ST website for hardware access. You are not bound to stm8flash , you can use the regular flash tool by ST if you prefer. stm8flash and libusb-1.0.dll are both included as precompiled binaries in the tools directory. Copy or link them to a directory in your path: cd hardware/sduino/tools/win cp -av stm8flash.exe libusb-1.0.dll /bin","title":"ST-Link, stm8flash"},{"location":"usage/manual-install/#limitations","text":"Keep the known problems using Windows in mind.","title":"Limitations"},{"location":"usage/manual-install/#additional-suggestions-for-windows-users","text":"","title":"Additional suggestions for Windows users"},{"location":"usage/manual-install/#get-a-better-console","text":"There is no good reason to keep suffering from the stock Windows terminal window. Installing e.g. console2 will make your life on the command line so much more enjoyable.","title":"Get a better console"},{"location":"usage/manual-install/#installation-shortcut","text":"Instead of installing mingw and sdcc from scratch you can manually unpack the latest board manager tools archive sduino-tools_mingw32*.tar.bz2 into the hardware/sduino/tools folder set c:\\sdcc as a link to the sdcc folder Add tools/win and c:\\sdcc\\bin to your `%PATH% As a workaround for unpacking a tar.bz2 file (again, Windows is lacking even the most basic tools...) you could use the board manager and copy the needed files out of Appdata/Arduino/packages/sduino. But mind the slightly different directory layout and don't forget to remove the package again after you are done copying. Otherwise your are going to use different versions of the sduino core for IDE and Makefile builds. Confusion would be guaranteed!","title":"Installation shortcut"},{"location":"usage/manual-install/#using-mingw-instead-of-msys2","text":"I used to recommand using MinGW, because it is more compact than msys2. But installation is a little more complicated. If you are like me and prefer minimal solutions over big packages: Check the MinGW Installation Notes Download and run mingw-get-setup.exe You can safely deactivate the graphical option. Add ;c:\\mingw\\bin;c:\\mingw\\msys\\1.0\\bin to the end of your %PATH% Open a command line and install msys-base: mingw-get install msys-base Now ls or make should work. Start a bash: bash For now you might want to set the HOME variable: export HOME=/c/Users/<yourusername> . In the long run this goes in .bashrc .","title":"Using MinGW instead of msys2"},{"location":"usage/manual-install/#additional-general-tweaks","text":"The full SDCC archive includes support for many CPUs, but you only need the stm8. You can safely delete all the files related to the PIC CPUs in the pic* and non-free directories. That safes more than 90% of the used disk space and leaves only 20MB out of 240MB.","title":"Additional general tweaks"},{"location":"usage/status-todo/","text":"Status and Todo Current status tested and working pinMode() digitalWrite() analogRead() delay() analogWrite() ShiftOut() WMath: map() serialEvent() pulseInLong() HardwareSerial : Standard UART interface with Print functions Print : Formatting functions to be used with the other output libraries SPI : working, no interrupt support LiquidCrystal : Text LCD based on the HD44780 controller PCD8544 : Nokia 5110 type displays Mini_SSD1306 : Monochrome OLED displays based on the SSD1306 controller Stepper : Multi-instance design for more than one stepper at a time Servo : Multi-instance design for more than one servo at a time) implemented and partly working Wire/I2C tested, but not working alternateFunctions() not tested ShiftIn() random() srandom() not implemented tone() noTone() pulseIn() handling of write error in Print (methods setWriteError etc.) module WCharacter module WString Todo Interesting libraries that might be worth porting cI2C : Arduino Hardware I2C for AVR (plain c) SimpleDHT : Simple, Stable and Fast Arduino Temp & Humidity Sensors for DHT11 and DHT22. It started out as plain C code (v1.0.0), but was converted to (simple) C++ with v1.0.1 cQueue : Queue handling library (written in plain c). But maybe too high-level to be worth using on very small devices. RTCtime : This library makes using modules based on the DS1307 and DS3231 RTC really easy. It is compatible with and is meant to leverage the standard C time library time.h API (datatypes and functions) as defined in ISO/IEC 9899 (C90) and implemented in the AVR Std C runtime libray since version 2.0.0. FatFS : FatFs is a generic FAT file system module for small embedded systems. The FatFs is written in compliance with ANSI C and completely separated from the disk I/O layer. Therefore it is independent of hardware architecture. stm32duino port of FatFS by elm-chan . A stripped down version exists as Petit FAT File System Module for very small CPU. Only 2..4kB flash usage. Unresolved problems The compile environment needs to detect which interrupts are actively used and link only the needed ones into the binary. See test/digitalWrite: Compiling with the straight Makefile.classic does not add UART interrupt routines. But when using the sduino.mk Makefile the two UART interrupt routines are pulled into the binary by the interrupt table in main.c.","title":"Status and todo"},{"location":"usage/status-todo/#status-and-todo","text":"","title":"Status and Todo"},{"location":"usage/status-todo/#current-status","text":"","title":"Current status"},{"location":"usage/status-todo/#tested-and-working","text":"pinMode() digitalWrite() analogRead() delay() analogWrite() ShiftOut() WMath: map() serialEvent() pulseInLong() HardwareSerial : Standard UART interface with Print functions Print : Formatting functions to be used with the other output libraries SPI : working, no interrupt support LiquidCrystal : Text LCD based on the HD44780 controller PCD8544 : Nokia 5110 type displays Mini_SSD1306 : Monochrome OLED displays based on the SSD1306 controller Stepper : Multi-instance design for more than one stepper at a time Servo : Multi-instance design for more than one servo at a time)","title":"tested and working"},{"location":"usage/status-todo/#implemented-and-partly-working","text":"Wire/I2C","title":"implemented and partly working"},{"location":"usage/status-todo/#tested-but-not-working","text":"alternateFunctions()","title":"tested, but not working"},{"location":"usage/status-todo/#not-tested","text":"ShiftIn() random() srandom()","title":"not tested"},{"location":"usage/status-todo/#not-implemented","text":"tone() noTone() pulseIn() handling of write error in Print (methods setWriteError etc.) module WCharacter module WString","title":"not implemented"},{"location":"usage/status-todo/#todo","text":"","title":"Todo"},{"location":"usage/status-todo/#interesting-libraries-that-might-be-worth-porting","text":"cI2C : Arduino Hardware I2C for AVR (plain c) SimpleDHT : Simple, Stable and Fast Arduino Temp & Humidity Sensors for DHT11 and DHT22. It started out as plain C code (v1.0.0), but was converted to (simple) C++ with v1.0.1 cQueue : Queue handling library (written in plain c). But maybe too high-level to be worth using on very small devices. RTCtime : This library makes using modules based on the DS1307 and DS3231 RTC really easy. It is compatible with and is meant to leverage the standard C time library time.h API (datatypes and functions) as defined in ISO/IEC 9899 (C90) and implemented in the AVR Std C runtime libray since version 2.0.0. FatFS : FatFs is a generic FAT file system module for small embedded systems. The FatFs is written in compliance with ANSI C and completely separated from the disk I/O layer. Therefore it is independent of hardware architecture. stm32duino port of FatFS by elm-chan . A stripped down version exists as Petit FAT File System Module for very small CPU. Only 2..4kB flash usage.","title":"Interesting libraries that might be worth porting"},{"location":"usage/status-todo/#unresolved-problems","text":"The compile environment needs to detect which interrupts are actively used and link only the needed ones into the binary. See test/digitalWrite: Compiling with the straight Makefile.classic does not add UART interrupt routines. But when using the sduino.mk Makefile the two UART interrupt routines are pulled into the binary by the interrupt table in main.c.","title":"Unresolved problems"},{"location":"usage/why-stm8/","text":"Let's ask the forbidden question: Why? The fine line between sense and nonsense. When to use an STM8 - and when not Hobby applications The fairly new ESP-14 module includes a STM8S003F3P6: Wifi and a programmable I/O-CPU for just over two dollars - that might be the most compelling reason to get started on the STM8S series. Apart from pure curiosity and eagerness to learn something new, of course. The simple STM8S103F breakout boards are powerful and dirt cheap. They cost well under one dollar. You can get three boards and one flash programmer together for well under five dollars on aliexpress , including shipping from China. That is an extremely good opportunity to learn something new. The major downside of this CPU series is the lack of information and community support for the STM8. The community support and the sheer number of existing libraries for all kinds of sensors and hardware is outstanding in the Arduino world. Don't let the tempting price tag be your only guide. An Arduino Nano compatible board is not that much more expensive: They start at $1.90 on aliexpress . That is only $1.20 more than an STM8S. I am sure you can afford that. If you just want to get something done, go for an Arduino board. Nothing will give you faster and easier results. (Or an STM32F103 bluepill for the same price if you need more computing power). Tinkering and Repurposing The STM8 series by ST might be the cheapest CPUs on the market while still being as powerful as the ATmega series. That makes them every Chinese engineer's darling and chances are pretty good that you will find an '003 if you crack open any cheap appliance like an irrigation, temperature, or charging controller. Things like the W1209 thermostat boards could be useful for almost every kind of sensor application. There is plenty of cheap stuff around that only needs a different firmware to be used for something. And Sduino might be just the right tool to help you doing this. Commercial applications For commercial use the STM8S offers some interesting advantages: Motor control : The STM8 has a strong focus on motor and position control systems. Things you need to handle yourself on an ATmega are implemented in hardware and work independently of the state of the software. There is even hardware support for quadrature encoders as used in position sensors and rotary encoders. Low power modes : The numbers in the datasheets don't look that different, but in real life the STM8 can be powered two or three times longer using the same battery capacity due to the finer control on the power modes (very, very careful programming required). Value for the money : 40 to 60 cents for a STM8 with 14 I/O pins compared to $1.60-$3.00 for an ATmega8. Upgrade path : The peripheral units of the STM8 are identical or at least very, very similar to the ones used with the STM32 family of 32 bit ARM-Cortex CPUs. This makes it relatively easy to migrate existing software between the 8- and the 32-bit world. This is quite unique among the other CPUs.","title":"When to use an STM8S - and when not"},{"location":"usage/why-stm8/#why","text":"The fine line between sense and nonsense.","title":"Why?"},{"location":"usage/why-stm8/#when-to-use-an-stm8-and-when-not","text":"","title":"When to use an STM8 - and when not"},{"location":"usage/why-stm8/#hobby-applications","text":"The fairly new ESP-14 module includes a STM8S003F3P6: Wifi and a programmable I/O-CPU for just over two dollars - that might be the most compelling reason to get started on the STM8S series. Apart from pure curiosity and eagerness to learn something new, of course. The simple STM8S103F breakout boards are powerful and dirt cheap. They cost well under one dollar. You can get three boards and one flash programmer together for well under five dollars on aliexpress , including shipping from China. That is an extremely good opportunity to learn something new. The major downside of this CPU series is the lack of information and community support for the STM8. The community support and the sheer number of existing libraries for all kinds of sensors and hardware is outstanding in the Arduino world. Don't let the tempting price tag be your only guide. An Arduino Nano compatible board is not that much more expensive: They start at $1.90 on aliexpress . That is only $1.20 more than an STM8S. I am sure you can afford that. If you just want to get something done, go for an Arduino board. Nothing will give you faster and easier results. (Or an STM32F103 bluepill for the same price if you need more computing power).","title":"Hobby applications"},{"location":"usage/why-stm8/#tinkering-and-repurposing","text":"The STM8 series by ST might be the cheapest CPUs on the market while still being as powerful as the ATmega series. That makes them every Chinese engineer's darling and chances are pretty good that you will find an '003 if you crack open any cheap appliance like an irrigation, temperature, or charging controller. Things like the W1209 thermostat boards could be useful for almost every kind of sensor application. There is plenty of cheap stuff around that only needs a different firmware to be used for something. And Sduino might be just the right tool to help you doing this.","title":"Tinkering and Repurposing"},{"location":"usage/why-stm8/#commercial-applications","text":"For commercial use the STM8S offers some interesting advantages: Motor control : The STM8 has a strong focus on motor and position control systems. Things you need to handle yourself on an ATmega are implemented in hardware and work independently of the state of the software. There is even hardware support for quadrature encoders as used in position sensors and rotary encoders. Low power modes : The numbers in the datasheets don't look that different, but in real life the STM8 can be powered two or three times longer using the same battery capacity due to the finer control on the power modes (very, very careful programming required). Value for the money : 40 to 60 cents for a STM8 with 14 I/O pins compared to $1.60-$3.00 for an ATmega8. Upgrade path : The peripheral units of the STM8 are identical or at least very, very similar to the ones used with the STM32 family of 32 bit ARM-Cortex CPUs. This makes it relatively easy to migrate existing software between the 8- and the 32-bit world. This is quite unique among the other CPUs.","title":"Commercial applications"}]}